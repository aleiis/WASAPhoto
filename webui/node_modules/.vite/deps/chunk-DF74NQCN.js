import {
  diag,
  metrics,
  trace
} from "./chunk-EOA2FUOG.js";
import {
  __commonJS,
  __toESM
} from "./chunk-TWLJ45QX.js";

// node_modules/shimmer/index.js
var require_shimmer = __commonJS({
  "node_modules/shimmer/index.js"(exports, module) {
    "use strict";
    function isFunction(funktion) {
      return typeof funktion === "function";
    }
    var logger = console.error.bind(console);
    function defineProperty(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function shimmer2(options) {
      if (options && options.logger) {
        if (!isFunction(options.logger))
          logger("new logger isn't a function, not replacing");
        else
          logger = options.logger;
      }
    }
    function wrap2(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger("no original function " + name + " to wrap");
        return;
      }
      if (!wrapper) {
        logger("no wrapper function");
        logger(new Error().stack);
        return;
      }
      if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
        logger("original object and wrapper must be functions");
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      defineProperty(wrapped, "__original", original);
      defineProperty(wrapped, "__unwrap", function() {
        if (nodule[name] === wrapped)
          defineProperty(nodule, name, original);
      });
      defineProperty(wrapped, "__wrapped", true);
      defineProperty(nodule, name, wrapped);
      return wrapped;
    }
    function massWrap2(nodules, names, wrapper) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to wrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          wrap2(nodule, name, wrapper);
        });
      });
    }
    function unwrap2(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger("no function to unwrap.");
        logger(new Error().stack);
        return;
      }
      if (!nodule[name].__unwrap) {
        logger("no original to unwrap to -- has " + name + " already been unwrapped?");
      } else {
        return nodule[name].__unwrap();
      }
    }
    function massUnwrap2(nodules, names) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to unwrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          unwrap2(nodule, name);
        });
      });
    }
    shimmer2.wrap = wrap2;
    shimmer2.massWrap = massWrap2;
    shimmer2.unwrap = unwrap2;
    shimmer2.massUnwrap = massUnwrap2;
    module.exports = shimmer2;
  }
});

// node_modules/@opentelemetry/api-logs/build/esm/types/LogRecord.js
var SeverityNumber;
(function(SeverityNumber2) {
  SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
  SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
  SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
  SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
  SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
  SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
  SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
  SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
  SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
  SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
  SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
  SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
  SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
  SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
  SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
  SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
  SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
  SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
  SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
  SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
  SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
  SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
  SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
  SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
})(SeverityNumber || (SeverityNumber = {}));

// node_modules/@opentelemetry/api-logs/build/esm/NoopLogger.js
var NoopLogger = function() {
  function NoopLogger2() {
  }
  NoopLogger2.prototype.emit = function(_logRecord) {
  };
  return NoopLogger2;
}();
var NOOP_LOGGER = new NoopLogger();

// node_modules/@opentelemetry/api-logs/build/esm/NoopLoggerProvider.js
var NoopLoggerProvider = function() {
  function NoopLoggerProvider2() {
  }
  NoopLoggerProvider2.prototype.getLogger = function(_name, _version, _options) {
    return new NoopLogger();
  };
  return NoopLoggerProvider2;
}();
var NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();

// node_modules/@opentelemetry/api-logs/build/esm/ProxyLogger.js
var ProxyLogger = function() {
  function ProxyLogger2(_provider, name, version, options) {
    this._provider = _provider;
    this.name = name;
    this.version = version;
    this.options = options;
  }
  ProxyLogger2.prototype.emit = function(logRecord) {
    this._getLogger().emit(logRecord);
  };
  ProxyLogger2.prototype._getLogger = function() {
    if (this._delegate) {
      return this._delegate;
    }
    var logger = this._provider.getDelegateLogger(this.name, this.version, this.options);
    if (!logger) {
      return NOOP_LOGGER;
    }
    this._delegate = logger;
    return this._delegate;
  };
  return ProxyLogger2;
}();

// node_modules/@opentelemetry/api-logs/build/esm/ProxyLoggerProvider.js
var ProxyLoggerProvider = function() {
  function ProxyLoggerProvider2() {
  }
  ProxyLoggerProvider2.prototype.getLogger = function(name, version, options) {
    var _a;
    return (_a = this.getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyLogger(this, name, version, options);
  };
  ProxyLoggerProvider2.prototype.getDelegate = function() {
    var _a;
    return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_LOGGER_PROVIDER;
  };
  ProxyLoggerProvider2.prototype.setDelegate = function(delegate) {
    this._delegate = delegate;
  };
  ProxyLoggerProvider2.prototype.getDelegateLogger = function(name, version, options) {
    var _a;
    return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
  };
  return ProxyLoggerProvider2;
}();

// node_modules/@opentelemetry/api-logs/build/esm/platform/browser/globalThis.js
var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};

// node_modules/@opentelemetry/api-logs/build/esm/internal/global-utils.js
var GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
var _global = _globalThis;
function makeGetter(requiredVersion, instance, fallback) {
  return function(version) {
    return version === requiredVersion ? instance : fallback;
  };
}
var API_BACKWARDS_COMPATIBILITY_VERSION = 1;

// node_modules/@opentelemetry/api-logs/build/esm/api/logs.js
var LogsAPI = function() {
  function LogsAPI2() {
    this._proxyLoggerProvider = new ProxyLoggerProvider();
  }
  LogsAPI2.getInstance = function() {
    if (!this._instance) {
      this._instance = new LogsAPI2();
    }
    return this._instance;
  };
  LogsAPI2.prototype.setGlobalLoggerProvider = function(provider) {
    if (_global[GLOBAL_LOGS_API_KEY]) {
      return this.getLoggerProvider();
    }
    _global[GLOBAL_LOGS_API_KEY] = makeGetter(API_BACKWARDS_COMPATIBILITY_VERSION, provider, NOOP_LOGGER_PROVIDER);
    this._proxyLoggerProvider.setDelegate(provider);
    return provider;
  };
  LogsAPI2.prototype.getLoggerProvider = function() {
    var _a, _b;
    return (_b = (_a = _global[GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(_global, API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
  };
  LogsAPI2.prototype.getLogger = function(name, version, options) {
    return this.getLoggerProvider().getLogger(name, version, options);
  };
  LogsAPI2.prototype.disable = function() {
    delete _global[GLOBAL_LOGS_API_KEY];
    this._proxyLoggerProvider = new ProxyLoggerProvider();
  };
  return LogsAPI2;
}();

// node_modules/@opentelemetry/api-logs/build/esm/index.js
var logs = LogsAPI.getInstance();

// node_modules/@opentelemetry/instrumentation/build/esm/autoLoaderUtils.js
function enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider) {
  for (var i = 0, j = instrumentations.length; i < j; i++) {
    var instrumentation = instrumentations[i];
    if (tracerProvider) {
      instrumentation.setTracerProvider(tracerProvider);
    }
    if (meterProvider) {
      instrumentation.setMeterProvider(meterProvider);
    }
    if (loggerProvider && instrumentation.setLoggerProvider) {
      instrumentation.setLoggerProvider(loggerProvider);
    }
    if (!instrumentation.getConfig().enabled) {
      instrumentation.enable();
    }
  }
}
function disableInstrumentations(instrumentations) {
  instrumentations.forEach(function(instrumentation) {
    return instrumentation.disable();
  });
}

// node_modules/@opentelemetry/instrumentation/build/esm/autoLoader.js
function registerInstrumentations(options) {
  var _a, _b;
  var tracerProvider = options.tracerProvider || trace.getTracerProvider();
  var meterProvider = options.meterProvider || metrics.getMeterProvider();
  var loggerProvider = options.loggerProvider || logs.getLoggerProvider();
  var instrumentations = (_b = (_a = options.instrumentations) === null || _a === void 0 ? void 0 : _a.flat()) !== null && _b !== void 0 ? _b : [];
  enableInstrumentations(instrumentations, tracerProvider, meterProvider, loggerProvider);
  return function() {
    disableInstrumentations(instrumentations);
  };
}

// node_modules/@opentelemetry/instrumentation/build/esm/instrumentation.js
var shimmer = __toESM(require_shimmer());
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var InstrumentationAbstract = function() {
  function InstrumentationAbstract2(instrumentationName, instrumentationVersion, config) {
    this.instrumentationName = instrumentationName;
    this.instrumentationVersion = instrumentationVersion;
    this._config = {};
    this._wrap = shimmer.wrap;
    this._unwrap = shimmer.unwrap;
    this._massWrap = shimmer.massWrap;
    this._massUnwrap = shimmer.massUnwrap;
    this.setConfig(config);
    this._diag = diag.createComponentLogger({
      namespace: instrumentationName
    });
    this._tracer = trace.getTracer(instrumentationName, instrumentationVersion);
    this._meter = metrics.getMeter(instrumentationName, instrumentationVersion);
    this._logger = logs.getLogger(instrumentationName, instrumentationVersion);
    this._updateMetricInstruments();
  }
  Object.defineProperty(InstrumentationAbstract2.prototype, "meter", {
    get: function() {
      return this._meter;
    },
    enumerable: false,
    configurable: true
  });
  InstrumentationAbstract2.prototype.setMeterProvider = function(meterProvider) {
    this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
    this._updateMetricInstruments();
  };
  Object.defineProperty(InstrumentationAbstract2.prototype, "logger", {
    get: function() {
      return this._logger;
    },
    enumerable: false,
    configurable: true
  });
  InstrumentationAbstract2.prototype.setLoggerProvider = function(loggerProvider) {
    this._logger = loggerProvider.getLogger(this.instrumentationName, this.instrumentationVersion);
  };
  InstrumentationAbstract2.prototype.getModuleDefinitions = function() {
    var _a;
    var initResult = (_a = this.init()) !== null && _a !== void 0 ? _a : [];
    if (!Array.isArray(initResult)) {
      return [initResult];
    }
    return initResult;
  };
  InstrumentationAbstract2.prototype._updateMetricInstruments = function() {
    return;
  };
  InstrumentationAbstract2.prototype.getConfig = function() {
    return this._config;
  };
  InstrumentationAbstract2.prototype.setConfig = function(config) {
    this._config = __assign({ enabled: true }, config);
  };
  InstrumentationAbstract2.prototype.setTracerProvider = function(tracerProvider) {
    this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
  };
  Object.defineProperty(InstrumentationAbstract2.prototype, "tracer", {
    get: function() {
      return this._tracer;
    },
    enumerable: false,
    configurable: true
  });
  InstrumentationAbstract2.prototype._runSpanCustomizationHook = function(hookHandler, triggerName, span, info) {
    if (!hookHandler) {
      return;
    }
    try {
      hookHandler(span, info);
    } catch (e) {
      this._diag.error("Error running span customization hook due to exception in handler", { triggerName }, e);
    }
  };
  return InstrumentationAbstract2;
}();

// node_modules/@opentelemetry/instrumentation/build/esm/platform/browser/instrumentation.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var InstrumentationBase = function(_super) {
  __extends(InstrumentationBase2, _super);
  function InstrumentationBase2(instrumentationName, instrumentationVersion, config) {
    var _this = _super.call(this, instrumentationName, instrumentationVersion, config) || this;
    if (_this._config.enabled) {
      _this.enable();
    }
    return _this;
  }
  return InstrumentationBase2;
}(InstrumentationAbstract);

// node_modules/@opentelemetry/instrumentation/build/esm/platform/browser/noop-normalize.js
function normalize(path) {
  diag.warn("Path normalization is not implemented for this platform. To silence this warning, ensure no node-specific instrumentations are loaded, and node-specific types (e.g. InstrumentationNodeModuleFile), are not used in a browser context)");
  return path;
}

// node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleDefinition.js
var InstrumentationNodeModuleDefinition = function() {
  function InstrumentationNodeModuleDefinition2(name, supportedVersions, patch, unpatch, files) {
    this.name = name;
    this.supportedVersions = supportedVersions;
    this.patch = patch;
    this.unpatch = unpatch;
    this.files = files || [];
  }
  return InstrumentationNodeModuleDefinition2;
}();

// node_modules/@opentelemetry/instrumentation/build/esm/instrumentationNodeModuleFile.js
var InstrumentationNodeModuleFile = function() {
  function InstrumentationNodeModuleFile2(name, supportedVersions, patch, unpatch) {
    this.supportedVersions = supportedVersions;
    this.patch = patch;
    this.unpatch = unpatch;
    this.name = normalize(name);
  }
  return InstrumentationNodeModuleFile2;
}();

// node_modules/@opentelemetry/instrumentation/build/esm/utils.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
function safeExecuteInTheMiddle(execute, onFinish, preventThrowingError) {
  var error;
  var result;
  try {
    result = execute();
  } catch (e) {
    error = e;
  } finally {
    onFinish(error, result);
    if (error && !preventThrowingError) {
      throw error;
    }
    return result;
  }
}
function safeExecuteInTheMiddleAsync(execute, onFinish, preventThrowingError) {
  return __awaiter(this, void 0, void 0, function() {
    var error, result, e_1;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          _a.trys.push([0, 2, 3, 4]);
          return [4, execute()];
        case 1:
          result = _a.sent();
          return [3, 4];
        case 2:
          e_1 = _a.sent();
          error = e_1;
          return [3, 4];
        case 3:
          onFinish(error, result);
          if (error && !preventThrowingError) {
            throw error;
          }
          return [2, result];
        case 4:
          return [2];
      }
    });
  });
}
function isWrapped(func) {
  return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
}

export {
  registerInstrumentations,
  InstrumentationBase,
  InstrumentationNodeModuleDefinition,
  InstrumentationNodeModuleFile,
  safeExecuteInTheMiddle,
  safeExecuteInTheMiddleAsync,
  isWrapped
};
//# sourceMappingURL=chunk-DF74NQCN.js.map
