{
  "version": 3,
  "sources": ["../../@opentelemetry/sdk-trace-base/src/enums.ts", "../../@opentelemetry/sdk-trace-base/src/Span.ts", "../../@opentelemetry/sdk-trace-base/src/Sampler.ts", "../../@opentelemetry/sdk-trace-base/src/sampler/AlwaysOffSampler.ts", "../../@opentelemetry/sdk-trace-base/src/sampler/AlwaysOnSampler.ts", "../../@opentelemetry/sdk-trace-base/src/sampler/ParentBasedSampler.ts", "../../@opentelemetry/sdk-trace-base/src/sampler/TraceIdRatioBasedSampler.ts", "../../@opentelemetry/sdk-trace-base/src/config.ts", "../../@opentelemetry/sdk-trace-base/src/utility.ts", "../../@opentelemetry/sdk-trace-base/src/export/BatchSpanProcessorBase.ts", "../../@opentelemetry/sdk-trace-base/src/platform/browser/export/BatchSpanProcessor.ts", "../../@opentelemetry/sdk-trace-base/src/platform/browser/RandomIdGenerator.ts", "../../@opentelemetry/sdk-trace-base/src/Tracer.ts", "../../@opentelemetry/sdk-trace-base/src/MultiSpanProcessor.ts", "../../@opentelemetry/sdk-trace-base/src/export/NoopSpanProcessor.ts", "../../@opentelemetry/sdk-trace-base/src/BasicTracerProvider.ts", "../../@opentelemetry/sdk-trace-base/src/export/ConsoleSpanExporter.ts", "../../@opentelemetry/sdk-trace-base/src/export/InMemorySpanExporter.ts", "../../@opentelemetry/sdk-trace-base/src/export/SimpleSpanProcessor.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Event name definitions\nexport const ExceptionEventName = 'exception';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  diag,\n  Exception,\n  HrTime,\n  Link,\n  Span as APISpan,\n  SpanAttributes,\n  SpanAttributeValue,\n  SpanContext,\n  SpanKind,\n  SpanStatus,\n  SpanStatusCode,\n  TimeInput,\n} from '@opentelemetry/api';\nimport {\n  addHrTimes,\n  millisToHrTime,\n  getTimeOrigin,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationLibrary,\n  isAttributeValue,\n  isTimeInput,\n  isTimeInputHrTime,\n  otperformance,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport {\n  SEMATTRS_EXCEPTION_MESSAGE,\n  SEMATTRS_EXCEPTION_STACKTRACE,\n  SEMATTRS_EXCEPTION_TYPE,\n} from '@opentelemetry/semantic-conventions';\nimport { ExceptionEventName } from './enums';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { SpanProcessor } from './SpanProcessor';\nimport { TimedEvent } from './TimedEvent';\nimport { Tracer } from './Tracer';\nimport { SpanLimits } from './types';\n\n/**\n * This class represents a span.\n */\nexport class Span implements APISpan, ReadableSpan {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: SpanContext;\n  readonly kind: SpanKind;\n  readonly parentSpanId?: string;\n  readonly attributes: SpanAttributes = {};\n  readonly links: Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: HrTime;\n  readonly resource: IResource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n\n  private _droppedAttributesCount = 0;\n  private _droppedEventsCount: number = 0;\n  private _droppedLinksCount: number = 0;\n\n  name: string;\n  status: SpanStatus = {\n    code: SpanStatusCode.UNSET,\n  };\n  endTime: HrTime = [0, 0];\n  private _ended = false;\n  private _duration: HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  private readonly _performanceStartTime: number;\n  private readonly _performanceOffset: number;\n  private readonly _startTimeProvided: boolean;\n\n  /**\n   * Constructs a new Span instance.\n   *\n   * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.\n   * */\n  constructor(\n    parentTracer: Tracer,\n    context: Context,\n    spanName: string,\n    spanContext: SpanContext,\n    kind: SpanKind,\n    parentSpanId?: string,\n    links: Link[] = [],\n    startTime?: TimeInput,\n    _deprecatedClock?: unknown, // keeping this argument even though it is unused to ensure backwards compatibility\n    attributes?: SpanAttributes\n  ) {\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n\n    const now = Date.now();\n    this._performanceStartTime = otperformance.now();\n    this._performanceOffset =\n      now - (this._performanceStartTime + getTimeOrigin());\n    this._startTimeProvided = startTime != null;\n\n    this.startTime = this._getTime(startTime ?? now);\n\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._attributeValueLengthLimit =\n      this._spanLimits.attributeValueLengthLimit || 0;\n\n    if (attributes != null) {\n      this.setAttributes(attributes);\n    }\n\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n  }\n\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: SpanAttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    if (\n      Object.keys(this.attributes).length >=\n        this._spanLimits.attributeCountLimit! &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      this._droppedAttributesCount++;\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: SpanAttributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [timeStamp] Specified time stamp for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: SpanAttributes | TimeInput,\n    timeStamp?: TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      diag.warn('No events allowed.');\n      this._droppedEventsCount++;\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit!) {\n      if (this._droppedEventsCount === 0) {\n        diag.debug('Dropping extra events.');\n      }\n      this.events.shift();\n      this._droppedEventsCount++;\n    }\n\n    if (isTimeInput(attributesOrStartTime)) {\n      if (!isTimeInput(timeStamp)) {\n        timeStamp = attributesOrStartTime;\n      }\n      attributesOrStartTime = undefined;\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n\n    this.events.push({\n      name,\n      attributes,\n      time: this._getTime(timeStamp),\n      droppedAttributesCount: 0,\n    });\n    return this;\n  }\n\n  addLink(link: Link): this {\n    this.links.push(link);\n    return this;\n  }\n\n  addLinks(links: Link[]): this {\n    this.links.push(...links);\n    return this;\n  }\n\n  setStatus(status: SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = { ...status };\n\n    // When using try-catch, the caught \"error\" is of type `any`. When then assigning `any` to `status.message`,\n    // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()\n    // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or\n    // undefined to avoid an incorrect type causing issues downstream.\n    if (this.status.message != null && typeof status.message !== 'string') {\n      diag.warn(\n        `Dropping invalid status.message of type '${typeof status.message}', expected 'string'`\n      );\n      delete this.status.message;\n    }\n\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime?: TimeInput): void {\n    if (this._isSpanEnded()) {\n      diag.error(\n        `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`\n      );\n      return;\n    }\n    this._ended = true;\n\n    this.endTime = this._getTime(endTime);\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n\n    if (this._duration[0] < 0) {\n      diag.warn(\n        'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',\n        this.startTime,\n        this.endTime\n      );\n      this.endTime = this.startTime.slice() as HrTime;\n      this._duration = [0, 0];\n    }\n\n    if (this._droppedEventsCount > 0) {\n      diag.warn(\n        `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  private _getTime(inp?: TimeInput): HrTime {\n    if (typeof inp === 'number' && inp <= otperformance.now()) {\n      // must be a performance timestamp\n      // apply correction and convert to hrtime\n      return hrTime(inp + this._performanceOffset);\n    }\n\n    if (typeof inp === 'number') {\n      return millisToHrTime(inp);\n    }\n\n    if (inp instanceof Date) {\n      return millisToHrTime(inp.getTime());\n    }\n\n    if (isTimeInputHrTime(inp)) {\n      return inp;\n    }\n\n    if (this._startTimeProvided) {\n      // if user provided a time for the start manually\n      // we can't use duration to calculate event/end times\n      return millisToHrTime(Date.now());\n    }\n\n    const msDuration = otperformance.now() - this._performanceStartTime;\n    return addHrTimes(this.startTime, millisToHrTime(msDuration));\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: Exception, time?: TimeInput): void {\n    const attributes: SpanAttributes = {};\n    if (typeof exception === 'string') {\n      attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (\n      attributes[SEMATTRS_EXCEPTION_TYPE] ||\n      attributes[SEMATTRS_EXCEPTION_MESSAGE]\n    ) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  get droppedAttributesCount(): number {\n    return this._droppedAttributesCount;\n  }\n\n  get droppedEventsCount(): number {\n    return this._droppedEventsCount;\n  }\n\n  get droppedLinksCount(): number {\n    return this._droppedLinksCount;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      diag.warn(\n        `Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`\n      );\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substring(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with truncated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: SpanAttributeValue): SpanAttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val =>\n        typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val\n      );\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  Link,\n  SpanAttributes,\n  SpanKind,\n  TraceState,\n} from '@opentelemetry/api';\n\n/**\n * A sampling decision that determines how a {@link Span} will be recorded\n * and collected.\n */\nexport enum SamplingDecision {\n  /**\n   * `Span.isRecording() === false`, span will not be recorded and all events\n   * and attributes will be dropped.\n   */\n  NOT_RECORD,\n  /**\n   * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}\n   * MUST NOT be set.\n   */\n  RECORD,\n  /**\n   * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}\n   * MUST be set.\n   */\n  RECORD_AND_SAMPLED,\n}\n\n/**\n * A sampling result contains a decision for a {@link Span} and additional\n * attributes the sampler would like to added to the Span.\n */\nexport interface SamplingResult {\n  /**\n   * A sampling decision, refer to {@link SamplingDecision} for details.\n   */\n  decision: SamplingDecision;\n  /**\n   * The list of attributes returned by SamplingResult MUST be immutable.\n   * Caller may call {@link Sampler}.shouldSample any number of times and\n   * can safely cache the returned value.\n   */\n  attributes?: Readonly<SpanAttributes>;\n  /**\n   * A {@link TraceState} that will be associated with the {@link Span} through\n   * the new {@link SpanContext}. Samplers SHOULD return the TraceState from\n   * the passed-in {@link Context} if they do not intend to change it. Leaving\n   * the value undefined will also leave the TraceState unchanged.\n   */\n  traceState?: TraceState;\n}\n\n/**\n * This interface represent a sampler. Sampling is a mechanism to control the\n * noise and overhead introduced by OpenTelemetry by reducing the number of\n * samples of traces collected and sent to the backend.\n */\nexport interface Sampler {\n  /**\n   * Checks whether span needs to be created and tracked.\n   *\n   * @param context Parent Context which may contain a span.\n   * @param traceId of the span to be created. It can be different from the\n   *     traceId in the {@link SpanContext}. Typically in situations when the\n   *     span to be created starts a new trace.\n   * @param spanName of the span to be created.\n   * @param spanKind of the span to be created.\n   * @param attributes Initial set of SpanAttributes for the Span being constructed.\n   * @param links Collection of links that will be associated with the Span to\n   *     be created. Typically useful for batch operations.\n   * @returns a {@link SamplingResult}.\n   */\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: SpanAttributes,\n    links: Link[]\n  ): SamplingResult;\n\n  /** Returns the sampler name or short description with the configuration. */\n  toString(): string;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples no traces. */\nexport class AlwaysOffSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOffSampler';\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples all traces. */\nexport class AlwaysOnSampler implements Sampler {\n  shouldSample(): SamplingResult {\n    return {\n      decision: SamplingDecision.RECORD_AND_SAMPLED,\n    };\n  }\n\n  toString(): string {\n    return 'AlwaysOnSampler';\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  Link,\n  SpanAttributes,\n  SpanKind,\n  TraceFlags,\n  trace,\n} from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { AlwaysOffSampler } from './AlwaysOffSampler';\nimport { AlwaysOnSampler } from './AlwaysOnSampler';\nimport { Sampler, SamplingResult } from '../Sampler';\n\n/**\n * A composite sampler that either respects the parent span's sampling decision\n * or delegates to `delegateSampler` for root spans.\n */\nexport class ParentBasedSampler implements Sampler {\n  private _root: Sampler;\n  private _remoteParentSampled: Sampler;\n  private _remoteParentNotSampled: Sampler;\n  private _localParentSampled: Sampler;\n  private _localParentNotSampled: Sampler;\n\n  constructor(config: ParentBasedSamplerConfig) {\n    this._root = config.root;\n\n    if (!this._root) {\n      globalErrorHandler(\n        new Error('ParentBasedSampler must have a root sampler configured')\n      );\n      this._root = new AlwaysOnSampler();\n    }\n\n    this._remoteParentSampled =\n      config.remoteParentSampled ?? new AlwaysOnSampler();\n    this._remoteParentNotSampled =\n      config.remoteParentNotSampled ?? new AlwaysOffSampler();\n    this._localParentSampled =\n      config.localParentSampled ?? new AlwaysOnSampler();\n    this._localParentNotSampled =\n      config.localParentNotSampled ?? new AlwaysOffSampler();\n  }\n\n  shouldSample(\n    context: Context,\n    traceId: string,\n    spanName: string,\n    spanKind: SpanKind,\n    attributes: SpanAttributes,\n    links: Link[]\n  ): SamplingResult {\n    const parentContext = trace.getSpanContext(context);\n\n    if (!parentContext || !isSpanContextValid(parentContext)) {\n      return this._root.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.isRemote) {\n      if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n        return this._remoteParentSampled.shouldSample(\n          context,\n          traceId,\n          spanName,\n          spanKind,\n          attributes,\n          links\n        );\n      }\n      return this._remoteParentNotSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    if (parentContext.traceFlags & TraceFlags.SAMPLED) {\n      return this._localParentSampled.shouldSample(\n        context,\n        traceId,\n        spanName,\n        spanKind,\n        attributes,\n        links\n      );\n    }\n\n    return this._localParentNotSampled.shouldSample(\n      context,\n      traceId,\n      spanName,\n      spanKind,\n      attributes,\n      links\n    );\n  }\n\n  toString(): string {\n    return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;\n  }\n}\n\ninterface ParentBasedSamplerConfig {\n  /** Sampler called for spans with no parent */\n  root: Sampler;\n  /** Sampler called for spans with a remote parent which was sampled. Default AlwaysOn */\n  remoteParentSampled?: Sampler;\n  /** Sampler called for spans with a remote parent which was not sampled. Default AlwaysOff */\n  remoteParentNotSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was sampled. Default AlwaysOn */\n  localParentSampled?: Sampler;\n  /** Sampler called for spans with a local parent which was not sampled. Default AlwaysOff */\n  localParentNotSampled?: Sampler;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isValidTraceId } from '@opentelemetry/api';\nimport { Sampler, SamplingDecision, SamplingResult } from '../Sampler';\n\n/** Sampler that samples a given fraction of traces based of trace id deterministically. */\nexport class TraceIdRatioBasedSampler implements Sampler {\n  private _upperBound: number;\n\n  constructor(private readonly _ratio: number = 0) {\n    this._ratio = this._normalize(_ratio);\n    this._upperBound = Math.floor(this._ratio * 0xffffffff);\n  }\n\n  shouldSample(context: unknown, traceId: string): SamplingResult {\n    return {\n      decision:\n        isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound\n          ? SamplingDecision.RECORD_AND_SAMPLED\n          : SamplingDecision.NOT_RECORD,\n    };\n  }\n\n  toString(): string {\n    return `TraceIdRatioBased{${this._ratio}}`;\n  }\n\n  private _normalize(ratio: number): number {\n    if (typeof ratio !== 'number' || isNaN(ratio)) return 0;\n    return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;\n  }\n\n  private _accumulate(traceId: string): number {\n    let accumulation = 0;\n    for (let i = 0; i < traceId.length / 8; i++) {\n      const pos = i * 8;\n      const part = parseInt(traceId.slice(pos, pos + 8), 16);\n      accumulation = (accumulation ^ part) >>> 0;\n    }\n    return accumulation;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport { getEnv, TracesSamplerValues, ENVIRONMENT } from '@opentelemetry/core';\nimport { Sampler } from './Sampler';\nimport { AlwaysOffSampler } from './sampler/AlwaysOffSampler';\nimport { AlwaysOnSampler } from './sampler/AlwaysOnSampler';\nimport { ParentBasedSampler } from './sampler/ParentBasedSampler';\nimport { TraceIdRatioBasedSampler } from './sampler/TraceIdRatioBasedSampler';\n\nconst env = getEnv();\nconst FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;\nconst DEFAULT_RATIO = 1;\n\n/**\n * Load default configuration. For fields with primitive values, any user-provided\n * value will override the corresponding default value. For fields with\n * non-primitive values (like `spanLimits`), the user-provided value will be\n * used to extend the default value.\n */\n\n// object needs to be wrapped in this function and called when needed otherwise\n// envs are parsed before tests are ran - causes tests using these envs to fail\nexport function loadDefaultConfig() {\n  const _env = getEnv();\n\n  return {\n    sampler: buildSamplerFromEnv(env),\n    forceFlushTimeoutMillis: 30000,\n    generalLimits: {\n      attributeValueLengthLimit: _env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: _env.OTEL_ATTRIBUTE_COUNT_LIMIT,\n    },\n    spanLimits: {\n      attributeValueLengthLimit: _env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      attributeCountLimit: _env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n      linkCountLimit: _env.OTEL_SPAN_LINK_COUNT_LIMIT,\n      eventCountLimit: _env.OTEL_SPAN_EVENT_COUNT_LIMIT,\n      attributePerEventCountLimit:\n        _env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n      attributePerLinkCountLimit: _env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n    },\n    mergeResourceWithDefaults: true,\n  };\n}\n\n/**\n * Based on environment, builds a sampler, complies with specification.\n * @param environment optional, by default uses getEnv(), but allows passing a value to reuse parsed environment\n */\nexport function buildSamplerFromEnv(\n  environment: Required<ENVIRONMENT> = getEnv()\n): Sampler {\n  switch (environment.OTEL_TRACES_SAMPLER) {\n    case TracesSamplerValues.AlwaysOn:\n      return new AlwaysOnSampler();\n    case TracesSamplerValues.AlwaysOff:\n      return new AlwaysOffSampler();\n    case TracesSamplerValues.ParentBasedAlwaysOn:\n      return new ParentBasedSampler({\n        root: new AlwaysOnSampler(),\n      });\n    case TracesSamplerValues.ParentBasedAlwaysOff:\n      return new ParentBasedSampler({\n        root: new AlwaysOffSampler(),\n      });\n    case TracesSamplerValues.TraceIdRatio:\n      return new TraceIdRatioBasedSampler(\n        getSamplerProbabilityFromEnv(environment)\n      );\n    case TracesSamplerValues.ParentBasedTraceIdRatio:\n      return new ParentBasedSampler({\n        root: new TraceIdRatioBasedSampler(\n          getSamplerProbabilityFromEnv(environment)\n        ),\n      });\n    default:\n      diag.error(\n        `OTEL_TRACES_SAMPLER value \"${environment.OTEL_TRACES_SAMPLER} invalid, defaulting to ${FALLBACK_OTEL_TRACES_SAMPLER}\".`\n      );\n      return new AlwaysOnSampler();\n  }\n}\n\nfunction getSamplerProbabilityFromEnv(\n  environment: Required<ENVIRONMENT>\n): number | undefined {\n  if (\n    environment.OTEL_TRACES_SAMPLER_ARG === undefined ||\n    environment.OTEL_TRACES_SAMPLER_ARG === ''\n  ) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  const probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);\n\n  if (isNaN(probability)) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  if (probability < 0 || probability > 1) {\n    diag.error(\n      `OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`\n    );\n    return DEFAULT_RATIO;\n  }\n\n  return probability;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { buildSamplerFromEnv, loadDefaultConfig } from './config';\nimport { Sampler } from './Sampler';\nimport { SpanLimits, TracerConfig, GeneralLimits } from './types';\nimport {\n  DEFAULT_ATTRIBUTE_COUNT_LIMIT,\n  DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  getEnvWithoutDefaults,\n} from '@opentelemetry/core';\n\n/**\n * Function to merge Default configuration (as specified in './config') with\n * user provided configurations.\n */\nexport function mergeConfig(userConfig: TracerConfig): TracerConfig & {\n  sampler: Sampler;\n  spanLimits: SpanLimits;\n  generalLimits: GeneralLimits;\n} {\n  const perInstanceDefaults: Partial<TracerConfig> = {\n    sampler: buildSamplerFromEnv(),\n  };\n\n  const DEFAULT_CONFIG = loadDefaultConfig();\n\n  const target = Object.assign(\n    {},\n    DEFAULT_CONFIG,\n    perInstanceDefaults,\n    userConfig\n  );\n\n  target.generalLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.generalLimits,\n    userConfig.generalLimits || {}\n  );\n\n  target.spanLimits = Object.assign(\n    {},\n    DEFAULT_CONFIG.spanLimits,\n    userConfig.spanLimits || {}\n  );\n\n  return target;\n}\n\n/**\n * When general limits are provided and model specific limits are not,\n * configures the model specific limits by using the values from the general ones.\n * @param userConfig User provided tracer configuration\n */\nexport function reconfigureLimits(userConfig: TracerConfig): TracerConfig {\n  const spanLimits = Object.assign({}, userConfig.spanLimits);\n\n  const parsedEnvConfig = getEnvWithoutDefaults();\n\n  /**\n   * Reassign span attribute count limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeCountLimit =\n    userConfig.spanLimits?.attributeCountLimit ??\n    userConfig.generalLimits?.attributeCountLimit ??\n    parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT ??\n    parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT ??\n    DEFAULT_ATTRIBUTE_COUNT_LIMIT;\n\n  /**\n   * Reassign span attribute value length limit to use first non null value defined by user or use default value\n   */\n  spanLimits.attributeValueLengthLimit =\n    userConfig.spanLimits?.attributeValueLengthLimit ??\n    userConfig.generalLimits?.attributeValueLengthLimit ??\n    parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT ??\n    parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT ??\n    DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;\n\n  return Object.assign({}, userConfig, { spanLimits });\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { context, Context, diag, TraceFlags } from '@opentelemetry/api';\nimport {\n  BindOnceFuture,\n  ExportResultCode,\n  getEnv,\n  globalErrorHandler,\n  suppressTracing,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { BufferConfig } from '../types';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\n\n/**\n * Implementation of the {@link SpanProcessor} that batches spans exported by\n * the SDK then pushes them to the exporter pipeline.\n */\nexport abstract class BatchSpanProcessorBase<T extends BufferConfig>\n  implements SpanProcessor\n{\n  private readonly _maxExportBatchSize: number;\n  private readonly _maxQueueSize: number;\n  private readonly _scheduledDelayMillis: number;\n  private readonly _exportTimeoutMillis: number;\n\n  private _isExporting = false;\n  private _finishedSpans: ReadableSpan[] = [];\n  private _timer: NodeJS.Timeout | undefined;\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _droppedSpansCount: number = 0;\n\n  constructor(\n    private readonly _exporter: SpanExporter,\n    config?: T\n  ) {\n    const env = getEnv();\n    this._maxExportBatchSize =\n      typeof config?.maxExportBatchSize === 'number'\n        ? config.maxExportBatchSize\n        : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;\n    this._maxQueueSize =\n      typeof config?.maxQueueSize === 'number'\n        ? config.maxQueueSize\n        : env.OTEL_BSP_MAX_QUEUE_SIZE;\n    this._scheduledDelayMillis =\n      typeof config?.scheduledDelayMillis === 'number'\n        ? config.scheduledDelayMillis\n        : env.OTEL_BSP_SCHEDULE_DELAY;\n    this._exportTimeoutMillis =\n      typeof config?.exportTimeoutMillis === 'number'\n        ? config.exportTimeoutMillis\n        : env.OTEL_BSP_EXPORT_TIMEOUT;\n\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n\n    if (this._maxExportBatchSize > this._maxQueueSize) {\n      diag.warn(\n        'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'\n      );\n      this._maxExportBatchSize = this._maxQueueSize;\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    if (this._shutdownOnce.isCalled) {\n      return this._shutdownOnce.promise;\n    }\n    return this._flushAll();\n  }\n\n  // does nothing.\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    this._addToBuffer(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown() {\n    return Promise.resolve()\n      .then(() => {\n        return this.onShutdown();\n      })\n      .then(() => {\n        return this._flushAll();\n      })\n      .then(() => {\n        return this._exporter.shutdown();\n      });\n  }\n\n  /** Add a span in the buffer. */\n  private _addToBuffer(span: ReadableSpan) {\n    if (this._finishedSpans.length >= this._maxQueueSize) {\n      // limit reached, drop span\n\n      if (this._droppedSpansCount === 0) {\n        diag.debug('maxQueueSize reached, dropping spans');\n      }\n      this._droppedSpansCount++;\n\n      return;\n    }\n\n    if (this._droppedSpansCount > 0) {\n      // some spans were dropped, log once with count of spans dropped\n      diag.warn(\n        `Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`\n      );\n      this._droppedSpansCount = 0;\n    }\n\n    this._finishedSpans.push(span);\n    this._maybeStartTimer();\n  }\n\n  /**\n   * Send all spans to the exporter respecting the batch size limit\n   * This function is used only on forceFlush or shutdown,\n   * for all other cases _flush should be used\n   * */\n  private _flushAll(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const promises = [];\n      // calculate number of batches\n      const count = Math.ceil(\n        this._finishedSpans.length / this._maxExportBatchSize\n      );\n      for (let i = 0, j = count; i < j; i++) {\n        promises.push(this._flushOneBatch());\n      }\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n\n  private _flushOneBatch(): Promise<void> {\n    this._clearTimer();\n    if (this._finishedSpans.length === 0) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const timer = setTimeout(() => {\n        // don't wait anymore for export, this way the next batch can start\n        reject(new Error('Timeout'));\n      }, this._exportTimeoutMillis);\n      // prevent downstream exporter calls from generating spans\n      context.with(suppressTracing(context.active()), () => {\n        // Reset the finished spans buffer here because the next invocations of the _flush method\n        // could pass the same finished spans to the exporter if the buffer is cleared\n        // outside the execution of this callback.\n        let spans: ReadableSpan[];\n        if (this._finishedSpans.length <= this._maxExportBatchSize) {\n          spans = this._finishedSpans;\n          this._finishedSpans = [];\n        } else {\n          spans = this._finishedSpans.splice(0, this._maxExportBatchSize);\n        }\n\n        const doExport = () =>\n          this._exporter.export(spans, result => {\n            clearTimeout(timer);\n            if (result.code === ExportResultCode.SUCCESS) {\n              resolve();\n            } else {\n              reject(\n                result.error ??\n                  new Error('BatchSpanProcessor: span export failed')\n              );\n            }\n          });\n\n        let pendingResources: Array<Promise<void>> | null = null;\n        for (let i = 0, len = spans.length; i < len; i++) {\n          const span = spans[i];\n          if (\n            span.resource.asyncAttributesPending &&\n            span.resource.waitForAsyncAttributes\n          ) {\n            pendingResources ??= [];\n            pendingResources.push(span.resource.waitForAsyncAttributes());\n          }\n        }\n\n        // Avoid scheduling a promise to make the behavior more predictable and easier to test\n        if (pendingResources === null) {\n          doExport();\n        } else {\n          Promise.all(pendingResources).then(doExport, err => {\n            globalErrorHandler(err);\n            reject(err);\n          });\n        }\n      });\n    });\n  }\n\n  private _maybeStartTimer() {\n    if (this._isExporting) return;\n    const flush = () => {\n      this._isExporting = true;\n      this._flushOneBatch()\n        .finally(() => {\n          this._isExporting = false;\n          if (this._finishedSpans.length > 0) {\n            this._clearTimer();\n            this._maybeStartTimer();\n          }\n        })\n        .catch(e => {\n          this._isExporting = false;\n          globalErrorHandler(e);\n        });\n    };\n    // we only wait if the queue doesn't have enough elements yet\n    if (this._finishedSpans.length >= this._maxExportBatchSize) {\n      return flush();\n    }\n    if (this._timer !== undefined) return;\n    this._timer = setTimeout(() => flush(), this._scheduledDelayMillis);\n    unrefTimer(this._timer);\n  }\n\n  private _clearTimer() {\n    if (this._timer !== undefined) {\n      clearTimeout(this._timer);\n      this._timer = undefined;\n    }\n  }\n\n  protected abstract onShutdown(): void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchSpanProcessorBase } from '../../../export/BatchSpanProcessorBase';\nimport { SpanExporter } from '../../../export/SpanExporter';\nimport { BatchSpanProcessorBrowserConfig } from '../../../types';\nimport { globalErrorHandler } from '@opentelemetry/core';\n\nexport class BatchSpanProcessor extends BatchSpanProcessorBase<BatchSpanProcessorBrowserConfig> {\n  private _visibilityChangeListener?: () => void;\n  private _pageHideListener?: () => void;\n\n  constructor(\n    _exporter: SpanExporter,\n    config?: BatchSpanProcessorBrowserConfig\n  ) {\n    super(_exporter, config);\n    this.onInit(config);\n  }\n\n  private onInit(config?: BatchSpanProcessorBrowserConfig): void {\n    if (\n      config?.disableAutoFlushOnDocumentHide !== true &&\n      typeof document !== 'undefined'\n    ) {\n      this._visibilityChangeListener = () => {\n        if (document.visibilityState === 'hidden') {\n          this.forceFlush().catch(error => {\n            globalErrorHandler(error);\n          });\n        }\n      };\n      this._pageHideListener = () => {\n        this.forceFlush().catch(error => {\n          globalErrorHandler(error);\n        });\n      };\n      document.addEventListener(\n        'visibilitychange',\n        this._visibilityChangeListener\n      );\n\n      // use 'pagehide' event as a fallback for Safari; see https://bugs.webkit.org/show_bug.cgi?id=116769\n      document.addEventListener('pagehide', this._pageHideListener);\n    }\n  }\n\n  protected onShutdown(): void {\n    if (typeof document !== 'undefined') {\n      if (this._visibilityChangeListener) {\n        document.removeEventListener(\n          'visibilitychange',\n          this._visibilityChangeListener\n        );\n      }\n      if (this._pageHideListener) {\n        document.removeEventListener('pagehide', this._pageHideListener);\n      }\n    }\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IdGenerator } from '../../IdGenerator';\n\nconst SPAN_ID_BYTES = 8;\nconst TRACE_ID_BYTES = 16;\n\nexport class RandomIdGenerator implements IdGenerator {\n  /**\n   * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex\n   * characters corresponding to 128 bits.\n   */\n  generateTraceId = getIdGenerator(TRACE_ID_BYTES);\n\n  /**\n   * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex\n   * characters corresponding to 64 bits.\n   */\n  generateSpanId = getIdGenerator(SPAN_ID_BYTES);\n}\n\nconst SHARED_CHAR_CODES_ARRAY = Array(32);\nfunction getIdGenerator(bytes: number): () => string {\n  return function generateId() {\n    for (let i = 0; i < bytes * 2; i++) {\n      SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;\n      // valid hex characters in the range 48-57 and 97-102\n      if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {\n        SHARED_CHAR_CODES_ARRAY[i] += 39;\n      }\n    }\n    return String.fromCharCode.apply(\n      null,\n      SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2)\n    );\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  InstrumentationLibrary,\n  sanitizeAttributes,\n  isTracingSuppressed,\n} from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport { BasicTracerProvider } from './BasicTracerProvider';\nimport { Span } from './Span';\nimport { GeneralLimits, SpanLimits, TracerConfig } from './types';\nimport { mergeConfig } from './utility';\nimport { SpanProcessor } from './SpanProcessor';\nimport { Sampler } from './Sampler';\nimport { IdGenerator } from './IdGenerator';\nimport { RandomIdGenerator } from './platform';\n\n/**\n * This class represents a basic tracer.\n */\nexport class Tracer implements api.Tracer {\n  private readonly _sampler: Sampler;\n  private readonly _generalLimits: GeneralLimits;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _idGenerator: IdGenerator;\n  readonly resource: IResource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n\n  /**\n   * Constructs a new Tracer instance.\n   */\n  constructor(\n    instrumentationLibrary: InstrumentationLibrary,\n    config: TracerConfig,\n    private _tracerProvider: BasicTracerProvider\n  ) {\n    const localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  startSpan(\n    name: string,\n    options: api.SpanOptions = {},\n    context = api.context.active()\n  ): api.Span {\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n    const parentSpan = api.trace.getSpan(context);\n\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      const nonRecordingSpan = api.trace.wrapSpanContext(\n        api.INVALID_SPAN_CONTEXT\n      );\n      return nonRecordingSpan;\n    }\n\n    const parentSpanContext = parentSpan?.spanContext();\n    const spanId = this._idGenerator.generateSpanId();\n    let traceId;\n    let traceState;\n    let parentSpanId;\n    if (\n      !parentSpanContext ||\n      !api.trace.isSpanContextValid(parentSpanContext)\n    ) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n\n    const spanKind = options.kind ?? api.SpanKind.INTERNAL;\n    const links = (options.links ?? []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes),\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    const samplingResult = this._sampler.shouldSample(\n      context,\n      traceId,\n      name,\n      spanKind,\n      attributes,\n      links\n    );\n\n    traceState = samplingResult.traceState ?? traceState;\n\n    const traceFlags =\n      samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n        ? api.TraceFlags.SAMPLED\n        : api.TraceFlags.NONE;\n    const spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug(\n        'Recording is off, propagating context in a non-recording span'\n      );\n      const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);\n      return nonRecordingSpan;\n    }\n\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    const initAttributes = sanitizeAttributes(\n      Object.assign(attributes, samplingResult.attributes)\n    );\n\n    const span = new Span(\n      this,\n      context,\n      name,\n      spanContext,\n      spanKind,\n      parentSpanId,\n      links,\n      options.startTime,\n      undefined,\n      initAttributes\n    );\n    return span;\n  }\n\n  /**\n   * Starts a new {@link Span} and calls the given function passing it the\n   * created span as first argument.\n   * Additionally the new span gets set in context and this context is activated\n   * for the duration of the function call.\n   *\n   * @param name The name of the span\n   * @param [options] SpanOptions used for span creation\n   * @param [context] Context to use to extract parent\n   * @param fn function called in the context of the span and receives the newly created span as an argument\n   * @returns return value of fn\n   * @example\n   *   const something = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       span.setStatus({code: SpanStatusCode.OK});\n   *       return something;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     } finally {\n   *       span.end();\n   *     }\n   *   });\n   * @example\n   *   const span = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       return span;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     }\n   *   });\n   *   do some more work\n   *   span.end();\n   */\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    ctx: api.Context,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | api.SpanOptions,\n    arg3?: F | api.Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: api.SpanOptions | undefined;\n    let ctx: api.Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as api.SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as api.SpanOptions | undefined;\n      ctx = arg3 as api.Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? api.context.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n\n  /** Returns the active {@link GeneralLimits}. */\n  getGeneralLimits(): GeneralLimits {\n    return this._generalLimits;\n  }\n\n  /** Returns the active {@link SpanLimits}. */\n  getSpanLimits(): SpanLimits {\n    return this._spanLimits;\n  }\n\n  getActiveSpanProcessor(): SpanProcessor {\n    return this._tracerProvider.getActiveSpanProcessor();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { globalErrorHandler } from '@opentelemetry/core';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { Span } from './Span';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * Implementation of the {@link SpanProcessor} that simply forwards all\n * received events to a list of {@link SpanProcessor}s.\n */\nexport class MultiSpanProcessor implements SpanProcessor {\n  constructor(private readonly _spanProcessors: SpanProcessor[]) {}\n\n  forceFlush(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.forceFlush());\n    }\n    return new Promise(resolve => {\n      Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(error => {\n          globalErrorHandler(\n            error || new Error('MultiSpanProcessor: forceFlush failed')\n          );\n          resolve();\n        });\n    });\n  }\n\n  onStart(span: Span, context: Context): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onStart(span, context);\n    }\n  }\n\n  onEnd(span: ReadableSpan): void {\n    for (const spanProcessor of this._spanProcessors) {\n      spanProcessor.onEnd(span);\n    }\n  }\n\n  shutdown(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const spanProcessor of this._spanProcessors) {\n      promises.push(spanProcessor.shutdown());\n    }\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(() => {\n        resolve();\n      }, reject);\n    });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '@opentelemetry/api';\nimport { ReadableSpan } from './ReadableSpan';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\n\n/** No-op implementation of SpanProcessor */\nexport class NoopSpanProcessor implements SpanProcessor {\n  onStart(_span: Span, _context: Context): void {}\n  onEnd(_span: ReadableSpan): void {}\n  shutdown(): Promise<void> {\n    return Promise.resolve();\n  }\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  context,\n  diag,\n  propagation,\n  TextMapPropagator,\n  trace,\n  TracerProvider,\n} from '@opentelemetry/api';\nimport {\n  CompositePropagator,\n  W3CBaggagePropagator,\n  W3CTraceContextPropagator,\n  getEnv,\n  merge,\n} from '@opentelemetry/core';\nimport { IResource, Resource } from '@opentelemetry/resources';\nimport { SpanProcessor, Tracer } from '.';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { NoopSpanProcessor } from './export/NoopSpanProcessor';\nimport { SDKRegistrationConfig, TracerConfig } from './types';\nimport { SpanExporter } from './export/SpanExporter';\nimport { BatchSpanProcessor } from './platform';\nimport { reconfigureLimits } from './utility';\n\nexport type PROPAGATOR_FACTORY = () => TextMapPropagator;\nexport type EXPORTER_FACTORY = () => SpanExporter;\n\nexport enum ForceFlushState {\n  'resolved',\n  'timeout',\n  'error',\n  'unresolved',\n}\n\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider implements TracerProvider {\n  protected static readonly _registeredPropagators = new Map<\n    string,\n    PROPAGATOR_FACTORY\n  >([\n    ['tracecontext', () => new W3CTraceContextPropagator()],\n    ['baggage', () => new W3CBaggagePropagator()],\n  ]);\n\n  protected static readonly _registeredExporters = new Map<\n    string,\n    EXPORTER_FACTORY\n  >();\n\n  private readonly _config: TracerConfig;\n  private readonly _registeredSpanProcessors: SpanProcessor[] = [];\n  private readonly _tracers: Map<string, Tracer> = new Map();\n\n  activeSpanProcessor: SpanProcessor;\n  readonly resource: IResource;\n\n  constructor(config: TracerConfig = {}) {\n    const mergedConfig = merge(\n      {},\n      loadDefaultConfig(),\n      reconfigureLimits(config)\n    );\n    this.resource = mergedConfig.resource ?? Resource.empty();\n\n    if (mergedConfig.mergeResourceWithDefaults) {\n      this.resource = Resource.default().merge(this.resource);\n    }\n\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this.resource,\n    });\n\n    if (config.spanProcessors?.length) {\n      this._registeredSpanProcessors = [...config.spanProcessors];\n      this.activeSpanProcessor = new MultiSpanProcessor(\n        this._registeredSpanProcessors\n      );\n    } else {\n      const defaultExporter = this._buildExporterFromEnv();\n      if (defaultExporter !== undefined) {\n        const batchProcessor = new BatchSpanProcessor(defaultExporter);\n        this.activeSpanProcessor = batchProcessor;\n      } else {\n        this.activeSpanProcessor = new NoopSpanProcessor();\n      }\n    }\n  }\n\n  getTracer(\n    name: string,\n    version?: string,\n    options?: { schemaUrl?: string }\n  ): Tracer {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(\n        key,\n        new Tracer(\n          { name, version, schemaUrl: options?.schemaUrl },\n          this._config,\n          this\n        )\n      );\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key)!;\n  }\n\n  /**\n   * @deprecated please use {@link TracerConfig} spanProcessors property\n   * Adds a new {@link SpanProcessor} to this tracer.\n   * @param spanProcessor the new SpanProcessor to be added.\n   */\n  addSpanProcessor(spanProcessor: SpanProcessor): void {\n    if (this._registeredSpanProcessors.length === 0) {\n      // since we might have enabled by default a batchProcessor, we disable it\n      // before adding the new one\n      this.activeSpanProcessor\n        .shutdown()\n        .catch(err =>\n          diag.error(\n            'Error while trying to shutdown current span processor',\n            err\n          )\n        );\n    }\n    this._registeredSpanProcessors.push(spanProcessor);\n    this.activeSpanProcessor = new MultiSpanProcessor(\n      this._registeredSpanProcessors\n    );\n  }\n\n  getActiveSpanProcessor(): SpanProcessor {\n    return this.activeSpanProcessor;\n  }\n\n  /**\n   * Register this TracerProvider for use with the OpenTelemetry API.\n   * Undefined values may be replaced with defaults, and\n   * null values will be skipped.\n   *\n   * @param config Configuration object for SDK registration\n   */\n  register(config: SDKRegistrationConfig = {}): void {\n    trace.setGlobalTracerProvider(this);\n    if (config.propagator === undefined) {\n      config.propagator = this._buildPropagatorFromEnv();\n    }\n\n    if (config.contextManager) {\n      context.setGlobalContextManager(config.contextManager);\n    }\n\n    if (config.propagator) {\n      propagation.setGlobalPropagator(config.propagator);\n    }\n  }\n\n  forceFlush(): Promise<void> {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._registeredSpanProcessors.map(\n      (spanProcessor: SpanProcessor) => {\n        return new Promise(resolve => {\n          let state: ForceFlushState;\n          const timeoutInterval = setTimeout(() => {\n            resolve(\n              new Error(\n                `Span processor did not completed within timeout period of ${timeout} ms`\n              )\n            );\n            state = ForceFlushState.timeout;\n          }, timeout);\n\n          spanProcessor\n            .forceFlush()\n            .then(() => {\n              clearTimeout(timeoutInterval);\n              if (state !== ForceFlushState.timeout) {\n                state = ForceFlushState.resolved;\n                resolve(state);\n              }\n            })\n            .catch(error => {\n              clearTimeout(timeoutInterval);\n              state = ForceFlushState.error;\n              resolve(error);\n            });\n        });\n      }\n    );\n\n    return new Promise<void>((resolve, reject) => {\n      Promise.all(promises)\n        .then(results => {\n          const errors = results.filter(\n            result => result !== ForceFlushState.resolved\n          );\n          if (errors.length > 0) {\n            reject(errors);\n          } else {\n            resolve();\n          }\n        })\n        .catch(error => reject([error]));\n    });\n  }\n\n  shutdown(): Promise<void> {\n    return this.activeSpanProcessor.shutdown();\n  }\n\n  /**\n   * TS cannot yet infer the type of this.constructor:\n   * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146\n   * There is no need to override either of the getters in your child class.\n   * The type of the registered component maps should be the same across all\n   * classes in the inheritance tree.\n   */\n  protected _getPropagator(name: string): TextMapPropagator | undefined {\n    return (\n      this.constructor as typeof BasicTracerProvider\n    )._registeredPropagators.get(name)?.();\n  }\n\n  protected _getSpanExporter(name: string): SpanExporter | undefined {\n    return (\n      this.constructor as typeof BasicTracerProvider\n    )._registeredExporters.get(name)?.();\n  }\n\n  protected _buildPropagatorFromEnv(): TextMapPropagator | undefined {\n    // per spec, propagators from env must be deduplicated\n    const uniquePropagatorNames = Array.from(\n      new Set(getEnv().OTEL_PROPAGATORS)\n    );\n\n    const propagators = uniquePropagatorNames.map(name => {\n      const propagator = this._getPropagator(name);\n      if (!propagator) {\n        diag.warn(\n          `Propagator \"${name}\" requested through environment variable is unavailable.`\n        );\n      }\n\n      return propagator;\n    });\n    const validPropagators = propagators.reduce<TextMapPropagator[]>(\n      (list, item) => {\n        if (item) {\n          list.push(item);\n        }\n        return list;\n      },\n      []\n    );\n\n    if (validPropagators.length === 0) {\n      return;\n    } else if (uniquePropagatorNames.length === 1) {\n      return validPropagators[0];\n    } else {\n      return new CompositePropagator({\n        propagators: validPropagators,\n      });\n    }\n  }\n\n  protected _buildExporterFromEnv(): SpanExporter | undefined {\n    const exporterName = getEnv().OTEL_TRACES_EXPORTER;\n    if (exporterName === 'none' || exporterName === '') return;\n    const exporter = this._getSpanExporter(exporterName);\n    if (!exporter) {\n      diag.error(\n        `Exporter \"${exporterName}\" requested through environment variable is unavailable.`\n      );\n    }\n    return exporter;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport {\n  ExportResult,\n  ExportResultCode,\n  hrTimeToMicroseconds,\n} from '@opentelemetry/core';\n\n/**\n * This is implementation of {@link SpanExporter} that prints spans to the\n * console. This class can be used for diagnostic purposes.\n *\n * NOTE: This {@link SpanExporter} is intended for diagnostics use only, output rendered to the console may change at any time.\n */\n\n/* eslint-disable no-console */\nexport class ConsoleSpanExporter implements SpanExporter {\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    return this._sendSpans(spans, resultCallback);\n  }\n\n  /**\n   * Shutdown the exporter.\n   */\n  shutdown(): Promise<void> {\n    this._sendSpans([]);\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * converts span info into more readable format\n   * @param span\n   */\n  private _exportInfo(span: ReadableSpan) {\n    return {\n      resource: {\n        attributes: span.resource.attributes,\n      },\n      instrumentationScope: span.instrumentationLibrary,\n      traceId: span.spanContext().traceId,\n      parentId: span.parentSpanId,\n      traceState: span.spanContext().traceState?.serialize(),\n      name: span.name,\n      id: span.spanContext().spanId,\n      kind: span.kind,\n      timestamp: hrTimeToMicroseconds(span.startTime),\n      duration: hrTimeToMicroseconds(span.duration),\n      attributes: span.attributes,\n      status: span.status,\n      events: span.events,\n      links: span.links,\n    };\n  }\n\n  /**\n   * Showing spans in console\n   * @param spans\n   * @param done\n   */\n  private _sendSpans(\n    spans: ReadableSpan[],\n    done?: (result: ExportResult) => void\n  ): void {\n    for (const span of spans) {\n      console.dir(this._exportInfo(span), { depth: 3 });\n    }\n    if (done) {\n      return done({ code: ExportResultCode.SUCCESS });\n    }\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanExporter } from './SpanExporter';\nimport { ReadableSpan } from './ReadableSpan';\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\n\n/**\n * This class can be used for testing purposes. It stores the exported spans\n * in a list in memory that can be retrieved using the `getFinishedSpans()`\n * method.\n */\nexport class InMemorySpanExporter implements SpanExporter {\n  private _finishedSpans: ReadableSpan[] = [];\n  /**\n   * Indicates if the exporter has been \"shutdown.\"\n   * When false, exported spans will not be stored in-memory.\n   */\n  protected _stopped = false;\n\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    if (this._stopped)\n      return resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Exporter has been stopped'),\n      });\n    this._finishedSpans.push(...spans);\n\n    setTimeout(() => resultCallback({ code: ExportResultCode.SUCCESS }), 0);\n  }\n\n  shutdown(): Promise<void> {\n    this._stopped = true;\n    this._finishedSpans = [];\n    return this.forceFlush();\n  }\n\n  /**\n   * Exports any pending spans in the exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  reset(): void {\n    this._finishedSpans = [];\n  }\n\n  getFinishedSpans(): ReadableSpan[] {\n    return this._finishedSpans;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, TraceFlags } from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  BindOnceFuture,\n  ExportResult,\n} from '@opentelemetry/core';\nimport { Span } from '../Span';\nimport { SpanProcessor } from '../SpanProcessor';\nimport { ReadableSpan } from './ReadableSpan';\nimport { SpanExporter } from './SpanExporter';\nimport { Resource } from '@opentelemetry/resources';\n\n/**\n * An implementation of the {@link SpanProcessor} that converts the {@link Span}\n * to {@link ReadableSpan} and passes it to the configured exporter.\n *\n * Only spans that are sampled are converted.\n *\n * NOTE: This {@link SpanProcessor} exports every ended span individually instead of batching spans together, which causes significant performance overhead with most exporters. For production use, please consider using the {@link BatchSpanProcessor} instead.\n */\nexport class SimpleSpanProcessor implements SpanProcessor {\n  private _shutdownOnce: BindOnceFuture<void>;\n  private _unresolvedExports: Set<Promise<void>>;\n\n  constructor(private readonly _exporter: SpanExporter) {\n    this._shutdownOnce = new BindOnceFuture(this._shutdown, this);\n    this._unresolvedExports = new Set<Promise<void>>();\n  }\n\n  async forceFlush(): Promise<void> {\n    // await unresolved resources before resolving\n    await Promise.all(Array.from(this._unresolvedExports));\n    if (this._exporter.forceFlush) {\n      await this._exporter.forceFlush();\n    }\n  }\n\n  onStart(_span: Span, _parentContext: Context): void {}\n\n  onEnd(span: ReadableSpan): void {\n    if (this._shutdownOnce.isCalled) {\n      return;\n    }\n\n    if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {\n      return;\n    }\n\n    const doExport = () =>\n      internal\n        ._export(this._exporter, [span])\n        .then((result: ExportResult) => {\n          if (result.code !== ExportResultCode.SUCCESS) {\n            globalErrorHandler(\n              result.error ??\n                new Error(\n                  `SimpleSpanProcessor: span export failed (status ${result})`\n                )\n            );\n          }\n        })\n        .catch(error => {\n          globalErrorHandler(error);\n        });\n\n    // Avoid scheduling a promise to make the behavior more predictable and easier to test\n    if (span.resource.asyncAttributesPending) {\n      const exportPromise = (span.resource as Resource)\n        .waitForAsyncAttributes?.()\n        .then(\n          () => {\n            if (exportPromise != null) {\n              this._unresolvedExports.delete(exportPromise);\n            }\n            return doExport();\n          },\n          err => globalErrorHandler(err)\n        );\n\n      // store the unresolved exports\n      if (exportPromise != null) {\n        this._unresolvedExports.add(exportPromise);\n      }\n    } else {\n      void doExport();\n    }\n  }\n\n  shutdown(): Promise<void> {\n    return this._shutdownOnce.call();\n  }\n\n  private _shutdown(): Promise<void> {\n    return this._exporter.shutdown();\n  }\n}\n"],
  "mappings": "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",
  "names": ["Span", "context", "SamplingDecision", "AlwaysOffSampler", "SamplingDecision", "AlwaysOnSampler", "SamplingDecision", "ParentBasedSampler", "context", "TraceIdRatioBasedSampler", "context", "SamplingDecision", "BatchSpanProcessorBase", "env", "BatchSpanProcessor", "RandomIdGenerator", "Tracer", "context", "MultiSpanProcessor", "__values", "context", "NoopSpanProcessor", "ForceFlushState", "BasicTracerProvider", "__spreadArray", "__read", "ConsoleSpanExporter", "__values", "InMemorySpanExporter", "__spreadArray", "__read", "SimpleSpanProcessor", "_a"]
}
