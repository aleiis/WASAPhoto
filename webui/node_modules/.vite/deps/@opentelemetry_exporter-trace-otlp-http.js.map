{
  "version": 3,
  "sources": ["../../@protobufjs/aspromise/index.js", "../../@protobufjs/base64/index.js", "../../@protobufjs/eventemitter/index.js", "../../@protobufjs/float/index.js", "../../@protobufjs/inquire/index.js", "../../@protobufjs/utf8/index.js", "../../@protobufjs/pool/index.js", "../../protobufjs/src/util/longbits.js", "../../protobufjs/src/util/minimal.js", "../../protobufjs/src/writer.js", "../../protobufjs/src/writer_buffer.js", "../../protobufjs/src/reader.js", "../../protobufjs/src/reader_buffer.js", "../../protobufjs/src/rpc/service.js", "../../protobufjs/src/rpc.js", "../../protobufjs/src/roots.js", "../../protobufjs/src/index-minimal.js", "../../protobufjs/minimal.js", "../../@opentelemetry/otlp-transformer/src/generated/root.js", "../../@opentelemetry/otlp-exporter-base/src/OTLPExporterBase.ts", "../../@opentelemetry/otlp-exporter-base/src/types.ts", "../../@opentelemetry/otlp-exporter-base/src/configuration/shared-configuration.ts", "../../@opentelemetry/otlp-exporter-base/src/configuration/legacy-node-configuration.ts", "../../@opentelemetry/otlp-exporter-base/src/bounded-queue-export-promise-handler.ts", "../../@opentelemetry/otlp-exporter-base/src/logging-response-handler.ts", "../../@opentelemetry/otlp-exporter-base/src/otlp-export-delegate.ts", "../../@opentelemetry/otlp-exporter-base/src/otlp-network-export-delegate.ts", "../../@opentelemetry/otlp-transformer/src/common/index.ts", "../../@opentelemetry/otlp-transformer/src/trace/types.ts", "../../@opentelemetry/otlp-transformer/src/common/internal.ts", "../../@opentelemetry/otlp-transformer/src/trace/internal.ts", "../../@opentelemetry/otlp-transformer/src/resource/internal.ts", "../../@opentelemetry/otlp-transformer/src/trace/index.ts", "../../@opentelemetry/sdk-metrics/src/export/AggregationTemporality.ts", "../../@opentelemetry/sdk-metrics/src/export/MetricData.ts", "../../@opentelemetry/sdk-metrics/src/utils.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/types.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/Drop.ts", "../../@opentelemetry/sdk-metrics/src/InstrumentDescriptor.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/Histogram.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/Buckets.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/ieee754.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/util.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/types.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/ExponentMapping.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/LogarithmMapping.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/exponential-histogram/mapping/getMapping.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/ExponentialHistogram.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/LastValue.ts", "../../@opentelemetry/sdk-metrics/src/aggregator/Sum.ts", "../../@opentelemetry/sdk-metrics/src/view/Aggregation.ts", "../../@opentelemetry/sdk-metrics/src/export/AggregationSelector.ts", "../../@opentelemetry/sdk-metrics/src/export/MetricReader.ts", "../../@opentelemetry/sdk-metrics/src/export/PeriodicExportingMetricReader.ts", "../../@opentelemetry/sdk-metrics/src/export/InMemoryMetricExporter.ts", "../../@opentelemetry/sdk-metrics/src/export/ConsoleMetricExporter.ts", "../../@opentelemetry/sdk-metrics/src/view/ViewRegistry.ts", "../../@opentelemetry/sdk-metrics/src/Instruments.ts", "../../@opentelemetry/sdk-metrics/src/Meter.ts", "../../@opentelemetry/sdk-metrics/src/state/MetricStorage.ts", "../../@opentelemetry/sdk-metrics/src/state/HashMap.ts", "../../@opentelemetry/sdk-metrics/src/state/DeltaMetricProcessor.ts", "../../@opentelemetry/sdk-metrics/src/state/TemporalMetricProcessor.ts", "../../@opentelemetry/sdk-metrics/src/state/AsyncMetricStorage.ts", "../../@opentelemetry/sdk-metrics/src/view/RegistrationConflicts.ts", "../../@opentelemetry/sdk-metrics/src/state/MetricStorageRegistry.ts", "../../@opentelemetry/sdk-metrics/src/state/MultiWritableMetricStorage.ts", "../../@opentelemetry/sdk-metrics/src/ObservableResult.ts", "../../@opentelemetry/sdk-metrics/src/state/ObservableRegistry.ts", "../../@opentelemetry/sdk-metrics/src/state/SyncMetricStorage.ts", "../../@opentelemetry/sdk-metrics/src/view/AttributesProcessor.ts", "../../@opentelemetry/sdk-metrics/src/state/MeterSharedState.ts", "../../@opentelemetry/sdk-metrics/src/state/MeterProviderSharedState.ts", "../../@opentelemetry/sdk-metrics/src/state/MetricCollector.ts", "../../@opentelemetry/sdk-metrics/src/MeterProvider.ts", "../../@opentelemetry/sdk-metrics/src/view/Predicate.ts", "../../@opentelemetry/sdk-metrics/src/view/InstrumentSelector.ts", "../../@opentelemetry/sdk-metrics/src/view/MeterSelector.ts", "../../@opentelemetry/sdk-metrics/src/view/View.ts", "../../@opentelemetry/otlp-transformer/src/protobuf/serializers.ts", "../../@opentelemetry/otlp-transformer/src/json/serializers.ts", "../../@opentelemetry/otlp-exporter-base/src/retrying-transport.ts", "../../@opentelemetry/otlp-exporter-base/src/is-export-retryable.ts", "../../@opentelemetry/otlp-exporter-base/src/transport/xhr-transport.ts", "../../@opentelemetry/otlp-exporter-base/src/transport/send-beacon-transport.ts", "../../@opentelemetry/otlp-exporter-base/src/otlp-browser-http-export-delegate.ts", "../../@opentelemetry/otlp-exporter-base/src/util.ts", "../../@opentelemetry/otlp-exporter-base/src/configuration/otlp-http-configuration.ts", "../../@opentelemetry/otlp-exporter-base/src/configuration/convert-legacy-browser-http-options.ts", "../../@opentelemetry/otlp-exporter-base/src/configuration/create-legacy-browser-delegate.ts", "../../@opentelemetry/exporter-trace-otlp-http/src/platform/browser/OTLPTraceExporter.ts"],
  "sourcesContent": ["\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n", "\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n", "\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n", "\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n", "\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n", "\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n", "\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n", "\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n", "\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n", "\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n", "\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n", "\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n", "\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n", "\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n", "\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n", "// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n", "/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.opentelemetry = (function() {\n\n    /**\n     * Namespace opentelemetry.\n     * @exports opentelemetry\n     * @namespace\n     */\n    var opentelemetry = {};\n\n    opentelemetry.proto = (function() {\n\n        /**\n         * Namespace proto.\n         * @memberof opentelemetry\n         * @namespace\n         */\n        var proto = {};\n\n        proto.common = (function() {\n\n            /**\n             * Namespace common.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var common = {};\n\n            common.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.common\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.AnyValue = (function() {\n\n                    /**\n                     * Properties of an AnyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IAnyValue\n                     * @property {string|null} [stringValue] AnyValue stringValue\n                     * @property {boolean|null} [boolValue] AnyValue boolValue\n                     * @property {number|Long|null} [intValue] AnyValue intValue\n                     * @property {number|null} [doubleValue] AnyValue doubleValue\n                     * @property {opentelemetry.proto.common.v1.IArrayValue|null} [arrayValue] AnyValue arrayValue\n                     * @property {opentelemetry.proto.common.v1.IKeyValueList|null} [kvlistValue] AnyValue kvlistValue\n                     * @property {Uint8Array|null} [bytesValue] AnyValue bytesValue\n                     */\n\n                    /**\n                     * Constructs a new AnyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents an AnyValue.\n                     * @implements IAnyValue\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IAnyValue=} [properties] Properties to set\n                     */\n                    function AnyValue(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * AnyValue stringValue.\n                     * @member {string|null|undefined} stringValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.stringValue = null;\n\n                    /**\n                     * AnyValue boolValue.\n                     * @member {boolean|null|undefined} boolValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.boolValue = null;\n\n                    /**\n                     * AnyValue intValue.\n                     * @member {number|Long|null|undefined} intValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.intValue = null;\n\n                    /**\n                     * AnyValue doubleValue.\n                     * @member {number|null|undefined} doubleValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.doubleValue = null;\n\n                    /**\n                     * AnyValue arrayValue.\n                     * @member {opentelemetry.proto.common.v1.IArrayValue|null|undefined} arrayValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.arrayValue = null;\n\n                    /**\n                     * AnyValue kvlistValue.\n                     * @member {opentelemetry.proto.common.v1.IKeyValueList|null|undefined} kvlistValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.kvlistValue = null;\n\n                    /**\n                     * AnyValue bytesValue.\n                     * @member {Uint8Array|null|undefined} bytesValue\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    AnyValue.prototype.bytesValue = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * AnyValue value.\n                     * @member {\"stringValue\"|\"boolValue\"|\"intValue\"|\"doubleValue\"|\"arrayValue\"|\"kvlistValue\"|\"bytesValue\"|undefined} value\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     */\n                    Object.defineProperty(AnyValue.prototype, \"value\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"stringValue\", \"boolValue\", \"intValue\", \"doubleValue\", \"arrayValue\", \"kvlistValue\", \"bytesValue\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new AnyValue instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IAnyValue=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue instance\n                     */\n                    AnyValue.create = function create(properties) {\n                        return new AnyValue(properties);\n                    };\n\n                    /**\n                     * Encodes the specified AnyValue message. Does not implicitly {@link opentelemetry.proto.common.v1.AnyValue.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IAnyValue} message AnyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AnyValue.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);\n                        if (message.boolValue != null && Object.hasOwnProperty.call(message, \"boolValue\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.boolValue);\n                        if (message.intValue != null && Object.hasOwnProperty.call(message, \"intValue\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int64(message.intValue);\n                        if (message.doubleValue != null && Object.hasOwnProperty.call(message, \"doubleValue\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.doubleValue);\n                        if (message.arrayValue != null && Object.hasOwnProperty.call(message, \"arrayValue\"))\n                            $root.opentelemetry.proto.common.v1.ArrayValue.encode(message.arrayValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.kvlistValue != null && Object.hasOwnProperty.call(message, \"kvlistValue\"))\n                            $root.opentelemetry.proto.common.v1.KeyValueList.encode(message.kvlistValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.bytesValue != null && Object.hasOwnProperty.call(message, \"bytesValue\"))\n                            writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.bytesValue);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified AnyValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.AnyValue.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IAnyValue} message AnyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AnyValue.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an AnyValue message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AnyValue.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.AnyValue();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.stringValue = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.boolValue = reader.bool();\n                                    break;\n                                }\n                            case 3: {\n                                    message.intValue = reader.int64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.doubleValue = reader.double();\n                                    break;\n                                }\n                            case 5: {\n                                    message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 6: {\n                                    message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 7: {\n                                    message.bytesValue = reader.bytes();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an AnyValue message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AnyValue.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an AnyValue message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    AnyValue.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n                            properties.value = 1;\n                            if (!$util.isString(message.stringValue))\n                                return \"stringValue: string expected\";\n                        }\n                        if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (typeof message.boolValue !== \"boolean\")\n                                return \"boolValue: boolean expected\";\n                        }\n                        if (message.intValue != null && message.hasOwnProperty(\"intValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))\n                                return \"intValue: integer|Long expected\";\n                        }\n                        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (typeof message.doubleValue !== \"number\")\n                                return \"doubleValue: number expected\";\n                        }\n                        if (message.arrayValue != null && message.hasOwnProperty(\"arrayValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            {\n                                var error = $root.opentelemetry.proto.common.v1.ArrayValue.verify(message.arrayValue);\n                                if (error)\n                                    return \"arrayValue.\" + error;\n                            }\n                        }\n                        if (message.kvlistValue != null && message.hasOwnProperty(\"kvlistValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValueList.verify(message.kvlistValue);\n                                if (error)\n                                    return \"kvlistValue.\" + error;\n                            }\n                        }\n                        if (message.bytesValue != null && message.hasOwnProperty(\"bytesValue\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!(message.bytesValue && typeof message.bytesValue.length === \"number\" || $util.isString(message.bytesValue)))\n                                return \"bytesValue: buffer expected\";\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates an AnyValue message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue\n                     */\n                    AnyValue.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.AnyValue)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.AnyValue();\n                        if (object.stringValue != null)\n                            message.stringValue = String(object.stringValue);\n                        if (object.boolValue != null)\n                            message.boolValue = Boolean(object.boolValue);\n                        if (object.intValue != null)\n                            if ($util.Long)\n                                (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;\n                            else if (typeof object.intValue === \"string\")\n                                message.intValue = parseInt(object.intValue, 10);\n                            else if (typeof object.intValue === \"number\")\n                                message.intValue = object.intValue;\n                            else if (typeof object.intValue === \"object\")\n                                message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();\n                        if (object.doubleValue != null)\n                            message.doubleValue = Number(object.doubleValue);\n                        if (object.arrayValue != null) {\n                            if (typeof object.arrayValue !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.common.v1.AnyValue.arrayValue: object expected\");\n                            message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.fromObject(object.arrayValue);\n                        }\n                        if (object.kvlistValue != null) {\n                            if (typeof object.kvlistValue !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.common.v1.AnyValue.kvlistValue: object expected\");\n                            message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.fromObject(object.kvlistValue);\n                        }\n                        if (object.bytesValue != null)\n                            if (typeof object.bytesValue === \"string\")\n                                $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);\n                            else if (object.bytesValue.length >= 0)\n                                message.bytesValue = object.bytesValue;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an AnyValue message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.AnyValue} message AnyValue\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    AnyValue.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n                            object.stringValue = message.stringValue;\n                            if (options.oneofs)\n                                object.value = \"stringValue\";\n                        }\n                        if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n                            object.boolValue = message.boolValue;\n                            if (options.oneofs)\n                                object.value = \"boolValue\";\n                        }\n                        if (message.intValue != null && message.hasOwnProperty(\"intValue\")) {\n                            if (typeof message.intValue === \"number\")\n                                object.intValue = options.longs === String ? String(message.intValue) : message.intValue;\n                            else\n                                object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;\n                            if (options.oneofs)\n                                object.value = \"intValue\";\n                        }\n                        if (message.doubleValue != null && message.hasOwnProperty(\"doubleValue\")) {\n                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;\n                            if (options.oneofs)\n                                object.value = \"doubleValue\";\n                        }\n                        if (message.arrayValue != null && message.hasOwnProperty(\"arrayValue\")) {\n                            object.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.toObject(message.arrayValue, options);\n                            if (options.oneofs)\n                                object.value = \"arrayValue\";\n                        }\n                        if (message.kvlistValue != null && message.hasOwnProperty(\"kvlistValue\")) {\n                            object.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.toObject(message.kvlistValue, options);\n                            if (options.oneofs)\n                                object.value = \"kvlistValue\";\n                        }\n                        if (message.bytesValue != null && message.hasOwnProperty(\"bytesValue\")) {\n                            object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;\n                            if (options.oneofs)\n                                object.value = \"bytesValue\";\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this AnyValue to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    AnyValue.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for AnyValue\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.AnyValue\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    AnyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.AnyValue\";\n                    };\n\n                    return AnyValue;\n                })();\n\n                v1.ArrayValue = (function() {\n\n                    /**\n                     * Properties of an ArrayValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IArrayValue\n                     * @property {Array.<opentelemetry.proto.common.v1.IAnyValue>|null} [values] ArrayValue values\n                     */\n\n                    /**\n                     * Constructs a new ArrayValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents an ArrayValue.\n                     * @implements IArrayValue\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IArrayValue=} [properties] Properties to set\n                     */\n                    function ArrayValue(properties) {\n                        this.values = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ArrayValue values.\n                     * @member {Array.<opentelemetry.proto.common.v1.IAnyValue>} values\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @instance\n                     */\n                    ArrayValue.prototype.values = $util.emptyArray;\n\n                    /**\n                     * Creates a new ArrayValue instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IArrayValue=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue instance\n                     */\n                    ArrayValue.create = function create(properties) {\n                        return new ArrayValue(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ArrayValue message. Does not implicitly {@link opentelemetry.proto.common.v1.ArrayValue.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IArrayValue} message ArrayValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ArrayValue.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.values != null && message.values.length)\n                            for (var i = 0; i < message.values.length; ++i)\n                                $root.opentelemetry.proto.common.v1.AnyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ArrayValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.ArrayValue.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IArrayValue} message ArrayValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ArrayValue.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an ArrayValue message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ArrayValue.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.ArrayValue();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.values && message.values.length))\n                                        message.values = [];\n                                    message.values.push($root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an ArrayValue message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ArrayValue.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an ArrayValue message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ArrayValue.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.values != null && message.hasOwnProperty(\"values\")) {\n                            if (!Array.isArray(message.values))\n                                return \"values: array expected\";\n                            for (var i = 0; i < message.values.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.values[i]);\n                                if (error)\n                                    return \"values.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates an ArrayValue message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue\n                     */\n                    ArrayValue.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.ArrayValue)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.ArrayValue();\n                        if (object.values) {\n                            if (!Array.isArray(object.values))\n                                throw TypeError(\".opentelemetry.proto.common.v1.ArrayValue.values: array expected\");\n                            message.values = [];\n                            for (var i = 0; i < object.values.length; ++i) {\n                                if (typeof object.values[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.common.v1.ArrayValue.values: object expected\");\n                                message.values[i] = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.values[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an ArrayValue message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.ArrayValue} message ArrayValue\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ArrayValue.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.values = [];\n                        if (message.values && message.values.length) {\n                            object.values = [];\n                            for (var j = 0; j < message.values.length; ++j)\n                                object.values[j] = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.values[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ArrayValue to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ArrayValue.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ArrayValue\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.ArrayValue\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ArrayValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.ArrayValue\";\n                    };\n\n                    return ArrayValue;\n                })();\n\n                v1.KeyValueList = (function() {\n\n                    /**\n                     * Properties of a KeyValueList.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IKeyValueList\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [values] KeyValueList values\n                     */\n\n                    /**\n                     * Constructs a new KeyValueList.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents a KeyValueList.\n                     * @implements IKeyValueList\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList=} [properties] Properties to set\n                     */\n                    function KeyValueList(properties) {\n                        this.values = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * KeyValueList values.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} values\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @instance\n                     */\n                    KeyValueList.prototype.values = $util.emptyArray;\n\n                    /**\n                     * Creates a new KeyValueList instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList instance\n                     */\n                    KeyValueList.create = function create(properties) {\n                        return new KeyValueList(properties);\n                    };\n\n                    /**\n                     * Encodes the specified KeyValueList message. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValueList.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList} message KeyValueList message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValueList.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.values != null && message.values.length)\n                            for (var i = 0; i < message.values.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified KeyValueList message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValueList.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValueList} message KeyValueList message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValueList.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a KeyValueList message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValueList.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValueList();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.values && message.values.length))\n                                        message.values = [];\n                                    message.values.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a KeyValueList message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValueList.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a KeyValueList message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    KeyValueList.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.values != null && message.hasOwnProperty(\"values\")) {\n                            if (!Array.isArray(message.values))\n                                return \"values: array expected\";\n                            for (var i = 0; i < message.values.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.values[i]);\n                                if (error)\n                                    return \"values.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a KeyValueList message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList\n                     */\n                    KeyValueList.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.KeyValueList)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.KeyValueList();\n                        if (object.values) {\n                            if (!Array.isArray(object.values))\n                                throw TypeError(\".opentelemetry.proto.common.v1.KeyValueList.values: array expected\");\n                            message.values = [];\n                            for (var i = 0; i < object.values.length; ++i) {\n                                if (typeof object.values[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.common.v1.KeyValueList.values: object expected\");\n                                message.values[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.values[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a KeyValueList message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.KeyValueList} message KeyValueList\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    KeyValueList.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.values = [];\n                        if (message.values && message.values.length) {\n                            object.values = [];\n                            for (var j = 0; j < message.values.length; ++j)\n                                object.values[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.values[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this KeyValueList to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    KeyValueList.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for KeyValueList\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.KeyValueList\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    KeyValueList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.KeyValueList\";\n                    };\n\n                    return KeyValueList;\n                })();\n\n                v1.KeyValue = (function() {\n\n                    /**\n                     * Properties of a KeyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IKeyValue\n                     * @property {string|null} [key] KeyValue key\n                     * @property {opentelemetry.proto.common.v1.IAnyValue|null} [value] KeyValue value\n                     */\n\n                    /**\n                     * Constructs a new KeyValue.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents a KeyValue.\n                     * @implements IKeyValue\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IKeyValue=} [properties] Properties to set\n                     */\n                    function KeyValue(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * KeyValue key.\n                     * @member {string|null|undefined} key\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @instance\n                     */\n                    KeyValue.prototype.key = null;\n\n                    /**\n                     * KeyValue value.\n                     * @member {opentelemetry.proto.common.v1.IAnyValue|null|undefined} value\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @instance\n                     */\n                    KeyValue.prototype.value = null;\n\n                    /**\n                     * Creates a new KeyValue instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValue=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue instance\n                     */\n                    KeyValue.create = function create(properties) {\n                        return new KeyValue(properties);\n                    };\n\n                    /**\n                     * Encodes the specified KeyValue message. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValue.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValue} message KeyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValue.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.key != null && Object.hasOwnProperty.call(message, \"key\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);\n                        if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n                            $root.opentelemetry.proto.common.v1.AnyValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValue.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IKeyValue} message KeyValue message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    KeyValue.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a KeyValue message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValue.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValue();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.key = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.value = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a KeyValue message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    KeyValue.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a KeyValue message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    KeyValue.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.key != null && message.hasOwnProperty(\"key\"))\n                            if (!$util.isString(message.key))\n                                return \"key: string expected\";\n                        if (message.value != null && message.hasOwnProperty(\"value\")) {\n                            var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.value);\n                            if (error)\n                                return \"value.\" + error;\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue\n                     */\n                    KeyValue.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.KeyValue)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.KeyValue();\n                        if (object.key != null)\n                            message.key = String(object.key);\n                        if (object.value != null) {\n                            if (typeof object.value !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.common.v1.KeyValue.value: object expected\");\n                            message.value = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.value);\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a KeyValue message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.KeyValue} message KeyValue\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    KeyValue.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.defaults) {\n                            object.key = \"\";\n                            object.value = null;\n                        }\n                        if (message.key != null && message.hasOwnProperty(\"key\"))\n                            object.key = message.key;\n                        if (message.value != null && message.hasOwnProperty(\"value\"))\n                            object.value = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.value, options);\n                        return object;\n                    };\n\n                    /**\n                     * Converts this KeyValue to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    KeyValue.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for KeyValue\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.KeyValue\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    KeyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.KeyValue\";\n                    };\n\n                    return KeyValue;\n                })();\n\n                v1.InstrumentationScope = (function() {\n\n                    /**\n                     * Properties of an InstrumentationScope.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @interface IInstrumentationScope\n                     * @property {string|null} [name] InstrumentationScope name\n                     * @property {string|null} [version] InstrumentationScope version\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] InstrumentationScope attributes\n                     * @property {number|null} [droppedAttributesCount] InstrumentationScope droppedAttributesCount\n                     */\n\n                    /**\n                     * Constructs a new InstrumentationScope.\n                     * @memberof opentelemetry.proto.common.v1\n                     * @classdesc Represents an InstrumentationScope.\n                     * @implements IInstrumentationScope\n                     * @constructor\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope=} [properties] Properties to set\n                     */\n                    function InstrumentationScope(properties) {\n                        this.attributes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * InstrumentationScope name.\n                     * @member {string|null|undefined} name\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.name = null;\n\n                    /**\n                     * InstrumentationScope version.\n                     * @member {string|null|undefined} version\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.version = null;\n\n                    /**\n                     * InstrumentationScope attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * InstrumentationScope droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     */\n                    InstrumentationScope.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * Creates a new InstrumentationScope instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope instance\n                     */\n                    InstrumentationScope.create = function create(properties) {\n                        return new InstrumentationScope(properties);\n                    };\n\n                    /**\n                     * Encodes the specified InstrumentationScope message. Does not implicitly {@link opentelemetry.proto.common.v1.InstrumentationScope.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope} message InstrumentationScope message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    InstrumentationScope.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.droppedAttributesCount);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified InstrumentationScope message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.InstrumentationScope.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope} message InstrumentationScope message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    InstrumentationScope.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an InstrumentationScope message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    InstrumentationScope.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.name = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.version = reader.string();\n                                    break;\n                                }\n                            case 3: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 4: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an InstrumentationScope message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    InstrumentationScope.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an InstrumentationScope message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    InstrumentationScope.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            if (!$util.isString(message.name))\n                                return \"name: string expected\";\n                        if (message.version != null && message.hasOwnProperty(\"version\"))\n                            if (!$util.isString(message.version))\n                                return \"version: string expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates an InstrumentationScope message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope\n                     */\n                    InstrumentationScope.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.common.v1.InstrumentationScope)\n                            return object;\n                        var message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        if (object.version != null)\n                            message.version = String(object.version);\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.common.v1.InstrumentationScope.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.common.v1.InstrumentationScope.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an InstrumentationScope message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {opentelemetry.proto.common.v1.InstrumentationScope} message InstrumentationScope\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    InstrumentationScope.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.attributes = [];\n                        if (options.defaults) {\n                            object.name = \"\";\n                            object.version = \"\";\n                            object.droppedAttributesCount = 0;\n                        }\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.version != null && message.hasOwnProperty(\"version\"))\n                            object.version = message.version;\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this InstrumentationScope to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    InstrumentationScope.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for InstrumentationScope\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    InstrumentationScope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.common.v1.InstrumentationScope\";\n                    };\n\n                    return InstrumentationScope;\n                })();\n\n                return v1;\n            })();\n\n            return common;\n        })();\n\n        proto.resource = (function() {\n\n            /**\n             * Namespace resource.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var resource = {};\n\n            resource.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.resource\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.Resource = (function() {\n\n                    /**\n                     * Properties of a Resource.\n                     * @memberof opentelemetry.proto.resource.v1\n                     * @interface IResource\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Resource attributes\n                     * @property {number|null} [droppedAttributesCount] Resource droppedAttributesCount\n                     */\n\n                    /**\n                     * Constructs a new Resource.\n                     * @memberof opentelemetry.proto.resource.v1\n                     * @classdesc Represents a Resource.\n                     * @implements IResource\n                     * @constructor\n                     * @param {opentelemetry.proto.resource.v1.IResource=} [properties] Properties to set\n                     */\n                    function Resource(properties) {\n                        this.attributes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Resource attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @instance\n                     */\n                    Resource.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * Resource droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @instance\n                     */\n                    Resource.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * Creates a new Resource instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.IResource=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource instance\n                     */\n                    Resource.create = function create(properties) {\n                        return new Resource(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Resource message. Does not implicitly {@link opentelemetry.proto.resource.v1.Resource.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.IResource} message Resource message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Resource.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.droppedAttributesCount);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Resource message, length delimited. Does not implicitly {@link opentelemetry.proto.resource.v1.Resource.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.IResource} message Resource message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Resource.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Resource message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Resource.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.resource.v1.Resource();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Resource message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Resource.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Resource message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Resource.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Resource message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource\n                     */\n                    Resource.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.resource.v1.Resource)\n                            return object;\n                        var message = new $root.opentelemetry.proto.resource.v1.Resource();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.resource.v1.Resource.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.resource.v1.Resource.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Resource message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {opentelemetry.proto.resource.v1.Resource} message Resource\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Resource.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.attributes = [];\n                        if (options.defaults)\n                            object.droppedAttributesCount = 0;\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Resource to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Resource.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Resource\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.resource.v1.Resource\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Resource.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.resource.v1.Resource\";\n                    };\n\n                    return Resource;\n                })();\n\n                return v1;\n            })();\n\n            return resource;\n        })();\n\n        proto.trace = (function() {\n\n            /**\n             * Namespace trace.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var trace = {};\n\n            trace.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.trace\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.TracesData = (function() {\n\n                    /**\n                     * Properties of a TracesData.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface ITracesData\n                     * @property {Array.<opentelemetry.proto.trace.v1.IResourceSpans>|null} [resourceSpans] TracesData resourceSpans\n                     */\n\n                    /**\n                     * Constructs a new TracesData.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a TracesData.\n                     * @implements ITracesData\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.ITracesData=} [properties] Properties to set\n                     */\n                    function TracesData(properties) {\n                        this.resourceSpans = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * TracesData resourceSpans.\n                     * @member {Array.<opentelemetry.proto.trace.v1.IResourceSpans>} resourceSpans\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @instance\n                     */\n                    TracesData.prototype.resourceSpans = $util.emptyArray;\n\n                    /**\n                     * Creates a new TracesData instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ITracesData=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData instance\n                     */\n                    TracesData.create = function create(properties) {\n                        return new TracesData(properties);\n                    };\n\n                    /**\n                     * Encodes the specified TracesData message. Does not implicitly {@link opentelemetry.proto.trace.v1.TracesData.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ITracesData} message TracesData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    TracesData.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resourceSpans != null && message.resourceSpans.length)\n                            for (var i = 0; i < message.resourceSpans.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified TracesData message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.TracesData.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ITracesData} message TracesData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    TracesData.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a TracesData message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    TracesData.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.TracesData();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.resourceSpans && message.resourceSpans.length))\n                                        message.resourceSpans = [];\n                                    message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a TracesData message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    TracesData.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a TracesData message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    TracesData.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resourceSpans != null && message.hasOwnProperty(\"resourceSpans\")) {\n                            if (!Array.isArray(message.resourceSpans))\n                                return \"resourceSpans: array expected\";\n                            for (var i = 0; i < message.resourceSpans.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);\n                                if (error)\n                                    return \"resourceSpans.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a TracesData message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData\n                     */\n                    TracesData.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.TracesData)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.TracesData();\n                        if (object.resourceSpans) {\n                            if (!Array.isArray(object.resourceSpans))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.TracesData.resourceSpans: array expected\");\n                            message.resourceSpans = [];\n                            for (var i = 0; i < object.resourceSpans.length; ++i) {\n                                if (typeof object.resourceSpans[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.TracesData.resourceSpans: object expected\");\n                                message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a TracesData message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.TracesData} message TracesData\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    TracesData.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.resourceSpans = [];\n                        if (message.resourceSpans && message.resourceSpans.length) {\n                            object.resourceSpans = [];\n                            for (var j = 0; j < message.resourceSpans.length; ++j)\n                                object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this TracesData to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    TracesData.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for TracesData\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.TracesData\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    TracesData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.TracesData\";\n                    };\n\n                    return TracesData;\n                })();\n\n                v1.ResourceSpans = (function() {\n\n                    /**\n                     * Properties of a ResourceSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface IResourceSpans\n                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceSpans resource\n                     * @property {Array.<opentelemetry.proto.trace.v1.IScopeSpans>|null} [scopeSpans] ResourceSpans scopeSpans\n                     * @property {string|null} [schemaUrl] ResourceSpans schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ResourceSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a ResourceSpans.\n                     * @implements IResourceSpans\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans=} [properties] Properties to set\n                     */\n                    function ResourceSpans(properties) {\n                        this.scopeSpans = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ResourceSpans resource.\n                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     */\n                    ResourceSpans.prototype.resource = null;\n\n                    /**\n                     * ResourceSpans scopeSpans.\n                     * @member {Array.<opentelemetry.proto.trace.v1.IScopeSpans>} scopeSpans\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     */\n                    ResourceSpans.prototype.scopeSpans = $util.emptyArray;\n\n                    /**\n                     * ResourceSpans schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     */\n                    ResourceSpans.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ResourceSpans instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans instance\n                     */\n                    ResourceSpans.create = function create(properties) {\n                        return new ResourceSpans(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ResourceSpans message. Does not implicitly {@link opentelemetry.proto.trace.v1.ResourceSpans.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans} message ResourceSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceSpans.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resource != null && Object.hasOwnProperty.call(message, \"resource\"))\n                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.scopeSpans != null && message.scopeSpans.length)\n                            for (var i = 0; i < message.scopeSpans.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.ScopeSpans.encode(message.scopeSpans[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ResourceSpans message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.ResourceSpans.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IResourceSpans} message ResourceSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceSpans.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ResourceSpans message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceSpans.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.scopeSpans && message.scopeSpans.length))\n                                        message.scopeSpans = [];\n                                    message.scopeSpans.push($root.opentelemetry.proto.trace.v1.ScopeSpans.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ResourceSpans message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceSpans.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ResourceSpans message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ResourceSpans.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resource != null && message.hasOwnProperty(\"resource\")) {\n                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);\n                            if (error)\n                                return \"resource.\" + error;\n                        }\n                        if (message.scopeSpans != null && message.hasOwnProperty(\"scopeSpans\")) {\n                            if (!Array.isArray(message.scopeSpans))\n                                return \"scopeSpans: array expected\";\n                            for (var i = 0; i < message.scopeSpans.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.ScopeSpans.verify(message.scopeSpans[i]);\n                                if (error)\n                                    return \"scopeSpans.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ResourceSpans message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans\n                     */\n                    ResourceSpans.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.ResourceSpans)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();\n                        if (object.resource != null) {\n                            if (typeof object.resource !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ResourceSpans.resource: object expected\");\n                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);\n                        }\n                        if (object.scopeSpans) {\n                            if (!Array.isArray(object.scopeSpans))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: array expected\");\n                            message.scopeSpans = [];\n                            for (var i = 0; i < object.scopeSpans.length; ++i) {\n                                if (typeof object.scopeSpans[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: object expected\");\n                                message.scopeSpans[i] = $root.opentelemetry.proto.trace.v1.ScopeSpans.fromObject(object.scopeSpans[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ResourceSpans message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ResourceSpans} message ResourceSpans\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ResourceSpans.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.scopeSpans = [];\n                        if (options.defaults) {\n                            object.resource = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.resource != null && message.hasOwnProperty(\"resource\"))\n                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);\n                        if (message.scopeSpans && message.scopeSpans.length) {\n                            object.scopeSpans = [];\n                            for (var j = 0; j < message.scopeSpans.length; ++j)\n                                object.scopeSpans[j] = $root.opentelemetry.proto.trace.v1.ScopeSpans.toObject(message.scopeSpans[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ResourceSpans to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ResourceSpans.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ResourceSpans\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ResourceSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.ResourceSpans\";\n                    };\n\n                    return ResourceSpans;\n                })();\n\n                v1.ScopeSpans = (function() {\n\n                    /**\n                     * Properties of a ScopeSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface IScopeSpans\n                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeSpans scope\n                     * @property {Array.<opentelemetry.proto.trace.v1.ISpan>|null} [spans] ScopeSpans spans\n                     * @property {string|null} [schemaUrl] ScopeSpans schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ScopeSpans.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a ScopeSpans.\n                     * @implements IScopeSpans\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans=} [properties] Properties to set\n                     */\n                    function ScopeSpans(properties) {\n                        this.spans = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ScopeSpans scope.\n                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     */\n                    ScopeSpans.prototype.scope = null;\n\n                    /**\n                     * ScopeSpans spans.\n                     * @member {Array.<opentelemetry.proto.trace.v1.ISpan>} spans\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     */\n                    ScopeSpans.prototype.spans = $util.emptyArray;\n\n                    /**\n                     * ScopeSpans schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     */\n                    ScopeSpans.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ScopeSpans instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans instance\n                     */\n                    ScopeSpans.create = function create(properties) {\n                        return new ScopeSpans(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ScopeSpans message. Does not implicitly {@link opentelemetry.proto.trace.v1.ScopeSpans.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans} message ScopeSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeSpans.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.spans != null && message.spans.length)\n                            for (var i = 0; i < message.spans.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.Span.encode(message.spans[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ScopeSpans message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.ScopeSpans.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IScopeSpans} message ScopeSpans message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeSpans.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ScopeSpans message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeSpans.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.spans && message.spans.length))\n                                        message.spans = [];\n                                    message.spans.push($root.opentelemetry.proto.trace.v1.Span.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ScopeSpans message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeSpans.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ScopeSpans message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ScopeSpans.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.scope != null && message.hasOwnProperty(\"scope\")) {\n                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);\n                            if (error)\n                                return \"scope.\" + error;\n                        }\n                        if (message.spans != null && message.hasOwnProperty(\"spans\")) {\n                            if (!Array.isArray(message.spans))\n                                return \"spans: array expected\";\n                            for (var i = 0; i < message.spans.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.Span.verify(message.spans[i]);\n                                if (error)\n                                    return \"spans.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ScopeSpans message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans\n                     */\n                    ScopeSpans.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.ScopeSpans)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();\n                        if (object.scope != null) {\n                            if (typeof object.scope !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ScopeSpans.scope: object expected\");\n                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);\n                        }\n                        if (object.spans) {\n                            if (!Array.isArray(object.spans))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.ScopeSpans.spans: array expected\");\n                            message.spans = [];\n                            for (var i = 0; i < object.spans.length; ++i) {\n                                if (typeof object.spans[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.ScopeSpans.spans: object expected\");\n                                message.spans[i] = $root.opentelemetry.proto.trace.v1.Span.fromObject(object.spans[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ScopeSpans message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ScopeSpans} message ScopeSpans\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ScopeSpans.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.spans = [];\n                        if (options.defaults) {\n                            object.scope = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);\n                        if (message.spans && message.spans.length) {\n                            object.spans = [];\n                            for (var j = 0; j < message.spans.length; ++j)\n                                object.spans[j] = $root.opentelemetry.proto.trace.v1.Span.toObject(message.spans[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ScopeSpans to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ScopeSpans.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ScopeSpans\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ScopeSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.ScopeSpans\";\n                    };\n\n                    return ScopeSpans;\n                })();\n\n                v1.Span = (function() {\n\n                    /**\n                     * Properties of a Span.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface ISpan\n                     * @property {Uint8Array|null} [traceId] Span traceId\n                     * @property {Uint8Array|null} [spanId] Span spanId\n                     * @property {string|null} [traceState] Span traceState\n                     * @property {Uint8Array|null} [parentSpanId] Span parentSpanId\n                     * @property {string|null} [name] Span name\n                     * @property {opentelemetry.proto.trace.v1.Span.SpanKind|null} [kind] Span kind\n                     * @property {number|Long|null} [startTimeUnixNano] Span startTimeUnixNano\n                     * @property {number|Long|null} [endTimeUnixNano] Span endTimeUnixNano\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Span attributes\n                     * @property {number|null} [droppedAttributesCount] Span droppedAttributesCount\n                     * @property {Array.<opentelemetry.proto.trace.v1.Span.IEvent>|null} [events] Span events\n                     * @property {number|null} [droppedEventsCount] Span droppedEventsCount\n                     * @property {Array.<opentelemetry.proto.trace.v1.Span.ILink>|null} [links] Span links\n                     * @property {number|null} [droppedLinksCount] Span droppedLinksCount\n                     * @property {opentelemetry.proto.trace.v1.IStatus|null} [status] Span status\n                     */\n\n                    /**\n                     * Constructs a new Span.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a Span.\n                     * @implements ISpan\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.ISpan=} [properties] Properties to set\n                     */\n                    function Span(properties) {\n                        this.attributes = [];\n                        this.events = [];\n                        this.links = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Span traceId.\n                     * @member {Uint8Array|null|undefined} traceId\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.traceId = null;\n\n                    /**\n                     * Span spanId.\n                     * @member {Uint8Array|null|undefined} spanId\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.spanId = null;\n\n                    /**\n                     * Span traceState.\n                     * @member {string|null|undefined} traceState\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.traceState = null;\n\n                    /**\n                     * Span parentSpanId.\n                     * @member {Uint8Array|null|undefined} parentSpanId\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.parentSpanId = null;\n\n                    /**\n                     * Span name.\n                     * @member {string|null|undefined} name\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.name = null;\n\n                    /**\n                     * Span kind.\n                     * @member {opentelemetry.proto.trace.v1.Span.SpanKind|null|undefined} kind\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.kind = null;\n\n                    /**\n                     * Span startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * Span endTimeUnixNano.\n                     * @member {number|Long|null|undefined} endTimeUnixNano\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.endTimeUnixNano = null;\n\n                    /**\n                     * Span attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * Span droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * Span events.\n                     * @member {Array.<opentelemetry.proto.trace.v1.Span.IEvent>} events\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.events = $util.emptyArray;\n\n                    /**\n                     * Span droppedEventsCount.\n                     * @member {number|null|undefined} droppedEventsCount\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.droppedEventsCount = null;\n\n                    /**\n                     * Span links.\n                     * @member {Array.<opentelemetry.proto.trace.v1.Span.ILink>} links\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.links = $util.emptyArray;\n\n                    /**\n                     * Span droppedLinksCount.\n                     * @member {number|null|undefined} droppedLinksCount\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.droppedLinksCount = null;\n\n                    /**\n                     * Span status.\n                     * @member {opentelemetry.proto.trace.v1.IStatus|null|undefined} status\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     */\n                    Span.prototype.status = null;\n\n                    /**\n                     * Creates a new Span instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ISpan=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span instance\n                     */\n                    Span.create = function create(properties) {\n                        return new Span(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Span message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ISpan} message Span message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Span.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.traceId);\n                        if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spanId);\n                        if (message.traceState != null && Object.hasOwnProperty.call(message, \"traceState\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.traceState);\n                        if (message.parentSpanId != null && Object.hasOwnProperty.call(message, \"parentSpanId\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.parentSpanId);\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);\n                        if (message.kind != null && Object.hasOwnProperty.call(message, \"kind\"))\n                            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.kind);\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 7, wireType 1 =*/57).fixed64(message.startTimeUnixNano);\n                        if (message.endTimeUnixNano != null && Object.hasOwnProperty.call(message, \"endTimeUnixNano\"))\n                            writer.uint32(/* id 8, wireType 1 =*/65).fixed64(message.endTimeUnixNano);\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.droppedAttributesCount);\n                        if (message.events != null && message.events.length)\n                            for (var i = 0; i < message.events.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.Span.Event.encode(message.events[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                        if (message.droppedEventsCount != null && Object.hasOwnProperty.call(message, \"droppedEventsCount\"))\n                            writer.uint32(/* id 12, wireType 0 =*/96).uint32(message.droppedEventsCount);\n                        if (message.links != null && message.links.length)\n                            for (var i = 0; i < message.links.length; ++i)\n                                $root.opentelemetry.proto.trace.v1.Span.Link.encode(message.links[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();\n                        if (message.droppedLinksCount != null && Object.hasOwnProperty.call(message, \"droppedLinksCount\"))\n                            writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.droppedLinksCount);\n                        if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                            $root.opentelemetry.proto.trace.v1.Status.encode(message.status, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Span message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.ISpan} message Span message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Span.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Span message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Span.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.traceId = reader.bytes();\n                                    break;\n                                }\n                            case 2: {\n                                    message.spanId = reader.bytes();\n                                    break;\n                                }\n                            case 3: {\n                                    message.traceState = reader.string();\n                                    break;\n                                }\n                            case 4: {\n                                    message.parentSpanId = reader.bytes();\n                                    break;\n                                }\n                            case 5: {\n                                    message.name = reader.string();\n                                    break;\n                                }\n                            case 6: {\n                                    message.kind = reader.int32();\n                                    break;\n                                }\n                            case 7: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 8: {\n                                    message.endTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 9: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 10: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            case 11: {\n                                    if (!(message.events && message.events.length))\n                                        message.events = [];\n                                    message.events.push($root.opentelemetry.proto.trace.v1.Span.Event.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 12: {\n                                    message.droppedEventsCount = reader.uint32();\n                                    break;\n                                }\n                            case 13: {\n                                    if (!(message.links && message.links.length))\n                                        message.links = [];\n                                    message.links.push($root.opentelemetry.proto.trace.v1.Span.Link.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 14: {\n                                    message.droppedLinksCount = reader.uint32();\n                                    break;\n                                }\n                            case 15: {\n                                    message.status = $root.opentelemetry.proto.trace.v1.Status.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Span message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Span.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Span message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Span.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                return \"traceId: buffer expected\";\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                return \"spanId: buffer expected\";\n                        if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                            if (!$util.isString(message.traceState))\n                                return \"traceState: string expected\";\n                        if (message.parentSpanId != null && message.hasOwnProperty(\"parentSpanId\"))\n                            if (!(message.parentSpanId && typeof message.parentSpanId.length === \"number\" || $util.isString(message.parentSpanId)))\n                                return \"parentSpanId: buffer expected\";\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            if (!$util.isString(message.name))\n                                return \"name: string expected\";\n                        if (message.kind != null && message.hasOwnProperty(\"kind\"))\n                            switch (message.kind) {\n                            default:\n                                return \"kind: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                            case 3:\n                            case 4:\n                            case 5:\n                                break;\n                            }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.endTimeUnixNano != null && message.hasOwnProperty(\"endTimeUnixNano\"))\n                            if (!$util.isInteger(message.endTimeUnixNano) && !(message.endTimeUnixNano && $util.isInteger(message.endTimeUnixNano.low) && $util.isInteger(message.endTimeUnixNano.high)))\n                                return \"endTimeUnixNano: integer|Long expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        if (message.events != null && message.hasOwnProperty(\"events\")) {\n                            if (!Array.isArray(message.events))\n                                return \"events: array expected\";\n                            for (var i = 0; i < message.events.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.Span.Event.verify(message.events[i]);\n                                if (error)\n                                    return \"events.\" + error;\n                            }\n                        }\n                        if (message.droppedEventsCount != null && message.hasOwnProperty(\"droppedEventsCount\"))\n                            if (!$util.isInteger(message.droppedEventsCount))\n                                return \"droppedEventsCount: integer expected\";\n                        if (message.links != null && message.hasOwnProperty(\"links\")) {\n                            if (!Array.isArray(message.links))\n                                return \"links: array expected\";\n                            for (var i = 0; i < message.links.length; ++i) {\n                                var error = $root.opentelemetry.proto.trace.v1.Span.Link.verify(message.links[i]);\n                                if (error)\n                                    return \"links.\" + error;\n                            }\n                        }\n                        if (message.droppedLinksCount != null && message.hasOwnProperty(\"droppedLinksCount\"))\n                            if (!$util.isInteger(message.droppedLinksCount))\n                                return \"droppedLinksCount: integer expected\";\n                        if (message.status != null && message.hasOwnProperty(\"status\")) {\n                            var error = $root.opentelemetry.proto.trace.v1.Status.verify(message.status);\n                            if (error)\n                                return \"status.\" + error;\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Span message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.Span} Span\n                     */\n                    Span.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.Span)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.Span();\n                        if (object.traceId != null)\n                            if (typeof object.traceId === \"string\")\n                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                            else if (object.traceId.length >= 0)\n                                message.traceId = object.traceId;\n                        if (object.spanId != null)\n                            if (typeof object.spanId === \"string\")\n                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                            else if (object.spanId.length >= 0)\n                                message.spanId = object.spanId;\n                        if (object.traceState != null)\n                            message.traceState = String(object.traceState);\n                        if (object.parentSpanId != null)\n                            if (typeof object.parentSpanId === \"string\")\n                                $util.base64.decode(object.parentSpanId, message.parentSpanId = $util.newBuffer($util.base64.length(object.parentSpanId)), 0);\n                            else if (object.parentSpanId.length >= 0)\n                                message.parentSpanId = object.parentSpanId;\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        switch (object.kind) {\n                        default:\n                            if (typeof object.kind === \"number\") {\n                                message.kind = object.kind;\n                                break;\n                            }\n                            break;\n                        case \"SPAN_KIND_UNSPECIFIED\":\n                        case 0:\n                            message.kind = 0;\n                            break;\n                        case \"SPAN_KIND_INTERNAL\":\n                        case 1:\n                            message.kind = 1;\n                            break;\n                        case \"SPAN_KIND_SERVER\":\n                        case 2:\n                            message.kind = 2;\n                            break;\n                        case \"SPAN_KIND_CLIENT\":\n                        case 3:\n                            message.kind = 3;\n                            break;\n                        case \"SPAN_KIND_PRODUCER\":\n                        case 4:\n                            message.kind = 4;\n                            break;\n                        case \"SPAN_KIND_CONSUMER\":\n                        case 5:\n                            message.kind = 5;\n                            break;\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.endTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.endTimeUnixNano = $util.Long.fromValue(object.endTimeUnixNano)).unsigned = false;\n                            else if (typeof object.endTimeUnixNano === \"string\")\n                                message.endTimeUnixNano = parseInt(object.endTimeUnixNano, 10);\n                            else if (typeof object.endTimeUnixNano === \"number\")\n                                message.endTimeUnixNano = object.endTimeUnixNano;\n                            else if (typeof object.endTimeUnixNano === \"object\")\n                                message.endTimeUnixNano = new $util.LongBits(object.endTimeUnixNano.low >>> 0, object.endTimeUnixNano.high >>> 0).toNumber();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        if (object.events) {\n                            if (!Array.isArray(object.events))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.events: array expected\");\n                            message.events = [];\n                            for (var i = 0; i < object.events.length; ++i) {\n                                if (typeof object.events[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.events: object expected\");\n                                message.events[i] = $root.opentelemetry.proto.trace.v1.Span.Event.fromObject(object.events[i]);\n                            }\n                        }\n                        if (object.droppedEventsCount != null)\n                            message.droppedEventsCount = object.droppedEventsCount >>> 0;\n                        if (object.links) {\n                            if (!Array.isArray(object.links))\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.links: array expected\");\n                            message.links = [];\n                            for (var i = 0; i < object.links.length; ++i) {\n                                if (typeof object.links[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.links: object expected\");\n                                message.links[i] = $root.opentelemetry.proto.trace.v1.Span.Link.fromObject(object.links[i]);\n                            }\n                        }\n                        if (object.droppedLinksCount != null)\n                            message.droppedLinksCount = object.droppedLinksCount >>> 0;\n                        if (object.status != null) {\n                            if (typeof object.status !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.trace.v1.Span.status: object expected\");\n                            message.status = $root.opentelemetry.proto.trace.v1.Status.fromObject(object.status);\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Span message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.Span} message Span\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Span.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.attributes = [];\n                            object.events = [];\n                            object.links = [];\n                        }\n                        if (options.defaults) {\n                            if (options.bytes === String)\n                                object.traceId = \"\";\n                            else {\n                                object.traceId = [];\n                                if (options.bytes !== Array)\n                                    object.traceId = $util.newBuffer(object.traceId);\n                            }\n                            if (options.bytes === String)\n                                object.spanId = \"\";\n                            else {\n                                object.spanId = [];\n                                if (options.bytes !== Array)\n                                    object.spanId = $util.newBuffer(object.spanId);\n                            }\n                            object.traceState = \"\";\n                            if (options.bytes === String)\n                                object.parentSpanId = \"\";\n                            else {\n                                object.parentSpanId = [];\n                                if (options.bytes !== Array)\n                                    object.parentSpanId = $util.newBuffer(object.parentSpanId);\n                            }\n                            object.name = \"\";\n                            object.kind = options.enums === String ? \"SPAN_KIND_UNSPECIFIED\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.endTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.endTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            object.droppedAttributesCount = 0;\n                            object.droppedEventsCount = 0;\n                            object.droppedLinksCount = 0;\n                            object.status = null;\n                        }\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                        if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                            object.traceState = message.traceState;\n                        if (message.parentSpanId != null && message.hasOwnProperty(\"parentSpanId\"))\n                            object.parentSpanId = options.bytes === String ? $util.base64.encode(message.parentSpanId, 0, message.parentSpanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentSpanId) : message.parentSpanId;\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.kind != null && message.hasOwnProperty(\"kind\"))\n                            object.kind = options.enums === String ? $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] === undefined ? message.kind : $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] : message.kind;\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.endTimeUnixNano != null && message.hasOwnProperty(\"endTimeUnixNano\"))\n                            if (typeof message.endTimeUnixNano === \"number\")\n                                object.endTimeUnixNano = options.longs === String ? String(message.endTimeUnixNano) : message.endTimeUnixNano;\n                            else\n                                object.endTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.endTimeUnixNano.low >>> 0, message.endTimeUnixNano.high >>> 0).toNumber() : message.endTimeUnixNano;\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        if (message.events && message.events.length) {\n                            object.events = [];\n                            for (var j = 0; j < message.events.length; ++j)\n                                object.events[j] = $root.opentelemetry.proto.trace.v1.Span.Event.toObject(message.events[j], options);\n                        }\n                        if (message.droppedEventsCount != null && message.hasOwnProperty(\"droppedEventsCount\"))\n                            object.droppedEventsCount = message.droppedEventsCount;\n                        if (message.links && message.links.length) {\n                            object.links = [];\n                            for (var j = 0; j < message.links.length; ++j)\n                                object.links[j] = $root.opentelemetry.proto.trace.v1.Span.Link.toObject(message.links[j], options);\n                        }\n                        if (message.droppedLinksCount != null && message.hasOwnProperty(\"droppedLinksCount\"))\n                            object.droppedLinksCount = message.droppedLinksCount;\n                        if (message.status != null && message.hasOwnProperty(\"status\"))\n                            object.status = $root.opentelemetry.proto.trace.v1.Status.toObject(message.status, options);\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Span to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Span.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Span\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.Span\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Span.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Span\";\n                    };\n\n                    /**\n                     * SpanKind enum.\n                     * @name opentelemetry.proto.trace.v1.Span.SpanKind\n                     * @enum {number}\n                     * @property {number} SPAN_KIND_UNSPECIFIED=0 SPAN_KIND_UNSPECIFIED value\n                     * @property {number} SPAN_KIND_INTERNAL=1 SPAN_KIND_INTERNAL value\n                     * @property {number} SPAN_KIND_SERVER=2 SPAN_KIND_SERVER value\n                     * @property {number} SPAN_KIND_CLIENT=3 SPAN_KIND_CLIENT value\n                     * @property {number} SPAN_KIND_PRODUCER=4 SPAN_KIND_PRODUCER value\n                     * @property {number} SPAN_KIND_CONSUMER=5 SPAN_KIND_CONSUMER value\n                     */\n                    Span.SpanKind = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"SPAN_KIND_UNSPECIFIED\"] = 0;\n                        values[valuesById[1] = \"SPAN_KIND_INTERNAL\"] = 1;\n                        values[valuesById[2] = \"SPAN_KIND_SERVER\"] = 2;\n                        values[valuesById[3] = \"SPAN_KIND_CLIENT\"] = 3;\n                        values[valuesById[4] = \"SPAN_KIND_PRODUCER\"] = 4;\n                        values[valuesById[5] = \"SPAN_KIND_CONSUMER\"] = 5;\n                        return values;\n                    })();\n\n                    Span.Event = (function() {\n\n                        /**\n                         * Properties of an Event.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @interface IEvent\n                         * @property {number|Long|null} [timeUnixNano] Event timeUnixNano\n                         * @property {string|null} [name] Event name\n                         * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Event attributes\n                         * @property {number|null} [droppedAttributesCount] Event droppedAttributesCount\n                         */\n\n                        /**\n                         * Constructs a new Event.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @classdesc Represents an Event.\n                         * @implements IEvent\n                         * @constructor\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent=} [properties] Properties to set\n                         */\n                        function Event(properties) {\n                            this.attributes = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * Event timeUnixNano.\n                         * @member {number|Long|null|undefined} timeUnixNano\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.timeUnixNano = null;\n\n                        /**\n                         * Event name.\n                         * @member {string|null|undefined} name\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.name = null;\n\n                        /**\n                         * Event attributes.\n                         * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.attributes = $util.emptyArray;\n\n                        /**\n                         * Event droppedAttributesCount.\n                         * @member {number|null|undefined} droppedAttributesCount\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         */\n                        Event.prototype.droppedAttributesCount = null;\n\n                        /**\n                         * Creates a new Event instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event instance\n                         */\n                        Event.create = function create(properties) {\n                            return new Event(properties);\n                        };\n\n                        /**\n                         * Encodes the specified Event message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Event.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent} message Event message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Event.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                                writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.timeUnixNano);\n                            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n                            if (message.attributes != null && message.attributes.length)\n                                for (var i = 0; i < message.attributes.length; ++i)\n                                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                            if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.droppedAttributesCount);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified Event message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Event.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.IEvent} message Event message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Event.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an Event message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Event.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Event();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.timeUnixNano = reader.fixed64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.name = reader.string();\n                                        break;\n                                    }\n                                case 3: {\n                                        if (!(message.attributes && message.attributes.length))\n                                            message.attributes = [];\n                                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                case 4: {\n                                        message.droppedAttributesCount = reader.uint32();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an Event message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Event.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an Event message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        Event.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                    return \"timeUnixNano: integer|Long expected\";\n                            if (message.name != null && message.hasOwnProperty(\"name\"))\n                                if (!$util.isString(message.name))\n                                    return \"name: string expected\";\n                            if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                                if (!Array.isArray(message.attributes))\n                                    return \"attributes: array expected\";\n                                for (var i = 0; i < message.attributes.length; ++i) {\n                                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                    if (error)\n                                        return \"attributes.\" + error;\n                                }\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                if (!$util.isInteger(message.droppedAttributesCount))\n                                    return \"droppedAttributesCount: integer expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an Event message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event\n                         */\n                        Event.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Event)\n                                return object;\n                            var message = new $root.opentelemetry.proto.trace.v1.Span.Event();\n                            if (object.timeUnixNano != null)\n                                if ($util.Long)\n                                    (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                                else if (typeof object.timeUnixNano === \"string\")\n                                    message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                                else if (typeof object.timeUnixNano === \"number\")\n                                    message.timeUnixNano = object.timeUnixNano;\n                                else if (typeof object.timeUnixNano === \"object\")\n                                    message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                            if (object.name != null)\n                                message.name = String(object.name);\n                            if (object.attributes) {\n                                if (!Array.isArray(object.attributes))\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.Event.attributes: array expected\");\n                                message.attributes = [];\n                                for (var i = 0; i < object.attributes.length; ++i) {\n                                    if (typeof object.attributes[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.trace.v1.Span.Event.attributes: object expected\");\n                                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                                }\n                            }\n                            if (object.droppedAttributesCount != null)\n                                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an Event message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.Event} message Event\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        Event.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.attributes = [];\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                                object.name = \"\";\n                                object.droppedAttributesCount = 0;\n                            }\n                            if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                                if (typeof message.timeUnixNano === \"number\")\n                                    object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                                else\n                                    object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                            if (message.name != null && message.hasOwnProperty(\"name\"))\n                                object.name = message.name;\n                            if (message.attributes && message.attributes.length) {\n                                object.attributes = [];\n                                for (var j = 0; j < message.attributes.length; ++j)\n                                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                object.droppedAttributesCount = message.droppedAttributesCount;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this Event to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        Event.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for Event\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.trace.v1.Span.Event\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        Event.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Span.Event\";\n                        };\n\n                        return Event;\n                    })();\n\n                    Span.Link = (function() {\n\n                        /**\n                         * Properties of a Link.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @interface ILink\n                         * @property {Uint8Array|null} [traceId] Link traceId\n                         * @property {Uint8Array|null} [spanId] Link spanId\n                         * @property {string|null} [traceState] Link traceState\n                         * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Link attributes\n                         * @property {number|null} [droppedAttributesCount] Link droppedAttributesCount\n                         */\n\n                        /**\n                         * Constructs a new Link.\n                         * @memberof opentelemetry.proto.trace.v1.Span\n                         * @classdesc Represents a Link.\n                         * @implements ILink\n                         * @constructor\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink=} [properties] Properties to set\n                         */\n                        function Link(properties) {\n                            this.attributes = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * Link traceId.\n                         * @member {Uint8Array|null|undefined} traceId\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.traceId = null;\n\n                        /**\n                         * Link spanId.\n                         * @member {Uint8Array|null|undefined} spanId\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.spanId = null;\n\n                        /**\n                         * Link traceState.\n                         * @member {string|null|undefined} traceState\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.traceState = null;\n\n                        /**\n                         * Link attributes.\n                         * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.attributes = $util.emptyArray;\n\n                        /**\n                         * Link droppedAttributesCount.\n                         * @member {number|null|undefined} droppedAttributesCount\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         */\n                        Link.prototype.droppedAttributesCount = null;\n\n                        /**\n                         * Creates a new Link instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link instance\n                         */\n                        Link.create = function create(properties) {\n                            return new Link(properties);\n                        };\n\n                        /**\n                         * Encodes the specified Link message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Link.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink} message Link message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Link.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.traceId);\n                            if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.spanId);\n                            if (message.traceState != null && Object.hasOwnProperty.call(message, \"traceState\"))\n                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.traceState);\n                            if (message.attributes != null && message.attributes.length)\n                                for (var i = 0; i < message.attributes.length; ++i)\n                                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                            if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.droppedAttributesCount);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified Link message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Link.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.ILink} message Link message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Link.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes a Link message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Link.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Link();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.traceId = reader.bytes();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.spanId = reader.bytes();\n                                        break;\n                                    }\n                                case 3: {\n                                        message.traceState = reader.string();\n                                        break;\n                                    }\n                                case 4: {\n                                        if (!(message.attributes && message.attributes.length))\n                                            message.attributes = [];\n                                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                case 5: {\n                                        message.droppedAttributesCount = reader.uint32();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes a Link message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Link.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies a Link message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        Link.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                                if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                    return \"traceId: buffer expected\";\n                            if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                                if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                    return \"spanId: buffer expected\";\n                            if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                                if (!$util.isString(message.traceState))\n                                    return \"traceState: string expected\";\n                            if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                                if (!Array.isArray(message.attributes))\n                                    return \"attributes: array expected\";\n                                for (var i = 0; i < message.attributes.length; ++i) {\n                                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                    if (error)\n                                        return \"attributes.\" + error;\n                                }\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                if (!$util.isInteger(message.droppedAttributesCount))\n                                    return \"droppedAttributesCount: integer expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates a Link message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link\n                         */\n                        Link.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Link)\n                                return object;\n                            var message = new $root.opentelemetry.proto.trace.v1.Span.Link();\n                            if (object.traceId != null)\n                                if (typeof object.traceId === \"string\")\n                                    $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                                else if (object.traceId.length >= 0)\n                                    message.traceId = object.traceId;\n                            if (object.spanId != null)\n                                if (typeof object.spanId === \"string\")\n                                    $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                                else if (object.spanId.length >= 0)\n                                    message.spanId = object.spanId;\n                            if (object.traceState != null)\n                                message.traceState = String(object.traceState);\n                            if (object.attributes) {\n                                if (!Array.isArray(object.attributes))\n                                    throw TypeError(\".opentelemetry.proto.trace.v1.Span.Link.attributes: array expected\");\n                                message.attributes = [];\n                                for (var i = 0; i < object.attributes.length; ++i) {\n                                    if (typeof object.attributes[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.trace.v1.Span.Link.attributes: object expected\");\n                                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                                }\n                            }\n                            if (object.droppedAttributesCount != null)\n                                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from a Link message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {opentelemetry.proto.trace.v1.Span.Link} message Link\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        Link.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.attributes = [];\n                            if (options.defaults) {\n                                if (options.bytes === String)\n                                    object.traceId = \"\";\n                                else {\n                                    object.traceId = [];\n                                    if (options.bytes !== Array)\n                                        object.traceId = $util.newBuffer(object.traceId);\n                                }\n                                if (options.bytes === String)\n                                    object.spanId = \"\";\n                                else {\n                                    object.spanId = [];\n                                    if (options.bytes !== Array)\n                                        object.spanId = $util.newBuffer(object.spanId);\n                                }\n                                object.traceState = \"\";\n                                object.droppedAttributesCount = 0;\n                            }\n                            if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                                object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                            if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                                object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                            if (message.traceState != null && message.hasOwnProperty(\"traceState\"))\n                                object.traceState = message.traceState;\n                            if (message.attributes && message.attributes.length) {\n                                object.attributes = [];\n                                for (var j = 0; j < message.attributes.length; ++j)\n                                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                            }\n                            if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                                object.droppedAttributesCount = message.droppedAttributesCount;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this Link to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        Link.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for Link\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.trace.v1.Span.Link\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        Link.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Span.Link\";\n                        };\n\n                        return Link;\n                    })();\n\n                    return Span;\n                })();\n\n                v1.Status = (function() {\n\n                    /**\n                     * Properties of a Status.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @interface IStatus\n                     * @property {string|null} [message] Status message\n                     * @property {opentelemetry.proto.trace.v1.Status.StatusCode|null} [code] Status code\n                     */\n\n                    /**\n                     * Constructs a new Status.\n                     * @memberof opentelemetry.proto.trace.v1\n                     * @classdesc Represents a Status.\n                     * @implements IStatus\n                     * @constructor\n                     * @param {opentelemetry.proto.trace.v1.IStatus=} [properties] Properties to set\n                     */\n                    function Status(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Status message.\n                     * @member {string|null|undefined} message\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @instance\n                     */\n                    Status.prototype.message = null;\n\n                    /**\n                     * Status code.\n                     * @member {opentelemetry.proto.trace.v1.Status.StatusCode|null|undefined} code\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @instance\n                     */\n                    Status.prototype.code = null;\n\n                    /**\n                     * Creates a new Status instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IStatus=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status instance\n                     */\n                    Status.create = function create(properties) {\n                        return new Status(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Status message. Does not implicitly {@link opentelemetry.proto.trace.v1.Status.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IStatus} message Status message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Status.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);\n                        if (message.code != null && Object.hasOwnProperty.call(message, \"code\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.code);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Status message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Status.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.IStatus} message Status message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Status.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Status message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Status.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Status();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 2: {\n                                    message.message = reader.string();\n                                    break;\n                                }\n                            case 3: {\n                                    message.code = reader.int32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Status message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Status.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Status message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Status.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.message != null && message.hasOwnProperty(\"message\"))\n                            if (!$util.isString(message.message))\n                                return \"message: string expected\";\n                        if (message.code != null && message.hasOwnProperty(\"code\"))\n                            switch (message.code) {\n                            default:\n                                return \"code: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Status message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.trace.v1.Status} Status\n                     */\n                    Status.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.trace.v1.Status)\n                            return object;\n                        var message = new $root.opentelemetry.proto.trace.v1.Status();\n                        if (object.message != null)\n                            message.message = String(object.message);\n                        switch (object.code) {\n                        default:\n                            if (typeof object.code === \"number\") {\n                                message.code = object.code;\n                                break;\n                            }\n                            break;\n                        case \"STATUS_CODE_UNSET\":\n                        case 0:\n                            message.code = 0;\n                            break;\n                        case \"STATUS_CODE_OK\":\n                        case 1:\n                            message.code = 1;\n                            break;\n                        case \"STATUS_CODE_ERROR\":\n                        case 2:\n                            message.code = 2;\n                            break;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Status message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {opentelemetry.proto.trace.v1.Status} message Status\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Status.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.defaults) {\n                            object.message = \"\";\n                            object.code = options.enums === String ? \"STATUS_CODE_UNSET\" : 0;\n                        }\n                        if (message.message != null && message.hasOwnProperty(\"message\"))\n                            object.message = message.message;\n                        if (message.code != null && message.hasOwnProperty(\"code\"))\n                            object.code = options.enums === String ? $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] === undefined ? message.code : $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] : message.code;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Status to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Status.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Status\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.trace.v1.Status\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Status.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.trace.v1.Status\";\n                    };\n\n                    /**\n                     * StatusCode enum.\n                     * @name opentelemetry.proto.trace.v1.Status.StatusCode\n                     * @enum {number}\n                     * @property {number} STATUS_CODE_UNSET=0 STATUS_CODE_UNSET value\n                     * @property {number} STATUS_CODE_OK=1 STATUS_CODE_OK value\n                     * @property {number} STATUS_CODE_ERROR=2 STATUS_CODE_ERROR value\n                     */\n                    Status.StatusCode = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"STATUS_CODE_UNSET\"] = 0;\n                        values[valuesById[1] = \"STATUS_CODE_OK\"] = 1;\n                        values[valuesById[2] = \"STATUS_CODE_ERROR\"] = 2;\n                        return values;\n                    })();\n\n                    return Status;\n                })();\n\n                return v1;\n            })();\n\n            return trace;\n        })();\n\n        proto.collector = (function() {\n\n            /**\n             * Namespace collector.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var collector = {};\n\n            collector.trace = (function() {\n\n                /**\n                 * Namespace trace.\n                 * @memberof opentelemetry.proto.collector\n                 * @namespace\n                 */\n                var trace = {};\n\n                trace.v1 = (function() {\n\n                    /**\n                     * Namespace v1.\n                     * @memberof opentelemetry.proto.collector.trace\n                     * @namespace\n                     */\n                    var v1 = {};\n\n                    v1.TraceService = (function() {\n\n                        /**\n                         * Constructs a new TraceService service.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents a TraceService\n                         * @extends $protobuf.rpc.Service\n                         * @constructor\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         */\n                        function TraceService(rpcImpl, requestDelimited, responseDelimited) {\n                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n                        }\n\n                        (TraceService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TraceService;\n\n                        /**\n                         * Creates new TraceService service using the specified rpc implementation.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @static\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         * @returns {TraceService} RPC service. Useful where requests and/or responses are streamed.\n                         */\n                        TraceService.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n                            return new this(rpcImpl, requestDelimited, responseDelimited);\n                        };\n\n                        /**\n                         * Callback as used by {@link opentelemetry.proto.collector.trace.v1.TraceService#export_}.\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @typedef ExportCallback\n                         * @type {function}\n                         * @param {Error|null} error Error, if any\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} [response] ExportTraceServiceResponse\n                         */\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} request ExportTraceServiceRequest message or plain object\n                         * @param {opentelemetry.proto.collector.trace.v1.TraceService.ExportCallback} callback Node-style callback called with the error, if any, and ExportTraceServiceResponse\n                         * @returns {undefined}\n                         * @variation 1\n                         */\n                        Object.defineProperty(TraceService.prototype[\"export\"] = function export_(request, callback) {\n                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse, request, callback);\n                        }, \"name\", { value: \"Export\" });\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} request ExportTraceServiceRequest message or plain object\n                         * @returns {Promise<opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse>} Promise\n                         * @variation 2\n                         */\n\n                        return TraceService;\n                    })();\n\n                    v1.ExportTraceServiceRequest = (function() {\n\n                        /**\n                         * Properties of an ExportTraceServiceRequest.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @interface IExportTraceServiceRequest\n                         * @property {Array.<opentelemetry.proto.trace.v1.IResourceSpans>|null} [resourceSpans] ExportTraceServiceRequest resourceSpans\n                         */\n\n                        /**\n                         * Constructs a new ExportTraceServiceRequest.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents an ExportTraceServiceRequest.\n                         * @implements IExportTraceServiceRequest\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest=} [properties] Properties to set\n                         */\n                        function ExportTraceServiceRequest(properties) {\n                            this.resourceSpans = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportTraceServiceRequest resourceSpans.\n                         * @member {Array.<opentelemetry.proto.trace.v1.IResourceSpans>} resourceSpans\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @instance\n                         */\n                        ExportTraceServiceRequest.prototype.resourceSpans = $util.emptyArray;\n\n                        /**\n                         * Creates a new ExportTraceServiceRequest instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest instance\n                         */\n                        ExportTraceServiceRequest.create = function create(properties) {\n                            return new ExportTraceServiceRequest(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} message ExportTraceServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceRequest.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.resourceSpans != null && message.resourceSpans.length)\n                                for (var i = 0; i < message.resourceSpans.length; ++i)\n                                    $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} message ExportTraceServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceRequest message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceRequest.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        if (!(message.resourceSpans && message.resourceSpans.length))\n                                            message.resourceSpans = [];\n                                        message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceRequest message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceRequest.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportTraceServiceRequest message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportTraceServiceRequest.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.resourceSpans != null && message.hasOwnProperty(\"resourceSpans\")) {\n                                if (!Array.isArray(message.resourceSpans))\n                                    return \"resourceSpans: array expected\";\n                                for (var i = 0; i < message.resourceSpans.length; ++i) {\n                                    var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);\n                                    if (error)\n                                        return \"resourceSpans.\" + error;\n                                }\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportTraceServiceRequest message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest\n                         */\n                        ExportTraceServiceRequest.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();\n                            if (object.resourceSpans) {\n                                if (!Array.isArray(object.resourceSpans))\n                                    throw TypeError(\".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: array expected\");\n                                message.resourceSpans = [];\n                                for (var i = 0; i < object.resourceSpans.length; ++i) {\n                                    if (typeof object.resourceSpans[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: object expected\");\n                                    message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportTraceServiceRequest message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} message ExportTraceServiceRequest\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportTraceServiceRequest.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.resourceSpans = [];\n                            if (message.resourceSpans && message.resourceSpans.length) {\n                                object.resourceSpans = [];\n                                for (var j = 0; j < message.resourceSpans.length; ++j)\n                                    object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportTraceServiceRequest to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportTraceServiceRequest.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportTraceServiceRequest\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportTraceServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest\";\n                        };\n\n                        return ExportTraceServiceRequest;\n                    })();\n\n                    v1.ExportTraceServiceResponse = (function() {\n\n                        /**\n                         * Properties of an ExportTraceServiceResponse.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @interface IExportTraceServiceResponse\n                         * @property {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess|null} [partialSuccess] ExportTraceServiceResponse partialSuccess\n                         */\n\n                        /**\n                         * Constructs a new ExportTraceServiceResponse.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents an ExportTraceServiceResponse.\n                         * @implements IExportTraceServiceResponse\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse=} [properties] Properties to set\n                         */\n                        function ExportTraceServiceResponse(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportTraceServiceResponse partialSuccess.\n                         * @member {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess|null|undefined} partialSuccess\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @instance\n                         */\n                        ExportTraceServiceResponse.prototype.partialSuccess = null;\n\n                        /**\n                         * Creates a new ExportTraceServiceResponse instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse instance\n                         */\n                        ExportTraceServiceResponse.create = function create(properties) {\n                            return new ExportTraceServiceResponse(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse} message ExportTraceServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceResponse.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, \"partialSuccess\"))\n                                $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportTraceServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse} message ExportTraceServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTraceServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceResponse message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceResponse.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.decode(reader, reader.uint32());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportTraceServiceResponse message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTraceServiceResponse.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportTraceServiceResponse message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportTraceServiceResponse.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\")) {\n                                var error = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify(message.partialSuccess);\n                                if (error)\n                                    return \"partialSuccess.\" + error;\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportTraceServiceResponse message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse\n                         */\n                        ExportTraceServiceResponse.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();\n                            if (object.partialSuccess != null) {\n                                if (typeof object.partialSuccess !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.partialSuccess: object expected\");\n                                message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.fromObject(object.partialSuccess);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportTraceServiceResponse message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} message ExportTraceServiceResponse\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportTraceServiceResponse.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults)\n                                object.partialSuccess = null;\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\"))\n                                object.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.toObject(message.partialSuccess, options);\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportTraceServiceResponse to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportTraceServiceResponse.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportTraceServiceResponse\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportTraceServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse\";\n                        };\n\n                        return ExportTraceServiceResponse;\n                    })();\n\n                    v1.ExportTracePartialSuccess = (function() {\n\n                        /**\n                         * Properties of an ExportTracePartialSuccess.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @interface IExportTracePartialSuccess\n                         * @property {number|Long|null} [rejectedSpans] ExportTracePartialSuccess rejectedSpans\n                         * @property {string|null} [errorMessage] ExportTracePartialSuccess errorMessage\n                         */\n\n                        /**\n                         * Constructs a new ExportTracePartialSuccess.\n                         * @memberof opentelemetry.proto.collector.trace.v1\n                         * @classdesc Represents an ExportTracePartialSuccess.\n                         * @implements IExportTracePartialSuccess\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess=} [properties] Properties to set\n                         */\n                        function ExportTracePartialSuccess(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportTracePartialSuccess rejectedSpans.\n                         * @member {number|Long|null|undefined} rejectedSpans\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @instance\n                         */\n                        ExportTracePartialSuccess.prototype.rejectedSpans = null;\n\n                        /**\n                         * ExportTracePartialSuccess errorMessage.\n                         * @member {string|null|undefined} errorMessage\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @instance\n                         */\n                        ExportTracePartialSuccess.prototype.errorMessage = null;\n\n                        /**\n                         * Creates a new ExportTracePartialSuccess instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess instance\n                         */\n                        ExportTracePartialSuccess.create = function create(properties) {\n                            return new ExportTracePartialSuccess(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportTracePartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess} message ExportTracePartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTracePartialSuccess.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.rejectedSpans != null && Object.hasOwnProperty.call(message, \"rejectedSpans\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rejectedSpans);\n                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, \"errorMessage\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportTracePartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess} message ExportTracePartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportTracePartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportTracePartialSuccess message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTracePartialSuccess.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.rejectedSpans = reader.int64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.errorMessage = reader.string();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportTracePartialSuccess message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportTracePartialSuccess.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportTracePartialSuccess message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportTracePartialSuccess.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.rejectedSpans != null && message.hasOwnProperty(\"rejectedSpans\"))\n                                if (!$util.isInteger(message.rejectedSpans) && !(message.rejectedSpans && $util.isInteger(message.rejectedSpans.low) && $util.isInteger(message.rejectedSpans.high)))\n                                    return \"rejectedSpans: integer|Long expected\";\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                if (!$util.isString(message.errorMessage))\n                                    return \"errorMessage: string expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportTracePartialSuccess message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess\n                         */\n                        ExportTracePartialSuccess.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();\n                            if (object.rejectedSpans != null)\n                                if ($util.Long)\n                                    (message.rejectedSpans = $util.Long.fromValue(object.rejectedSpans)).unsigned = false;\n                                else if (typeof object.rejectedSpans === \"string\")\n                                    message.rejectedSpans = parseInt(object.rejectedSpans, 10);\n                                else if (typeof object.rejectedSpans === \"number\")\n                                    message.rejectedSpans = object.rejectedSpans;\n                                else if (typeof object.rejectedSpans === \"object\")\n                                    message.rejectedSpans = new $util.LongBits(object.rejectedSpans.low >>> 0, object.rejectedSpans.high >>> 0).toNumber();\n                            if (object.errorMessage != null)\n                                message.errorMessage = String(object.errorMessage);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportTracePartialSuccess message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} message ExportTracePartialSuccess\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportTracePartialSuccess.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.rejectedSpans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.rejectedSpans = options.longs === String ? \"0\" : 0;\n                                object.errorMessage = \"\";\n                            }\n                            if (message.rejectedSpans != null && message.hasOwnProperty(\"rejectedSpans\"))\n                                if (typeof message.rejectedSpans === \"number\")\n                                    object.rejectedSpans = options.longs === String ? String(message.rejectedSpans) : message.rejectedSpans;\n                                else\n                                    object.rejectedSpans = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedSpans) : options.longs === Number ? new $util.LongBits(message.rejectedSpans.low >>> 0, message.rejectedSpans.high >>> 0).toNumber() : message.rejectedSpans;\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                object.errorMessage = message.errorMessage;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportTracePartialSuccess to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportTracePartialSuccess.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportTracePartialSuccess\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportTracePartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess\";\n                        };\n\n                        return ExportTracePartialSuccess;\n                    })();\n\n                    return v1;\n                })();\n\n                return trace;\n            })();\n\n            collector.metrics = (function() {\n\n                /**\n                 * Namespace metrics.\n                 * @memberof opentelemetry.proto.collector\n                 * @namespace\n                 */\n                var metrics = {};\n\n                metrics.v1 = (function() {\n\n                    /**\n                     * Namespace v1.\n                     * @memberof opentelemetry.proto.collector.metrics\n                     * @namespace\n                     */\n                    var v1 = {};\n\n                    v1.MetricsService = (function() {\n\n                        /**\n                         * Constructs a new MetricsService service.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents a MetricsService\n                         * @extends $protobuf.rpc.Service\n                         * @constructor\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         */\n                        function MetricsService(rpcImpl, requestDelimited, responseDelimited) {\n                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n                        }\n\n                        (MetricsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetricsService;\n\n                        /**\n                         * Creates new MetricsService service using the specified rpc implementation.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @static\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         * @returns {MetricsService} RPC service. Useful where requests and/or responses are streamed.\n                         */\n                        MetricsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n                            return new this(rpcImpl, requestDelimited, responseDelimited);\n                        };\n\n                        /**\n                         * Callback as used by {@link opentelemetry.proto.collector.metrics.v1.MetricsService#export_}.\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @typedef ExportCallback\n                         * @type {function}\n                         * @param {Error|null} error Error, if any\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} [response] ExportMetricsServiceResponse\n                         */\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} request ExportMetricsServiceRequest message or plain object\n                         * @param {opentelemetry.proto.collector.metrics.v1.MetricsService.ExportCallback} callback Node-style callback called with the error, if any, and ExportMetricsServiceResponse\n                         * @returns {undefined}\n                         * @variation 1\n                         */\n                        Object.defineProperty(MetricsService.prototype[\"export\"] = function export_(request, callback) {\n                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse, request, callback);\n                        }, \"name\", { value: \"Export\" });\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} request ExportMetricsServiceRequest message or plain object\n                         * @returns {Promise<opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse>} Promise\n                         * @variation 2\n                         */\n\n                        return MetricsService;\n                    })();\n\n                    v1.ExportMetricsServiceRequest = (function() {\n\n                        /**\n                         * Properties of an ExportMetricsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @interface IExportMetricsServiceRequest\n                         * @property {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>|null} [resourceMetrics] ExportMetricsServiceRequest resourceMetrics\n                         */\n\n                        /**\n                         * Constructs a new ExportMetricsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents an ExportMetricsServiceRequest.\n                         * @implements IExportMetricsServiceRequest\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest=} [properties] Properties to set\n                         */\n                        function ExportMetricsServiceRequest(properties) {\n                            this.resourceMetrics = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportMetricsServiceRequest resourceMetrics.\n                         * @member {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>} resourceMetrics\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @instance\n                         */\n                        ExportMetricsServiceRequest.prototype.resourceMetrics = $util.emptyArray;\n\n                        /**\n                         * Creates a new ExportMetricsServiceRequest instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest instance\n                         */\n                        ExportMetricsServiceRequest.create = function create(properties) {\n                            return new ExportMetricsServiceRequest(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} message ExportMetricsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceRequest.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.resourceMetrics != null && message.resourceMetrics.length)\n                                for (var i = 0; i < message.resourceMetrics.length; ++i)\n                                    $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} message ExportMetricsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceRequest message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceRequest.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        if (!(message.resourceMetrics && message.resourceMetrics.length))\n                                            message.resourceMetrics = [];\n                                        message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceRequest message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceRequest.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportMetricsServiceRequest message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportMetricsServiceRequest.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.resourceMetrics != null && message.hasOwnProperty(\"resourceMetrics\")) {\n                                if (!Array.isArray(message.resourceMetrics))\n                                    return \"resourceMetrics: array expected\";\n                                for (var i = 0; i < message.resourceMetrics.length; ++i) {\n                                    var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);\n                                    if (error)\n                                        return \"resourceMetrics.\" + error;\n                                }\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportMetricsServiceRequest message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest\n                         */\n                        ExportMetricsServiceRequest.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();\n                            if (object.resourceMetrics) {\n                                if (!Array.isArray(object.resourceMetrics))\n                                    throw TypeError(\".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: array expected\");\n                                message.resourceMetrics = [];\n                                for (var i = 0; i < object.resourceMetrics.length; ++i) {\n                                    if (typeof object.resourceMetrics[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: object expected\");\n                                    message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportMetricsServiceRequest message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} message ExportMetricsServiceRequest\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportMetricsServiceRequest.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.resourceMetrics = [];\n                            if (message.resourceMetrics && message.resourceMetrics.length) {\n                                object.resourceMetrics = [];\n                                for (var j = 0; j < message.resourceMetrics.length; ++j)\n                                    object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportMetricsServiceRequest to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportMetricsServiceRequest.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportMetricsServiceRequest\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportMetricsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest\";\n                        };\n\n                        return ExportMetricsServiceRequest;\n                    })();\n\n                    v1.ExportMetricsServiceResponse = (function() {\n\n                        /**\n                         * Properties of an ExportMetricsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @interface IExportMetricsServiceResponse\n                         * @property {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess|null} [partialSuccess] ExportMetricsServiceResponse partialSuccess\n                         */\n\n                        /**\n                         * Constructs a new ExportMetricsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents an ExportMetricsServiceResponse.\n                         * @implements IExportMetricsServiceResponse\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse=} [properties] Properties to set\n                         */\n                        function ExportMetricsServiceResponse(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportMetricsServiceResponse partialSuccess.\n                         * @member {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess|null|undefined} partialSuccess\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @instance\n                         */\n                        ExportMetricsServiceResponse.prototype.partialSuccess = null;\n\n                        /**\n                         * Creates a new ExportMetricsServiceResponse instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse instance\n                         */\n                        ExportMetricsServiceResponse.create = function create(properties) {\n                            return new ExportMetricsServiceResponse(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse} message ExportMetricsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceResponse.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, \"partialSuccess\"))\n                                $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse} message ExportMetricsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceResponse message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceResponse.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.decode(reader, reader.uint32());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsServiceResponse message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsServiceResponse.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportMetricsServiceResponse message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportMetricsServiceResponse.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\")) {\n                                var error = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify(message.partialSuccess);\n                                if (error)\n                                    return \"partialSuccess.\" + error;\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportMetricsServiceResponse message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse\n                         */\n                        ExportMetricsServiceResponse.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();\n                            if (object.partialSuccess != null) {\n                                if (typeof object.partialSuccess !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.partialSuccess: object expected\");\n                                message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.fromObject(object.partialSuccess);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportMetricsServiceResponse message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} message ExportMetricsServiceResponse\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportMetricsServiceResponse.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults)\n                                object.partialSuccess = null;\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\"))\n                                object.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.toObject(message.partialSuccess, options);\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportMetricsServiceResponse to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportMetricsServiceResponse.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportMetricsServiceResponse\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportMetricsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse\";\n                        };\n\n                        return ExportMetricsServiceResponse;\n                    })();\n\n                    v1.ExportMetricsPartialSuccess = (function() {\n\n                        /**\n                         * Properties of an ExportMetricsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @interface IExportMetricsPartialSuccess\n                         * @property {number|Long|null} [rejectedDataPoints] ExportMetricsPartialSuccess rejectedDataPoints\n                         * @property {string|null} [errorMessage] ExportMetricsPartialSuccess errorMessage\n                         */\n\n                        /**\n                         * Constructs a new ExportMetricsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.metrics.v1\n                         * @classdesc Represents an ExportMetricsPartialSuccess.\n                         * @implements IExportMetricsPartialSuccess\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess=} [properties] Properties to set\n                         */\n                        function ExportMetricsPartialSuccess(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportMetricsPartialSuccess rejectedDataPoints.\n                         * @member {number|Long|null|undefined} rejectedDataPoints\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @instance\n                         */\n                        ExportMetricsPartialSuccess.prototype.rejectedDataPoints = null;\n\n                        /**\n                         * ExportMetricsPartialSuccess errorMessage.\n                         * @member {string|null|undefined} errorMessage\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @instance\n                         */\n                        ExportMetricsPartialSuccess.prototype.errorMessage = null;\n\n                        /**\n                         * Creates a new ExportMetricsPartialSuccess instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess instance\n                         */\n                        ExportMetricsPartialSuccess.create = function create(properties) {\n                            return new ExportMetricsPartialSuccess(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsPartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess} message ExportMetricsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsPartialSuccess.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.rejectedDataPoints != null && Object.hasOwnProperty.call(message, \"rejectedDataPoints\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rejectedDataPoints);\n                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, \"errorMessage\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportMetricsPartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess} message ExportMetricsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportMetricsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsPartialSuccess message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsPartialSuccess.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.rejectedDataPoints = reader.int64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.errorMessage = reader.string();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportMetricsPartialSuccess message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportMetricsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportMetricsPartialSuccess message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportMetricsPartialSuccess.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.rejectedDataPoints != null && message.hasOwnProperty(\"rejectedDataPoints\"))\n                                if (!$util.isInteger(message.rejectedDataPoints) && !(message.rejectedDataPoints && $util.isInteger(message.rejectedDataPoints.low) && $util.isInteger(message.rejectedDataPoints.high)))\n                                    return \"rejectedDataPoints: integer|Long expected\";\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                if (!$util.isString(message.errorMessage))\n                                    return \"errorMessage: string expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportMetricsPartialSuccess message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess\n                         */\n                        ExportMetricsPartialSuccess.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();\n                            if (object.rejectedDataPoints != null)\n                                if ($util.Long)\n                                    (message.rejectedDataPoints = $util.Long.fromValue(object.rejectedDataPoints)).unsigned = false;\n                                else if (typeof object.rejectedDataPoints === \"string\")\n                                    message.rejectedDataPoints = parseInt(object.rejectedDataPoints, 10);\n                                else if (typeof object.rejectedDataPoints === \"number\")\n                                    message.rejectedDataPoints = object.rejectedDataPoints;\n                                else if (typeof object.rejectedDataPoints === \"object\")\n                                    message.rejectedDataPoints = new $util.LongBits(object.rejectedDataPoints.low >>> 0, object.rejectedDataPoints.high >>> 0).toNumber();\n                            if (object.errorMessage != null)\n                                message.errorMessage = String(object.errorMessage);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportMetricsPartialSuccess message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} message ExportMetricsPartialSuccess\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportMetricsPartialSuccess.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.rejectedDataPoints = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.rejectedDataPoints = options.longs === String ? \"0\" : 0;\n                                object.errorMessage = \"\";\n                            }\n                            if (message.rejectedDataPoints != null && message.hasOwnProperty(\"rejectedDataPoints\"))\n                                if (typeof message.rejectedDataPoints === \"number\")\n                                    object.rejectedDataPoints = options.longs === String ? String(message.rejectedDataPoints) : message.rejectedDataPoints;\n                                else\n                                    object.rejectedDataPoints = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedDataPoints) : options.longs === Number ? new $util.LongBits(message.rejectedDataPoints.low >>> 0, message.rejectedDataPoints.high >>> 0).toNumber() : message.rejectedDataPoints;\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                object.errorMessage = message.errorMessage;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportMetricsPartialSuccess to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportMetricsPartialSuccess.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportMetricsPartialSuccess\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportMetricsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess\";\n                        };\n\n                        return ExportMetricsPartialSuccess;\n                    })();\n\n                    return v1;\n                })();\n\n                return metrics;\n            })();\n\n            collector.logs = (function() {\n\n                /**\n                 * Namespace logs.\n                 * @memberof opentelemetry.proto.collector\n                 * @namespace\n                 */\n                var logs = {};\n\n                logs.v1 = (function() {\n\n                    /**\n                     * Namespace v1.\n                     * @memberof opentelemetry.proto.collector.logs\n                     * @namespace\n                     */\n                    var v1 = {};\n\n                    v1.LogsService = (function() {\n\n                        /**\n                         * Constructs a new LogsService service.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents a LogsService\n                         * @extends $protobuf.rpc.Service\n                         * @constructor\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         */\n                        function LogsService(rpcImpl, requestDelimited, responseDelimited) {\n                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);\n                        }\n\n                        (LogsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LogsService;\n\n                        /**\n                         * Creates new LogsService service using the specified rpc implementation.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @static\n                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation\n                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n                         * @returns {LogsService} RPC service. Useful where requests and/or responses are streamed.\n                         */\n                        LogsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n                            return new this(rpcImpl, requestDelimited, responseDelimited);\n                        };\n\n                        /**\n                         * Callback as used by {@link opentelemetry.proto.collector.logs.v1.LogsService#export_}.\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @typedef ExportCallback\n                         * @type {function}\n                         * @param {Error|null} error Error, if any\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} [response] ExportLogsServiceResponse\n                         */\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} request ExportLogsServiceRequest message or plain object\n                         * @param {opentelemetry.proto.collector.logs.v1.LogsService.ExportCallback} callback Node-style callback called with the error, if any, and ExportLogsServiceResponse\n                         * @returns {undefined}\n                         * @variation 1\n                         */\n                        Object.defineProperty(LogsService.prototype[\"export\"] = function export_(request, callback) {\n                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse, request, callback);\n                        }, \"name\", { value: \"Export\" });\n\n                        /**\n                         * Calls Export.\n                         * @function export\n                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService\n                         * @instance\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} request ExportLogsServiceRequest message or plain object\n                         * @returns {Promise<opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse>} Promise\n                         * @variation 2\n                         */\n\n                        return LogsService;\n                    })();\n\n                    v1.ExportLogsServiceRequest = (function() {\n\n                        /**\n                         * Properties of an ExportLogsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @interface IExportLogsServiceRequest\n                         * @property {Array.<opentelemetry.proto.logs.v1.IResourceLogs>|null} [resourceLogs] ExportLogsServiceRequest resourceLogs\n                         */\n\n                        /**\n                         * Constructs a new ExportLogsServiceRequest.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents an ExportLogsServiceRequest.\n                         * @implements IExportLogsServiceRequest\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest=} [properties] Properties to set\n                         */\n                        function ExportLogsServiceRequest(properties) {\n                            this.resourceLogs = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportLogsServiceRequest resourceLogs.\n                         * @member {Array.<opentelemetry.proto.logs.v1.IResourceLogs>} resourceLogs\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @instance\n                         */\n                        ExportLogsServiceRequest.prototype.resourceLogs = $util.emptyArray;\n\n                        /**\n                         * Creates a new ExportLogsServiceRequest instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest instance\n                         */\n                        ExportLogsServiceRequest.create = function create(properties) {\n                            return new ExportLogsServiceRequest(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} message ExportLogsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceRequest.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.resourceLogs != null && message.resourceLogs.length)\n                                for (var i = 0; i < message.resourceLogs.length; ++i)\n                                    $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} message ExportLogsServiceRequest message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceRequest message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceRequest.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        if (!(message.resourceLogs && message.resourceLogs.length))\n                                            message.resourceLogs = [];\n                                        message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceRequest message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceRequest.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportLogsServiceRequest message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportLogsServiceRequest.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.resourceLogs != null && message.hasOwnProperty(\"resourceLogs\")) {\n                                if (!Array.isArray(message.resourceLogs))\n                                    return \"resourceLogs: array expected\";\n                                for (var i = 0; i < message.resourceLogs.length; ++i) {\n                                    var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);\n                                    if (error)\n                                        return \"resourceLogs.\" + error;\n                                }\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportLogsServiceRequest message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest\n                         */\n                        ExportLogsServiceRequest.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();\n                            if (object.resourceLogs) {\n                                if (!Array.isArray(object.resourceLogs))\n                                    throw TypeError(\".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: array expected\");\n                                message.resourceLogs = [];\n                                for (var i = 0; i < object.resourceLogs.length; ++i) {\n                                    if (typeof object.resourceLogs[i] !== \"object\")\n                                        throw TypeError(\".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: object expected\");\n                                    message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportLogsServiceRequest message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} message ExportLogsServiceRequest\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportLogsServiceRequest.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.resourceLogs = [];\n                            if (message.resourceLogs && message.resourceLogs.length) {\n                                object.resourceLogs = [];\n                                for (var j = 0; j < message.resourceLogs.length; ++j)\n                                    object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportLogsServiceRequest to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportLogsServiceRequest.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportLogsServiceRequest\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportLogsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest\";\n                        };\n\n                        return ExportLogsServiceRequest;\n                    })();\n\n                    v1.ExportLogsServiceResponse = (function() {\n\n                        /**\n                         * Properties of an ExportLogsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @interface IExportLogsServiceResponse\n                         * @property {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess|null} [partialSuccess] ExportLogsServiceResponse partialSuccess\n                         */\n\n                        /**\n                         * Constructs a new ExportLogsServiceResponse.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents an ExportLogsServiceResponse.\n                         * @implements IExportLogsServiceResponse\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse=} [properties] Properties to set\n                         */\n                        function ExportLogsServiceResponse(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportLogsServiceResponse partialSuccess.\n                         * @member {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess|null|undefined} partialSuccess\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @instance\n                         */\n                        ExportLogsServiceResponse.prototype.partialSuccess = null;\n\n                        /**\n                         * Creates a new ExportLogsServiceResponse instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse instance\n                         */\n                        ExportLogsServiceResponse.create = function create(properties) {\n                            return new ExportLogsServiceResponse(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse} message ExportLogsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceResponse.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, \"partialSuccess\"))\n                                $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse} message ExportLogsServiceResponse message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceResponse message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceResponse.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.decode(reader, reader.uint32());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportLogsServiceResponse message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsServiceResponse.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportLogsServiceResponse message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportLogsServiceResponse.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\")) {\n                                var error = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify(message.partialSuccess);\n                                if (error)\n                                    return \"partialSuccess.\" + error;\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportLogsServiceResponse message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse\n                         */\n                        ExportLogsServiceResponse.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();\n                            if (object.partialSuccess != null) {\n                                if (typeof object.partialSuccess !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.partialSuccess: object expected\");\n                                message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.fromObject(object.partialSuccess);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportLogsServiceResponse message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} message ExportLogsServiceResponse\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportLogsServiceResponse.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults)\n                                object.partialSuccess = null;\n                            if (message.partialSuccess != null && message.hasOwnProperty(\"partialSuccess\"))\n                                object.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.toObject(message.partialSuccess, options);\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportLogsServiceResponse to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportLogsServiceResponse.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportLogsServiceResponse\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportLogsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse\";\n                        };\n\n                        return ExportLogsServiceResponse;\n                    })();\n\n                    v1.ExportLogsPartialSuccess = (function() {\n\n                        /**\n                         * Properties of an ExportLogsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @interface IExportLogsPartialSuccess\n                         * @property {number|Long|null} [rejectedLogRecords] ExportLogsPartialSuccess rejectedLogRecords\n                         * @property {string|null} [errorMessage] ExportLogsPartialSuccess errorMessage\n                         */\n\n                        /**\n                         * Constructs a new ExportLogsPartialSuccess.\n                         * @memberof opentelemetry.proto.collector.logs.v1\n                         * @classdesc Represents an ExportLogsPartialSuccess.\n                         * @implements IExportLogsPartialSuccess\n                         * @constructor\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess=} [properties] Properties to set\n                         */\n                        function ExportLogsPartialSuccess(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ExportLogsPartialSuccess rejectedLogRecords.\n                         * @member {number|Long|null|undefined} rejectedLogRecords\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @instance\n                         */\n                        ExportLogsPartialSuccess.prototype.rejectedLogRecords = null;\n\n                        /**\n                         * ExportLogsPartialSuccess errorMessage.\n                         * @member {string|null|undefined} errorMessage\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @instance\n                         */\n                        ExportLogsPartialSuccess.prototype.errorMessage = null;\n\n                        /**\n                         * Creates a new ExportLogsPartialSuccess instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess instance\n                         */\n                        ExportLogsPartialSuccess.create = function create(properties) {\n                            return new ExportLogsPartialSuccess(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsPartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess} message ExportLogsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsPartialSuccess.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.rejectedLogRecords != null && Object.hasOwnProperty.call(message, \"rejectedLogRecords\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.rejectedLogRecords);\n                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, \"errorMessage\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ExportLogsPartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess} message ExportLogsPartialSuccess message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ExportLogsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes an ExportLogsPartialSuccess message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsPartialSuccess.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.rejectedLogRecords = reader.int64();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.errorMessage = reader.string();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes an ExportLogsPartialSuccess message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ExportLogsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies an ExportLogsPartialSuccess message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ExportLogsPartialSuccess.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.rejectedLogRecords != null && message.hasOwnProperty(\"rejectedLogRecords\"))\n                                if (!$util.isInteger(message.rejectedLogRecords) && !(message.rejectedLogRecords && $util.isInteger(message.rejectedLogRecords.low) && $util.isInteger(message.rejectedLogRecords.high)))\n                                    return \"rejectedLogRecords: integer|Long expected\";\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                if (!$util.isString(message.errorMessage))\n                                    return \"errorMessage: string expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates an ExportLogsPartialSuccess message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess\n                         */\n                        ExportLogsPartialSuccess.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess)\n                                return object;\n                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();\n                            if (object.rejectedLogRecords != null)\n                                if ($util.Long)\n                                    (message.rejectedLogRecords = $util.Long.fromValue(object.rejectedLogRecords)).unsigned = false;\n                                else if (typeof object.rejectedLogRecords === \"string\")\n                                    message.rejectedLogRecords = parseInt(object.rejectedLogRecords, 10);\n                                else if (typeof object.rejectedLogRecords === \"number\")\n                                    message.rejectedLogRecords = object.rejectedLogRecords;\n                                else if (typeof object.rejectedLogRecords === \"object\")\n                                    message.rejectedLogRecords = new $util.LongBits(object.rejectedLogRecords.low >>> 0, object.rejectedLogRecords.high >>> 0).toNumber();\n                            if (object.errorMessage != null)\n                                message.errorMessage = String(object.errorMessage);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from an ExportLogsPartialSuccess message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} message ExportLogsPartialSuccess\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ExportLogsPartialSuccess.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                if ($util.Long) {\n                                    var long = new $util.Long(0, 0, false);\n                                    object.rejectedLogRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                                } else\n                                    object.rejectedLogRecords = options.longs === String ? \"0\" : 0;\n                                object.errorMessage = \"\";\n                            }\n                            if (message.rejectedLogRecords != null && message.hasOwnProperty(\"rejectedLogRecords\"))\n                                if (typeof message.rejectedLogRecords === \"number\")\n                                    object.rejectedLogRecords = options.longs === String ? String(message.rejectedLogRecords) : message.rejectedLogRecords;\n                                else\n                                    object.rejectedLogRecords = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedLogRecords) : options.longs === Number ? new $util.LongBits(message.rejectedLogRecords.low >>> 0, message.rejectedLogRecords.high >>> 0).toNumber() : message.rejectedLogRecords;\n                            if (message.errorMessage != null && message.hasOwnProperty(\"errorMessage\"))\n                                object.errorMessage = message.errorMessage;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ExportLogsPartialSuccess to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ExportLogsPartialSuccess.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ExportLogsPartialSuccess\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ExportLogsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess\";\n                        };\n\n                        return ExportLogsPartialSuccess;\n                    })();\n\n                    return v1;\n                })();\n\n                return logs;\n            })();\n\n            return collector;\n        })();\n\n        proto.metrics = (function() {\n\n            /**\n             * Namespace metrics.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var metrics = {};\n\n            metrics.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.metrics\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.MetricsData = (function() {\n\n                    /**\n                     * Properties of a MetricsData.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IMetricsData\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>|null} [resourceMetrics] MetricsData resourceMetrics\n                     */\n\n                    /**\n                     * Constructs a new MetricsData.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a MetricsData.\n                     * @implements IMetricsData\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData=} [properties] Properties to set\n                     */\n                    function MetricsData(properties) {\n                        this.resourceMetrics = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * MetricsData resourceMetrics.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>} resourceMetrics\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @instance\n                     */\n                    MetricsData.prototype.resourceMetrics = $util.emptyArray;\n\n                    /**\n                     * Creates a new MetricsData instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData instance\n                     */\n                    MetricsData.create = function create(properties) {\n                        return new MetricsData(properties);\n                    };\n\n                    /**\n                     * Encodes the specified MetricsData message. Does not implicitly {@link opentelemetry.proto.metrics.v1.MetricsData.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData} message MetricsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    MetricsData.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resourceMetrics != null && message.resourceMetrics.length)\n                            for (var i = 0; i < message.resourceMetrics.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified MetricsData message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.MetricsData.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetricsData} message MetricsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    MetricsData.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a MetricsData message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    MetricsData.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.MetricsData();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.resourceMetrics && message.resourceMetrics.length))\n                                        message.resourceMetrics = [];\n                                    message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a MetricsData message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    MetricsData.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a MetricsData message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    MetricsData.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resourceMetrics != null && message.hasOwnProperty(\"resourceMetrics\")) {\n                            if (!Array.isArray(message.resourceMetrics))\n                                return \"resourceMetrics: array expected\";\n                            for (var i = 0; i < message.resourceMetrics.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);\n                                if (error)\n                                    return \"resourceMetrics.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a MetricsData message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData\n                     */\n                    MetricsData.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.MetricsData)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.MetricsData();\n                        if (object.resourceMetrics) {\n                            if (!Array.isArray(object.resourceMetrics))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: array expected\");\n                            message.resourceMetrics = [];\n                            for (var i = 0; i < object.resourceMetrics.length; ++i) {\n                                if (typeof object.resourceMetrics[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: object expected\");\n                                message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a MetricsData message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.MetricsData} message MetricsData\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    MetricsData.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.resourceMetrics = [];\n                        if (message.resourceMetrics && message.resourceMetrics.length) {\n                            object.resourceMetrics = [];\n                            for (var j = 0; j < message.resourceMetrics.length; ++j)\n                                object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this MetricsData to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    MetricsData.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for MetricsData\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.MetricsData\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    MetricsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.MetricsData\";\n                    };\n\n                    return MetricsData;\n                })();\n\n                v1.ResourceMetrics = (function() {\n\n                    /**\n                     * Properties of a ResourceMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IResourceMetrics\n                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceMetrics resource\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IScopeMetrics>|null} [scopeMetrics] ResourceMetrics scopeMetrics\n                     * @property {string|null} [schemaUrl] ResourceMetrics schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ResourceMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a ResourceMetrics.\n                     * @implements IResourceMetrics\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics=} [properties] Properties to set\n                     */\n                    function ResourceMetrics(properties) {\n                        this.scopeMetrics = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ResourceMetrics resource.\n                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     */\n                    ResourceMetrics.prototype.resource = null;\n\n                    /**\n                     * ResourceMetrics scopeMetrics.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IScopeMetrics>} scopeMetrics\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     */\n                    ResourceMetrics.prototype.scopeMetrics = $util.emptyArray;\n\n                    /**\n                     * ResourceMetrics schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     */\n                    ResourceMetrics.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ResourceMetrics instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics instance\n                     */\n                    ResourceMetrics.create = function create(properties) {\n                        return new ResourceMetrics(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ResourceMetrics message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ResourceMetrics.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics} message ResourceMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceMetrics.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resource != null && Object.hasOwnProperty.call(message, \"resource\"))\n                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.scopeMetrics != null && message.scopeMetrics.length)\n                            for (var i = 0; i < message.scopeMetrics.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.ScopeMetrics.encode(message.scopeMetrics[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ResourceMetrics message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ResourceMetrics.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics} message ResourceMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceMetrics.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ResourceMetrics message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceMetrics.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.scopeMetrics && message.scopeMetrics.length))\n                                        message.scopeMetrics = [];\n                                    message.scopeMetrics.push($root.opentelemetry.proto.metrics.v1.ScopeMetrics.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ResourceMetrics message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceMetrics.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ResourceMetrics message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ResourceMetrics.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resource != null && message.hasOwnProperty(\"resource\")) {\n                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);\n                            if (error)\n                                return \"resource.\" + error;\n                        }\n                        if (message.scopeMetrics != null && message.hasOwnProperty(\"scopeMetrics\")) {\n                            if (!Array.isArray(message.scopeMetrics))\n                                return \"scopeMetrics: array expected\";\n                            for (var i = 0; i < message.scopeMetrics.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.verify(message.scopeMetrics[i]);\n                                if (error)\n                                    return \"scopeMetrics.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ResourceMetrics message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics\n                     */\n                    ResourceMetrics.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ResourceMetrics)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();\n                        if (object.resource != null) {\n                            if (typeof object.resource !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ResourceMetrics.resource: object expected\");\n                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);\n                        }\n                        if (object.scopeMetrics) {\n                            if (!Array.isArray(object.scopeMetrics))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: array expected\");\n                            message.scopeMetrics = [];\n                            for (var i = 0; i < object.scopeMetrics.length; ++i) {\n                                if (typeof object.scopeMetrics[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: object expected\");\n                                message.scopeMetrics[i] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.fromObject(object.scopeMetrics[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ResourceMetrics message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ResourceMetrics} message ResourceMetrics\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ResourceMetrics.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.scopeMetrics = [];\n                        if (options.defaults) {\n                            object.resource = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.resource != null && message.hasOwnProperty(\"resource\"))\n                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);\n                        if (message.scopeMetrics && message.scopeMetrics.length) {\n                            object.scopeMetrics = [];\n                            for (var j = 0; j < message.scopeMetrics.length; ++j)\n                                object.scopeMetrics[j] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.toObject(message.scopeMetrics[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ResourceMetrics to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ResourceMetrics.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ResourceMetrics\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ResourceMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ResourceMetrics\";\n                    };\n\n                    return ResourceMetrics;\n                })();\n\n                v1.ScopeMetrics = (function() {\n\n                    /**\n                     * Properties of a ScopeMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IScopeMetrics\n                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeMetrics scope\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IMetric>|null} [metrics] ScopeMetrics metrics\n                     * @property {string|null} [schemaUrl] ScopeMetrics schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ScopeMetrics.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a ScopeMetrics.\n                     * @implements IScopeMetrics\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics=} [properties] Properties to set\n                     */\n                    function ScopeMetrics(properties) {\n                        this.metrics = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ScopeMetrics scope.\n                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     */\n                    ScopeMetrics.prototype.scope = null;\n\n                    /**\n                     * ScopeMetrics metrics.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IMetric>} metrics\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     */\n                    ScopeMetrics.prototype.metrics = $util.emptyArray;\n\n                    /**\n                     * ScopeMetrics schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     */\n                    ScopeMetrics.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ScopeMetrics instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics instance\n                     */\n                    ScopeMetrics.create = function create(properties) {\n                        return new ScopeMetrics(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ScopeMetrics message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ScopeMetrics.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics} message ScopeMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeMetrics.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.metrics != null && message.metrics.length)\n                            for (var i = 0; i < message.metrics.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Metric.encode(message.metrics[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ScopeMetrics message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ScopeMetrics.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics} message ScopeMetrics message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeMetrics.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ScopeMetrics message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeMetrics.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.metrics && message.metrics.length))\n                                        message.metrics = [];\n                                    message.metrics.push($root.opentelemetry.proto.metrics.v1.Metric.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ScopeMetrics message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeMetrics.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ScopeMetrics message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ScopeMetrics.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.scope != null && message.hasOwnProperty(\"scope\")) {\n                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);\n                            if (error)\n                                return \"scope.\" + error;\n                        }\n                        if (message.metrics != null && message.hasOwnProperty(\"metrics\")) {\n                            if (!Array.isArray(message.metrics))\n                                return \"metrics: array expected\";\n                            for (var i = 0; i < message.metrics.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Metric.verify(message.metrics[i]);\n                                if (error)\n                                    return \"metrics.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ScopeMetrics message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics\n                     */\n                    ScopeMetrics.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ScopeMetrics)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();\n                        if (object.scope != null) {\n                            if (typeof object.scope !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ScopeMetrics.scope: object expected\");\n                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);\n                        }\n                        if (object.metrics) {\n                            if (!Array.isArray(object.metrics))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: array expected\");\n                            message.metrics = [];\n                            for (var i = 0; i < object.metrics.length; ++i) {\n                                if (typeof object.metrics[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: object expected\");\n                                message.metrics[i] = $root.opentelemetry.proto.metrics.v1.Metric.fromObject(object.metrics[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ScopeMetrics message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ScopeMetrics} message ScopeMetrics\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ScopeMetrics.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.metrics = [];\n                        if (options.defaults) {\n                            object.scope = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);\n                        if (message.metrics && message.metrics.length) {\n                            object.metrics = [];\n                            for (var j = 0; j < message.metrics.length; ++j)\n                                object.metrics[j] = $root.opentelemetry.proto.metrics.v1.Metric.toObject(message.metrics[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ScopeMetrics to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ScopeMetrics.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ScopeMetrics\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ScopeMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ScopeMetrics\";\n                    };\n\n                    return ScopeMetrics;\n                })();\n\n                v1.Metric = (function() {\n\n                    /**\n                     * Properties of a Metric.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IMetric\n                     * @property {string|null} [name] Metric name\n                     * @property {string|null} [description] Metric description\n                     * @property {string|null} [unit] Metric unit\n                     * @property {opentelemetry.proto.metrics.v1.IGauge|null} [gauge] Metric gauge\n                     * @property {opentelemetry.proto.metrics.v1.ISum|null} [sum] Metric sum\n                     * @property {opentelemetry.proto.metrics.v1.IHistogram|null} [histogram] Metric histogram\n                     * @property {opentelemetry.proto.metrics.v1.IExponentialHistogram|null} [exponentialHistogram] Metric exponentialHistogram\n                     * @property {opentelemetry.proto.metrics.v1.ISummary|null} [summary] Metric summary\n                     */\n\n                    /**\n                     * Constructs a new Metric.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Metric.\n                     * @implements IMetric\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IMetric=} [properties] Properties to set\n                     */\n                    function Metric(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Metric name.\n                     * @member {string|null|undefined} name\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.name = null;\n\n                    /**\n                     * Metric description.\n                     * @member {string|null|undefined} description\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.description = null;\n\n                    /**\n                     * Metric unit.\n                     * @member {string|null|undefined} unit\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.unit = null;\n\n                    /**\n                     * Metric gauge.\n                     * @member {opentelemetry.proto.metrics.v1.IGauge|null|undefined} gauge\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.gauge = null;\n\n                    /**\n                     * Metric sum.\n                     * @member {opentelemetry.proto.metrics.v1.ISum|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.sum = null;\n\n                    /**\n                     * Metric histogram.\n                     * @member {opentelemetry.proto.metrics.v1.IHistogram|null|undefined} histogram\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.histogram = null;\n\n                    /**\n                     * Metric exponentialHistogram.\n                     * @member {opentelemetry.proto.metrics.v1.IExponentialHistogram|null|undefined} exponentialHistogram\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.exponentialHistogram = null;\n\n                    /**\n                     * Metric summary.\n                     * @member {opentelemetry.proto.metrics.v1.ISummary|null|undefined} summary\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Metric.prototype.summary = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * Metric data.\n                     * @member {\"gauge\"|\"sum\"|\"histogram\"|\"exponentialHistogram\"|\"summary\"|undefined} data\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     */\n                    Object.defineProperty(Metric.prototype, \"data\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"gauge\", \"sum\", \"histogram\", \"exponentialHistogram\", \"summary\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new Metric instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetric=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric instance\n                     */\n                    Metric.create = function create(properties) {\n                        return new Metric(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Metric message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Metric.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetric} message Metric message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Metric.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.description != null && Object.hasOwnProperty.call(message, \"description\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);\n                        if (message.unit != null && Object.hasOwnProperty.call(message, \"unit\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.unit);\n                        if (message.gauge != null && Object.hasOwnProperty.call(message, \"gauge\"))\n                            $root.opentelemetry.proto.metrics.v1.Gauge.encode(message.gauge, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            $root.opentelemetry.proto.metrics.v1.Sum.encode(message.sum, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.histogram != null && Object.hasOwnProperty.call(message, \"histogram\"))\n                            $root.opentelemetry.proto.metrics.v1.Histogram.encode(message.histogram, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.exponentialHistogram != null && Object.hasOwnProperty.call(message, \"exponentialHistogram\"))\n                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.encode(message.exponentialHistogram, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                        if (message.summary != null && Object.hasOwnProperty.call(message, \"summary\"))\n                            $root.opentelemetry.proto.metrics.v1.Summary.encode(message.summary, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Metric message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Metric.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IMetric} message Metric message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Metric.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Metric message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Metric.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Metric();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.name = reader.string();\n                                    break;\n                                }\n                            case 2: {\n                                    message.description = reader.string();\n                                    break;\n                                }\n                            case 3: {\n                                    message.unit = reader.string();\n                                    break;\n                                }\n                            case 5: {\n                                    message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 7: {\n                                    message.sum = $root.opentelemetry.proto.metrics.v1.Sum.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 9: {\n                                    message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 10: {\n                                    message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 11: {\n                                    message.summary = $root.opentelemetry.proto.metrics.v1.Summary.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Metric message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Metric.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Metric message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Metric.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            if (!$util.isString(message.name))\n                                return \"name: string expected\";\n                        if (message.description != null && message.hasOwnProperty(\"description\"))\n                            if (!$util.isString(message.description))\n                                return \"description: string expected\";\n                        if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                            if (!$util.isString(message.unit))\n                                return \"unit: string expected\";\n                        if (message.gauge != null && message.hasOwnProperty(\"gauge\")) {\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Gauge.verify(message.gauge);\n                                if (error)\n                                    return \"gauge.\" + error;\n                            }\n                        }\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Sum.verify(message.sum);\n                                if (error)\n                                    return \"sum.\" + error;\n                            }\n                        }\n                        if (message.histogram != null && message.hasOwnProperty(\"histogram\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Histogram.verify(message.histogram);\n                                if (error)\n                                    return \"histogram.\" + error;\n                            }\n                        }\n                        if (message.exponentialHistogram != null && message.hasOwnProperty(\"exponentialHistogram\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.verify(message.exponentialHistogram);\n                                if (error)\n                                    return \"exponentialHistogram.\" + error;\n                            }\n                        }\n                        if (message.summary != null && message.hasOwnProperty(\"summary\")) {\n                            if (properties.data === 1)\n                                return \"data: multiple values\";\n                            properties.data = 1;\n                            {\n                                var error = $root.opentelemetry.proto.metrics.v1.Summary.verify(message.summary);\n                                if (error)\n                                    return \"summary.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Metric message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric\n                     */\n                    Metric.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Metric)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Metric();\n                        if (object.name != null)\n                            message.name = String(object.name);\n                        if (object.description != null)\n                            message.description = String(object.description);\n                        if (object.unit != null)\n                            message.unit = String(object.unit);\n                        if (object.gauge != null) {\n                            if (typeof object.gauge !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.gauge: object expected\");\n                            message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.fromObject(object.gauge);\n                        }\n                        if (object.sum != null) {\n                            if (typeof object.sum !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.sum: object expected\");\n                            message.sum = $root.opentelemetry.proto.metrics.v1.Sum.fromObject(object.sum);\n                        }\n                        if (object.histogram != null) {\n                            if (typeof object.histogram !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.histogram: object expected\");\n                            message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.fromObject(object.histogram);\n                        }\n                        if (object.exponentialHistogram != null) {\n                            if (typeof object.exponentialHistogram !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.exponentialHistogram: object expected\");\n                            message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.fromObject(object.exponentialHistogram);\n                        }\n                        if (object.summary != null) {\n                            if (typeof object.summary !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Metric.summary: object expected\");\n                            message.summary = $root.opentelemetry.proto.metrics.v1.Summary.fromObject(object.summary);\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Metric message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Metric} message Metric\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Metric.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.defaults) {\n                            object.name = \"\";\n                            object.description = \"\";\n                            object.unit = \"\";\n                        }\n                        if (message.name != null && message.hasOwnProperty(\"name\"))\n                            object.name = message.name;\n                        if (message.description != null && message.hasOwnProperty(\"description\"))\n                            object.description = message.description;\n                        if (message.unit != null && message.hasOwnProperty(\"unit\"))\n                            object.unit = message.unit;\n                        if (message.gauge != null && message.hasOwnProperty(\"gauge\")) {\n                            object.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.toObject(message.gauge, options);\n                            if (options.oneofs)\n                                object.data = \"gauge\";\n                        }\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            object.sum = $root.opentelemetry.proto.metrics.v1.Sum.toObject(message.sum, options);\n                            if (options.oneofs)\n                                object.data = \"sum\";\n                        }\n                        if (message.histogram != null && message.hasOwnProperty(\"histogram\")) {\n                            object.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.toObject(message.histogram, options);\n                            if (options.oneofs)\n                                object.data = \"histogram\";\n                        }\n                        if (message.exponentialHistogram != null && message.hasOwnProperty(\"exponentialHistogram\")) {\n                            object.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.toObject(message.exponentialHistogram, options);\n                            if (options.oneofs)\n                                object.data = \"exponentialHistogram\";\n                        }\n                        if (message.summary != null && message.hasOwnProperty(\"summary\")) {\n                            object.summary = $root.opentelemetry.proto.metrics.v1.Summary.toObject(message.summary, options);\n                            if (options.oneofs)\n                                object.data = \"summary\";\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Metric to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Metric.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Metric\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Metric\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Metric.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Metric\";\n                    };\n\n                    return Metric;\n                })();\n\n                v1.Gauge = (function() {\n\n                    /**\n                     * Properties of a Gauge.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IGauge\n                     * @property {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>|null} [dataPoints] Gauge dataPoints\n                     */\n\n                    /**\n                     * Constructs a new Gauge.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Gauge.\n                     * @implements IGauge\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IGauge=} [properties] Properties to set\n                     */\n                    function Gauge(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Gauge dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @instance\n                     */\n                    Gauge.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Creates a new Gauge instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IGauge=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge instance\n                     */\n                    Gauge.create = function create(properties) {\n                        return new Gauge(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Gauge message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Gauge.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IGauge} message Gauge message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Gauge.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Gauge message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Gauge.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IGauge} message Gauge message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Gauge.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Gauge message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Gauge.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Gauge();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Gauge message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Gauge.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Gauge message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Gauge.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Gauge message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge\n                     */\n                    Gauge.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Gauge)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Gauge();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Gauge.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Gauge.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Gauge message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Gauge} message Gauge\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Gauge.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Gauge to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Gauge.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Gauge\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Gauge\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Gauge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Gauge\";\n                    };\n\n                    return Gauge;\n                })();\n\n                v1.Sum = (function() {\n\n                    /**\n                     * Properties of a Sum.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface ISum\n                     * @property {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>|null} [dataPoints] Sum dataPoints\n                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] Sum aggregationTemporality\n                     * @property {boolean|null} [isMonotonic] Sum isMonotonic\n                     */\n\n                    /**\n                     * Constructs a new Sum.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Sum.\n                     * @implements ISum\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.ISum=} [properties] Properties to set\n                     */\n                    function Sum(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Sum dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     */\n                    Sum.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Sum aggregationTemporality.\n                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     */\n                    Sum.prototype.aggregationTemporality = null;\n\n                    /**\n                     * Sum isMonotonic.\n                     * @member {boolean|null|undefined} isMonotonic\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     */\n                    Sum.prototype.isMonotonic = null;\n\n                    /**\n                     * Creates a new Sum instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISum=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum instance\n                     */\n                    Sum.create = function create(properties) {\n                        return new Sum(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Sum message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Sum.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISum} message Sum message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Sum.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, \"aggregationTemporality\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.aggregationTemporality);\n                        if (message.isMonotonic != null && Object.hasOwnProperty.call(message, \"isMonotonic\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isMonotonic);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Sum message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Sum.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISum} message Sum message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Sum.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Sum message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Sum.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Sum();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.aggregationTemporality = reader.int32();\n                                    break;\n                                }\n                            case 3: {\n                                    message.isMonotonic = reader.bool();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Sum message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Sum.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Sum message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Sum.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            switch (message.aggregationTemporality) {\n                            default:\n                                return \"aggregationTemporality: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        if (message.isMonotonic != null && message.hasOwnProperty(\"isMonotonic\"))\n                            if (typeof message.isMonotonic !== \"boolean\")\n                                return \"isMonotonic: boolean expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Sum message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum\n                     */\n                    Sum.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Sum)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Sum();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Sum.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Sum.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        switch (object.aggregationTemporality) {\n                        default:\n                            if (typeof object.aggregationTemporality === \"number\") {\n                                message.aggregationTemporality = object.aggregationTemporality;\n                                break;\n                            }\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_UNSPECIFIED\":\n                        case 0:\n                            message.aggregationTemporality = 0;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_DELTA\":\n                        case 1:\n                            message.aggregationTemporality = 1;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_CUMULATIVE\":\n                        case 2:\n                            message.aggregationTemporality = 2;\n                            break;\n                        }\n                        if (object.isMonotonic != null)\n                            message.isMonotonic = Boolean(object.isMonotonic);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Sum message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Sum} message Sum\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Sum.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (options.defaults) {\n                            object.aggregationTemporality = options.enums === String ? \"AGGREGATION_TEMPORALITY_UNSPECIFIED\" : 0;\n                            object.isMonotonic = false;\n                        }\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;\n                        if (message.isMonotonic != null && message.hasOwnProperty(\"isMonotonic\"))\n                            object.isMonotonic = message.isMonotonic;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Sum to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Sum.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Sum\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Sum\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Sum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Sum\";\n                    };\n\n                    return Sum;\n                })();\n\n                v1.Histogram = (function() {\n\n                    /**\n                     * Properties of a Histogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IHistogram\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IHistogramDataPoint>|null} [dataPoints] Histogram dataPoints\n                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] Histogram aggregationTemporality\n                     */\n\n                    /**\n                     * Constructs a new Histogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Histogram.\n                     * @implements IHistogram\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram=} [properties] Properties to set\n                     */\n                    function Histogram(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Histogram dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IHistogramDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @instance\n                     */\n                    Histogram.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Histogram aggregationTemporality.\n                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @instance\n                     */\n                    Histogram.prototype.aggregationTemporality = null;\n\n                    /**\n                     * Creates a new Histogram instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram instance\n                     */\n                    Histogram.create = function create(properties) {\n                        return new Histogram(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Histogram message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Histogram.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram} message Histogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Histogram.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, \"aggregationTemporality\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.aggregationTemporality);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Histogram message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Histogram.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogram} message Histogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Histogram.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Histogram message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Histogram.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Histogram();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.HistogramDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.aggregationTemporality = reader.int32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Histogram message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Histogram.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Histogram message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Histogram.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            switch (message.aggregationTemporality) {\n                            default:\n                                return \"aggregationTemporality: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Histogram message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram\n                     */\n                    Histogram.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Histogram)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Histogram();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Histogram.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Histogram.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        switch (object.aggregationTemporality) {\n                        default:\n                            if (typeof object.aggregationTemporality === \"number\") {\n                                message.aggregationTemporality = object.aggregationTemporality;\n                                break;\n                            }\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_UNSPECIFIED\":\n                        case 0:\n                            message.aggregationTemporality = 0;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_DELTA\":\n                        case 1:\n                            message.aggregationTemporality = 1;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_CUMULATIVE\":\n                        case 2:\n                            message.aggregationTemporality = 2;\n                            break;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Histogram message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Histogram} message Histogram\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Histogram.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (options.defaults)\n                            object.aggregationTemporality = options.enums === String ? \"AGGREGATION_TEMPORALITY_UNSPECIFIED\" : 0;\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Histogram to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Histogram.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Histogram\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Histogram\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Histogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Histogram\";\n                    };\n\n                    return Histogram;\n                })();\n\n                v1.ExponentialHistogram = (function() {\n\n                    /**\n                     * Properties of an ExponentialHistogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IExponentialHistogram\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint>|null} [dataPoints] ExponentialHistogram dataPoints\n                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] ExponentialHistogram aggregationTemporality\n                     */\n\n                    /**\n                     * Constructs a new ExponentialHistogram.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents an ExponentialHistogram.\n                     * @implements IExponentialHistogram\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram=} [properties] Properties to set\n                     */\n                    function ExponentialHistogram(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ExponentialHistogram dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @instance\n                     */\n                    ExponentialHistogram.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * ExponentialHistogram aggregationTemporality.\n                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @instance\n                     */\n                    ExponentialHistogram.prototype.aggregationTemporality = null;\n\n                    /**\n                     * Creates a new ExponentialHistogram instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram instance\n                     */\n                    ExponentialHistogram.create = function create(properties) {\n                        return new ExponentialHistogram(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogram message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogram.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram} message ExponentialHistogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogram.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, \"aggregationTemporality\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.aggregationTemporality);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogram message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogram.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram} message ExponentialHistogram message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogram.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogram message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogram.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.aggregationTemporality = reader.int32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogram message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogram.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an ExponentialHistogram message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ExponentialHistogram.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            switch (message.aggregationTemporality) {\n                            default:\n                                return \"aggregationTemporality: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                                break;\n                            }\n                        return null;\n                    };\n\n                    /**\n                     * Creates an ExponentialHistogram message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram\n                     */\n                    ExponentialHistogram.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogram)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        switch (object.aggregationTemporality) {\n                        default:\n                            if (typeof object.aggregationTemporality === \"number\") {\n                                message.aggregationTemporality = object.aggregationTemporality;\n                                break;\n                            }\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_UNSPECIFIED\":\n                        case 0:\n                            message.aggregationTemporality = 0;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_DELTA\":\n                        case 1:\n                            message.aggregationTemporality = 1;\n                            break;\n                        case \"AGGREGATION_TEMPORALITY_CUMULATIVE\":\n                        case 2:\n                            message.aggregationTemporality = 2;\n                            break;\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an ExponentialHistogram message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ExponentialHistogram} message ExponentialHistogram\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ExponentialHistogram.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (options.defaults)\n                            object.aggregationTemporality = options.enums === String ? \"AGGREGATION_TEMPORALITY_UNSPECIFIED\" : 0;\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        if (message.aggregationTemporality != null && message.hasOwnProperty(\"aggregationTemporality\"))\n                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ExponentialHistogram to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ExponentialHistogram.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ExponentialHistogram\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ExponentialHistogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ExponentialHistogram\";\n                    };\n\n                    return ExponentialHistogram;\n                })();\n\n                v1.Summary = (function() {\n\n                    /**\n                     * Properties of a Summary.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface ISummary\n                     * @property {Array.<opentelemetry.proto.metrics.v1.ISummaryDataPoint>|null} [dataPoints] Summary dataPoints\n                     */\n\n                    /**\n                     * Constructs a new Summary.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a Summary.\n                     * @implements ISummary\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.ISummary=} [properties] Properties to set\n                     */\n                    function Summary(properties) {\n                        this.dataPoints = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Summary dataPoints.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.ISummaryDataPoint>} dataPoints\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @instance\n                     */\n                    Summary.prototype.dataPoints = $util.emptyArray;\n\n                    /**\n                     * Creates a new Summary instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummary=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary instance\n                     */\n                    Summary.create = function create(properties) {\n                        return new Summary(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Summary message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Summary.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummary} message Summary message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Summary.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.dataPoints != null && message.dataPoints.length)\n                            for (var i = 0; i < message.dataPoints.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Summary message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Summary.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummary} message Summary message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Summary.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a Summary message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Summary.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Summary();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.dataPoints && message.dataPoints.length))\n                                        message.dataPoints = [];\n                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a Summary message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Summary.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a Summary message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Summary.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.dataPoints != null && message.hasOwnProperty(\"dataPoints\")) {\n                            if (!Array.isArray(message.dataPoints))\n                                return \"dataPoints: array expected\";\n                            for (var i = 0; i < message.dataPoints.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.verify(message.dataPoints[i]);\n                                if (error)\n                                    return \"dataPoints.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a Summary message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary\n                     */\n                    Summary.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Summary)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Summary();\n                        if (object.dataPoints) {\n                            if (!Array.isArray(object.dataPoints))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Summary.dataPoints: array expected\");\n                            message.dataPoints = [];\n                            for (var i = 0; i < object.dataPoints.length; ++i) {\n                                if (typeof object.dataPoints[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Summary.dataPoints: object expected\");\n                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.fromObject(object.dataPoints[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a Summary message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Summary} message Summary\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Summary.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.dataPoints = [];\n                        if (message.dataPoints && message.dataPoints.length) {\n                            object.dataPoints = [];\n                            for (var j = 0; j < message.dataPoints.length; ++j)\n                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.toObject(message.dataPoints[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Summary to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Summary.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Summary\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Summary\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Summary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Summary\";\n                    };\n\n                    return Summary;\n                })();\n\n                /**\n                 * AggregationTemporality enum.\n                 * @name opentelemetry.proto.metrics.v1.AggregationTemporality\n                 * @enum {number}\n                 * @property {number} AGGREGATION_TEMPORALITY_UNSPECIFIED=0 AGGREGATION_TEMPORALITY_UNSPECIFIED value\n                 * @property {number} AGGREGATION_TEMPORALITY_DELTA=1 AGGREGATION_TEMPORALITY_DELTA value\n                 * @property {number} AGGREGATION_TEMPORALITY_CUMULATIVE=2 AGGREGATION_TEMPORALITY_CUMULATIVE value\n                 */\n                v1.AggregationTemporality = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"AGGREGATION_TEMPORALITY_UNSPECIFIED\"] = 0;\n                    values[valuesById[1] = \"AGGREGATION_TEMPORALITY_DELTA\"] = 1;\n                    values[valuesById[2] = \"AGGREGATION_TEMPORALITY_CUMULATIVE\"] = 2;\n                    return values;\n                })();\n\n                /**\n                 * DataPointFlags enum.\n                 * @name opentelemetry.proto.metrics.v1.DataPointFlags\n                 * @enum {number}\n                 * @property {number} DATA_POINT_FLAGS_DO_NOT_USE=0 DATA_POINT_FLAGS_DO_NOT_USE value\n                 * @property {number} DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK=1 DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK value\n                 */\n                v1.DataPointFlags = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"DATA_POINT_FLAGS_DO_NOT_USE\"] = 0;\n                    values[valuesById[1] = \"DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK\"] = 1;\n                    return values;\n                })();\n\n                v1.NumberDataPoint = (function() {\n\n                    /**\n                     * Properties of a NumberDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface INumberDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] NumberDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] NumberDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] NumberDataPoint timeUnixNano\n                     * @property {number|null} [asDouble] NumberDataPoint asDouble\n                     * @property {number|Long|null} [asInt] NumberDataPoint asInt\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] NumberDataPoint exemplars\n                     * @property {number|null} [flags] NumberDataPoint flags\n                     */\n\n                    /**\n                     * Constructs a new NumberDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a NumberDataPoint.\n                     * @implements INumberDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint=} [properties] Properties to set\n                     */\n                    function NumberDataPoint(properties) {\n                        this.attributes = [];\n                        this.exemplars = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * NumberDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * NumberDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * NumberDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * NumberDataPoint asDouble.\n                     * @member {number|null|undefined} asDouble\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.asDouble = null;\n\n                    /**\n                     * NumberDataPoint asInt.\n                     * @member {number|Long|null|undefined} asInt\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.asInt = null;\n\n                    /**\n                     * NumberDataPoint exemplars.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.exemplars = $util.emptyArray;\n\n                    /**\n                     * NumberDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    NumberDataPoint.prototype.flags = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * NumberDataPoint value.\n                     * @member {\"asDouble\"|\"asInt\"|undefined} value\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     */\n                    Object.defineProperty(NumberDataPoint.prototype, \"value\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"asDouble\", \"asInt\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new NumberDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint instance\n                     */\n                    NumberDataPoint.create = function create(properties) {\n                        return new NumberDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified NumberDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.NumberDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint} message NumberDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NumberDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.asDouble != null && Object.hasOwnProperty.call(message, \"asDouble\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).double(message.asDouble);\n                        if (message.exemplars != null && message.exemplars.length)\n                            for (var i = 0; i < message.exemplars.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.asInt != null && Object.hasOwnProperty.call(message, \"asInt\"))\n                            writer.uint32(/* id 6, wireType 1 =*/49).sfixed64(message.asInt);\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified NumberDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.NumberDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint} message NumberDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NumberDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a NumberDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NumberDataPoint.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 7: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.asDouble = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    message.asInt = reader.sfixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    if (!(message.exemplars && message.exemplars.length))\n                                        message.exemplars = [];\n                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 8: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a NumberDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NumberDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a NumberDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    NumberDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            properties.value = 1;\n                            if (typeof message.asDouble !== \"number\")\n                                return \"asDouble: number expected\";\n                        }\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))\n                                return \"asInt: integer|Long expected\";\n                        }\n                        if (message.exemplars != null && message.hasOwnProperty(\"exemplars\")) {\n                            if (!Array.isArray(message.exemplars))\n                                return \"exemplars: array expected\";\n                            for (var i = 0; i < message.exemplars.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);\n                                if (error)\n                                    return \"exemplars.\" + error;\n                            }\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a NumberDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint\n                     */\n                    NumberDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.NumberDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.asDouble != null)\n                            message.asDouble = Number(object.asDouble);\n                        if (object.asInt != null)\n                            if ($util.Long)\n                                (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;\n                            else if (typeof object.asInt === \"string\")\n                                message.asInt = parseInt(object.asInt, 10);\n                            else if (typeof object.asInt === \"number\")\n                                message.asInt = object.asInt;\n                            else if (typeof object.asInt === \"object\")\n                                message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();\n                        if (object.exemplars) {\n                            if (!Array.isArray(object.exemplars))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: array expected\");\n                            message.exemplars = [];\n                            for (var i = 0; i < object.exemplars.length; ++i) {\n                                if (typeof object.exemplars[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: object expected\");\n                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);\n                            }\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a NumberDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.NumberDataPoint} message NumberDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    NumberDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.exemplars = [];\n                            object.attributes = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            object.flags = 0;\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;\n                            if (options.oneofs)\n                                object.value = \"asDouble\";\n                        }\n                        if (message.exemplars && message.exemplars.length) {\n                            object.exemplars = [];\n                            for (var j = 0; j < message.exemplars.length; ++j)\n                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);\n                        }\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (typeof message.asInt === \"number\")\n                                object.asInt = options.longs === String ? String(message.asInt) : message.asInt;\n                            else\n                                object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;\n                            if (options.oneofs)\n                                object.value = \"asInt\";\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this NumberDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    NumberDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for NumberDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    NumberDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.NumberDataPoint\";\n                    };\n\n                    return NumberDataPoint;\n                })();\n\n                v1.HistogramDataPoint = (function() {\n\n                    /**\n                     * Properties of a HistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IHistogramDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] HistogramDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] HistogramDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] HistogramDataPoint timeUnixNano\n                     * @property {number|Long|null} [count] HistogramDataPoint count\n                     * @property {number|null} [sum] HistogramDataPoint sum\n                     * @property {Array.<number|Long>|null} [bucketCounts] HistogramDataPoint bucketCounts\n                     * @property {Array.<number>|null} [explicitBounds] HistogramDataPoint explicitBounds\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] HistogramDataPoint exemplars\n                     * @property {number|null} [flags] HistogramDataPoint flags\n                     * @property {number|null} [min] HistogramDataPoint min\n                     * @property {number|null} [max] HistogramDataPoint max\n                     */\n\n                    /**\n                     * Constructs a new HistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a HistogramDataPoint.\n                     * @implements IHistogramDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint=} [properties] Properties to set\n                     */\n                    function HistogramDataPoint(properties) {\n                        this.attributes = [];\n                        this.bucketCounts = [];\n                        this.explicitBounds = [];\n                        this.exemplars = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * HistogramDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * HistogramDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * HistogramDataPoint count.\n                     * @member {number|Long|null|undefined} count\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.count = null;\n\n                    /**\n                     * HistogramDataPoint sum.\n                     * @member {number|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.sum = null;\n\n                    /**\n                     * HistogramDataPoint bucketCounts.\n                     * @member {Array.<number|Long>} bucketCounts\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.bucketCounts = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint explicitBounds.\n                     * @member {Array.<number>} explicitBounds\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.explicitBounds = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint exemplars.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.exemplars = $util.emptyArray;\n\n                    /**\n                     * HistogramDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.flags = null;\n\n                    /**\n                     * HistogramDataPoint min.\n                     * @member {number|null|undefined} min\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.min = null;\n\n                    /**\n                     * HistogramDataPoint max.\n                     * @member {number|null|undefined} max\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     */\n                    HistogramDataPoint.prototype.max = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    // Virtual OneOf for proto3 optional field\n                    Object.defineProperty(HistogramDataPoint.prototype, \"_sum\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"sum\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    // Virtual OneOf for proto3 optional field\n                    Object.defineProperty(HistogramDataPoint.prototype, \"_min\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"min\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    // Virtual OneOf for proto3 optional field\n                    Object.defineProperty(HistogramDataPoint.prototype, \"_max\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"max\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new HistogramDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint instance\n                     */\n                    HistogramDataPoint.create = function create(properties) {\n                        return new HistogramDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified HistogramDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.HistogramDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint} message HistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    HistogramDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.count != null && Object.hasOwnProperty.call(message, \"count\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.count);\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.sum);\n                        if (message.bucketCounts != null && message.bucketCounts.length) {\n                            writer.uint32(/* id 6, wireType 2 =*/50).fork();\n                            for (var i = 0; i < message.bucketCounts.length; ++i)\n                                writer.fixed64(message.bucketCounts[i]);\n                            writer.ldelim();\n                        }\n                        if (message.explicitBounds != null && message.explicitBounds.length) {\n                            writer.uint32(/* id 7, wireType 2 =*/58).fork();\n                            for (var i = 0; i < message.explicitBounds.length; ++i)\n                                writer.double(message.explicitBounds[i]);\n                            writer.ldelim();\n                        }\n                        if (message.exemplars != null && message.exemplars.length)\n                            for (var i = 0; i < message.exemplars.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.flags);\n                        if (message.min != null && Object.hasOwnProperty.call(message, \"min\"))\n                            writer.uint32(/* id 11, wireType 1 =*/89).double(message.min);\n                        if (message.max != null && Object.hasOwnProperty.call(message, \"max\"))\n                            writer.uint32(/* id 12, wireType 1 =*/97).double(message.max);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified HistogramDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.HistogramDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint} message HistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    HistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a HistogramDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    HistogramDataPoint.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 9: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.count = reader.fixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    message.sum = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    if (!(message.bucketCounts && message.bucketCounts.length))\n                                        message.bucketCounts = [];\n                                    if ((tag & 7) === 2) {\n                                        var end2 = reader.uint32() + reader.pos;\n                                        while (reader.pos < end2)\n                                            message.bucketCounts.push(reader.fixed64());\n                                    } else\n                                        message.bucketCounts.push(reader.fixed64());\n                                    break;\n                                }\n                            case 7: {\n                                    if (!(message.explicitBounds && message.explicitBounds.length))\n                                        message.explicitBounds = [];\n                                    if ((tag & 7) === 2) {\n                                        var end2 = reader.uint32() + reader.pos;\n                                        while (reader.pos < end2)\n                                            message.explicitBounds.push(reader.double());\n                                    } else\n                                        message.explicitBounds.push(reader.double());\n                                    break;\n                                }\n                            case 8: {\n                                    if (!(message.exemplars && message.exemplars.length))\n                                        message.exemplars = [];\n                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 10: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            case 11: {\n                                    message.min = reader.double();\n                                    break;\n                                }\n                            case 12: {\n                                    message.max = reader.double();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a HistogramDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    HistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a HistogramDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    HistogramDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                                return \"count: integer|Long expected\";\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            properties._sum = 1;\n                            if (typeof message.sum !== \"number\")\n                                return \"sum: number expected\";\n                        }\n                        if (message.bucketCounts != null && message.hasOwnProperty(\"bucketCounts\")) {\n                            if (!Array.isArray(message.bucketCounts))\n                                return \"bucketCounts: array expected\";\n                            for (var i = 0; i < message.bucketCounts.length; ++i)\n                                if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))\n                                    return \"bucketCounts: integer|Long[] expected\";\n                        }\n                        if (message.explicitBounds != null && message.hasOwnProperty(\"explicitBounds\")) {\n                            if (!Array.isArray(message.explicitBounds))\n                                return \"explicitBounds: array expected\";\n                            for (var i = 0; i < message.explicitBounds.length; ++i)\n                                if (typeof message.explicitBounds[i] !== \"number\")\n                                    return \"explicitBounds: number[] expected\";\n                        }\n                        if (message.exemplars != null && message.hasOwnProperty(\"exemplars\")) {\n                            if (!Array.isArray(message.exemplars))\n                                return \"exemplars: array expected\";\n                            for (var i = 0; i < message.exemplars.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);\n                                if (error)\n                                    return \"exemplars.\" + error;\n                            }\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            properties._min = 1;\n                            if (typeof message.min !== \"number\")\n                                return \"min: number expected\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            properties._max = 1;\n                            if (typeof message.max !== \"number\")\n                                return \"max: number expected\";\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a HistogramDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint\n                     */\n                    HistogramDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.HistogramDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.count != null)\n                            if ($util.Long)\n                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;\n                            else if (typeof object.count === \"string\")\n                                message.count = parseInt(object.count, 10);\n                            else if (typeof object.count === \"number\")\n                                message.count = object.count;\n                            else if (typeof object.count === \"object\")\n                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();\n                        if (object.sum != null)\n                            message.sum = Number(object.sum);\n                        if (object.bucketCounts) {\n                            if (!Array.isArray(object.bucketCounts))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.bucketCounts: array expected\");\n                            message.bucketCounts = [];\n                            for (var i = 0; i < object.bucketCounts.length; ++i)\n                                if ($util.Long)\n                                    (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = false;\n                                else if (typeof object.bucketCounts[i] === \"string\")\n                                    message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);\n                                else if (typeof object.bucketCounts[i] === \"number\")\n                                    message.bucketCounts[i] = object.bucketCounts[i];\n                                else if (typeof object.bucketCounts[i] === \"object\")\n                                    message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber();\n                        }\n                        if (object.explicitBounds) {\n                            if (!Array.isArray(object.explicitBounds))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.explicitBounds: array expected\");\n                            message.explicitBounds = [];\n                            for (var i = 0; i < object.explicitBounds.length; ++i)\n                                message.explicitBounds[i] = Number(object.explicitBounds[i]);\n                        }\n                        if (object.exemplars) {\n                            if (!Array.isArray(object.exemplars))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: array expected\");\n                            message.exemplars = [];\n                            for (var i = 0; i < object.exemplars.length; ++i) {\n                                if (typeof object.exemplars[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: object expected\");\n                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);\n                            }\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        if (object.min != null)\n                            message.min = Number(object.min);\n                        if (object.max != null)\n                            message.max = Number(object.max);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a HistogramDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.HistogramDataPoint} message HistogramDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    HistogramDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.bucketCounts = [];\n                            object.explicitBounds = [];\n                            object.exemplars = [];\n                            object.attributes = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.count = options.longs === String ? \"0\" : 0;\n                            object.flags = 0;\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (typeof message.count === \"number\")\n                                object.count = options.longs === String ? String(message.count) : message.count;\n                            else\n                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;\n                            if (options.oneofs)\n                                object._sum = \"sum\";\n                        }\n                        if (message.bucketCounts && message.bucketCounts.length) {\n                            object.bucketCounts = [];\n                            for (var j = 0; j < message.bucketCounts.length; ++j)\n                                if (typeof message.bucketCounts[j] === \"number\")\n                                    object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];\n                                else\n                                    object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber() : message.bucketCounts[j];\n                        }\n                        if (message.explicitBounds && message.explicitBounds.length) {\n                            object.explicitBounds = [];\n                            for (var j = 0; j < message.explicitBounds.length; ++j)\n                                object.explicitBounds[j] = options.json && !isFinite(message.explicitBounds[j]) ? String(message.explicitBounds[j]) : message.explicitBounds[j];\n                        }\n                        if (message.exemplars && message.exemplars.length) {\n                            object.exemplars = [];\n                            for (var j = 0; j < message.exemplars.length; ++j)\n                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;\n                            if (options.oneofs)\n                                object._min = \"min\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;\n                            if (options.oneofs)\n                                object._max = \"max\";\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this HistogramDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    HistogramDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for HistogramDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    HistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.HistogramDataPoint\";\n                    };\n\n                    return HistogramDataPoint;\n                })();\n\n                v1.ExponentialHistogramDataPoint = (function() {\n\n                    /**\n                     * Properties of an ExponentialHistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IExponentialHistogramDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] ExponentialHistogramDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] ExponentialHistogramDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] ExponentialHistogramDataPoint timeUnixNano\n                     * @property {number|Long|null} [count] ExponentialHistogramDataPoint count\n                     * @property {number|null} [sum] ExponentialHistogramDataPoint sum\n                     * @property {number|null} [scale] ExponentialHistogramDataPoint scale\n                     * @property {number|Long|null} [zeroCount] ExponentialHistogramDataPoint zeroCount\n                     * @property {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null} [positive] ExponentialHistogramDataPoint positive\n                     * @property {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null} [negative] ExponentialHistogramDataPoint negative\n                     * @property {number|null} [flags] ExponentialHistogramDataPoint flags\n                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] ExponentialHistogramDataPoint exemplars\n                     * @property {number|null} [min] ExponentialHistogramDataPoint min\n                     * @property {number|null} [max] ExponentialHistogramDataPoint max\n                     * @property {number|null} [zeroThreshold] ExponentialHistogramDataPoint zeroThreshold\n                     */\n\n                    /**\n                     * Constructs a new ExponentialHistogramDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents an ExponentialHistogramDataPoint.\n                     * @implements IExponentialHistogramDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint=} [properties] Properties to set\n                     */\n                    function ExponentialHistogramDataPoint(properties) {\n                        this.attributes = [];\n                        this.exemplars = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ExponentialHistogramDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * ExponentialHistogramDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint count.\n                     * @member {number|Long|null|undefined} count\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.count = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint sum.\n                     * @member {number|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.sum = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint scale.\n                     * @member {number|null|undefined} scale\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.scale = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint zeroCount.\n                     * @member {number|Long|null|undefined} zeroCount\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.zeroCount = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint positive.\n                     * @member {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null|undefined} positive\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.positive = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint negative.\n                     * @member {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null|undefined} negative\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.negative = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.flags = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint exemplars.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.exemplars = $util.emptyArray;\n\n                    /**\n                     * ExponentialHistogramDataPoint min.\n                     * @member {number|null|undefined} min\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.min = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint max.\n                     * @member {number|null|undefined} max\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.max = null;\n\n                    /**\n                     * ExponentialHistogramDataPoint zeroThreshold.\n                     * @member {number|null|undefined} zeroThreshold\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     */\n                    ExponentialHistogramDataPoint.prototype.zeroThreshold = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    // Virtual OneOf for proto3 optional field\n                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, \"_sum\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"sum\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    // Virtual OneOf for proto3 optional field\n                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, \"_min\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"min\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    // Virtual OneOf for proto3 optional field\n                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, \"_max\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"max\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new ExponentialHistogramDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint instance\n                     */\n                    ExponentialHistogramDataPoint.create = function create(properties) {\n                        return new ExponentialHistogramDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogramDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint} message ExponentialHistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogramDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.count != null && Object.hasOwnProperty.call(message, \"count\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.count);\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.sum);\n                        if (message.scale != null && Object.hasOwnProperty.call(message, \"scale\"))\n                            writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.scale);\n                        if (message.zeroCount != null && Object.hasOwnProperty.call(message, \"zeroCount\"))\n                            writer.uint32(/* id 7, wireType 1 =*/57).fixed64(message.zeroCount);\n                        if (message.positive != null && Object.hasOwnProperty.call(message, \"positive\"))\n                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.positive, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                        if (message.negative != null && Object.hasOwnProperty.call(message, \"negative\"))\n                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.negative, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.flags);\n                        if (message.exemplars != null && message.exemplars.length)\n                            for (var i = 0; i < message.exemplars.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();\n                        if (message.min != null && Object.hasOwnProperty.call(message, \"min\"))\n                            writer.uint32(/* id 12, wireType 1 =*/97).double(message.min);\n                        if (message.max != null && Object.hasOwnProperty.call(message, \"max\"))\n                            writer.uint32(/* id 13, wireType 1 =*/105).double(message.max);\n                        if (message.zeroThreshold != null && Object.hasOwnProperty.call(message, \"zeroThreshold\"))\n                            writer.uint32(/* id 14, wireType 1 =*/113).double(message.zeroThreshold);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ExponentialHistogramDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint} message ExponentialHistogramDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExponentialHistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogramDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogramDataPoint.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.count = reader.fixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    message.sum = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    message.scale = reader.sint32();\n                                    break;\n                                }\n                            case 7: {\n                                    message.zeroCount = reader.fixed64();\n                                    break;\n                                }\n                            case 8: {\n                                    message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 9: {\n                                    message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 10: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            case 11: {\n                                    if (!(message.exemplars && message.exemplars.length))\n                                        message.exemplars = [];\n                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 12: {\n                                    message.min = reader.double();\n                                    break;\n                                }\n                            case 13: {\n                                    message.max = reader.double();\n                                    break;\n                                }\n                            case 14: {\n                                    message.zeroThreshold = reader.double();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an ExponentialHistogramDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExponentialHistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an ExponentialHistogramDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ExponentialHistogramDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                                return \"count: integer|Long expected\";\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            properties._sum = 1;\n                            if (typeof message.sum !== \"number\")\n                                return \"sum: number expected\";\n                        }\n                        if (message.scale != null && message.hasOwnProperty(\"scale\"))\n                            if (!$util.isInteger(message.scale))\n                                return \"scale: integer expected\";\n                        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n                            if (!$util.isInteger(message.zeroCount) && !(message.zeroCount && $util.isInteger(message.zeroCount.low) && $util.isInteger(message.zeroCount.high)))\n                                return \"zeroCount: integer|Long expected\";\n                        if (message.positive != null && message.hasOwnProperty(\"positive\")) {\n                            var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.positive);\n                            if (error)\n                                return \"positive.\" + error;\n                        }\n                        if (message.negative != null && message.hasOwnProperty(\"negative\")) {\n                            var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.negative);\n                            if (error)\n                                return \"negative.\" + error;\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        if (message.exemplars != null && message.hasOwnProperty(\"exemplars\")) {\n                            if (!Array.isArray(message.exemplars))\n                                return \"exemplars: array expected\";\n                            for (var i = 0; i < message.exemplars.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);\n                                if (error)\n                                    return \"exemplars.\" + error;\n                            }\n                        }\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            properties._min = 1;\n                            if (typeof message.min !== \"number\")\n                                return \"min: number expected\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            properties._max = 1;\n                            if (typeof message.max !== \"number\")\n                                return \"max: number expected\";\n                        }\n                        if (message.zeroThreshold != null && message.hasOwnProperty(\"zeroThreshold\"))\n                            if (typeof message.zeroThreshold !== \"number\")\n                                return \"zeroThreshold: number expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates an ExponentialHistogramDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint\n                     */\n                    ExponentialHistogramDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.count != null)\n                            if ($util.Long)\n                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;\n                            else if (typeof object.count === \"string\")\n                                message.count = parseInt(object.count, 10);\n                            else if (typeof object.count === \"number\")\n                                message.count = object.count;\n                            else if (typeof object.count === \"object\")\n                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();\n                        if (object.sum != null)\n                            message.sum = Number(object.sum);\n                        if (object.scale != null)\n                            message.scale = object.scale | 0;\n                        if (object.zeroCount != null)\n                            if ($util.Long)\n                                (message.zeroCount = $util.Long.fromValue(object.zeroCount)).unsigned = false;\n                            else if (typeof object.zeroCount === \"string\")\n                                message.zeroCount = parseInt(object.zeroCount, 10);\n                            else if (typeof object.zeroCount === \"number\")\n                                message.zeroCount = object.zeroCount;\n                            else if (typeof object.zeroCount === \"object\")\n                                message.zeroCount = new $util.LongBits(object.zeroCount.low >>> 0, object.zeroCount.high >>> 0).toNumber();\n                        if (object.positive != null) {\n                            if (typeof object.positive !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.positive: object expected\");\n                            message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.positive);\n                        }\n                        if (object.negative != null) {\n                            if (typeof object.negative !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.negative: object expected\");\n                            message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.negative);\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        if (object.exemplars) {\n                            if (!Array.isArray(object.exemplars))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: array expected\");\n                            message.exemplars = [];\n                            for (var i = 0; i < object.exemplars.length; ++i) {\n                                if (typeof object.exemplars[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: object expected\");\n                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);\n                            }\n                        }\n                        if (object.min != null)\n                            message.min = Number(object.min);\n                        if (object.max != null)\n                            message.max = Number(object.max);\n                        if (object.zeroThreshold != null)\n                            message.zeroThreshold = Number(object.zeroThreshold);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an ExponentialHistogramDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} message ExponentialHistogramDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ExponentialHistogramDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.attributes = [];\n                            object.exemplars = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.count = options.longs === String ? \"0\" : 0;\n                            object.scale = 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.zeroCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.zeroCount = options.longs === String ? \"0\" : 0;\n                            object.positive = null;\n                            object.negative = null;\n                            object.flags = 0;\n                            object.zeroThreshold = 0;\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (typeof message.count === \"number\")\n                                object.count = options.longs === String ? String(message.count) : message.count;\n                            else\n                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;\n                        if (message.sum != null && message.hasOwnProperty(\"sum\")) {\n                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;\n                            if (options.oneofs)\n                                object._sum = \"sum\";\n                        }\n                        if (message.scale != null && message.hasOwnProperty(\"scale\"))\n                            object.scale = message.scale;\n                        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n                            if (typeof message.zeroCount === \"number\")\n                                object.zeroCount = options.longs === String ? String(message.zeroCount) : message.zeroCount;\n                            else\n                                object.zeroCount = options.longs === String ? $util.Long.prototype.toString.call(message.zeroCount) : options.longs === Number ? new $util.LongBits(message.zeroCount.low >>> 0, message.zeroCount.high >>> 0).toNumber() : message.zeroCount;\n                        if (message.positive != null && message.hasOwnProperty(\"positive\"))\n                            object.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.positive, options);\n                        if (message.negative != null && message.hasOwnProperty(\"negative\"))\n                            object.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.negative, options);\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        if (message.exemplars && message.exemplars.length) {\n                            object.exemplars = [];\n                            for (var j = 0; j < message.exemplars.length; ++j)\n                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);\n                        }\n                        if (message.min != null && message.hasOwnProperty(\"min\")) {\n                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;\n                            if (options.oneofs)\n                                object._min = \"min\";\n                        }\n                        if (message.max != null && message.hasOwnProperty(\"max\")) {\n                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;\n                            if (options.oneofs)\n                                object._max = \"max\";\n                        }\n                        if (message.zeroThreshold != null && message.hasOwnProperty(\"zeroThreshold\"))\n                            object.zeroThreshold = options.json && !isFinite(message.zeroThreshold) ? String(message.zeroThreshold) : message.zeroThreshold;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ExponentialHistogramDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ExponentialHistogramDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ExponentialHistogramDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ExponentialHistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\";\n                    };\n\n                    ExponentialHistogramDataPoint.Buckets = (function() {\n\n                        /**\n                         * Properties of a Buckets.\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                         * @interface IBuckets\n                         * @property {number|null} [offset] Buckets offset\n                         * @property {Array.<number|Long>|null} [bucketCounts] Buckets bucketCounts\n                         */\n\n                        /**\n                         * Constructs a new Buckets.\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint\n                         * @classdesc Represents a Buckets.\n                         * @implements IBuckets\n                         * @constructor\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets=} [properties] Properties to set\n                         */\n                        function Buckets(properties) {\n                            this.bucketCounts = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * Buckets offset.\n                         * @member {number|null|undefined} offset\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @instance\n                         */\n                        Buckets.prototype.offset = null;\n\n                        /**\n                         * Buckets bucketCounts.\n                         * @member {Array.<number|Long>} bucketCounts\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @instance\n                         */\n                        Buckets.prototype.bucketCounts = $util.emptyArray;\n\n                        /**\n                         * Creates a new Buckets instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets instance\n                         */\n                        Buckets.create = function create(properties) {\n                            return new Buckets(properties);\n                        };\n\n                        /**\n                         * Encodes the specified Buckets message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets} message Buckets message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Buckets.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.offset);\n                            if (message.bucketCounts != null && message.bucketCounts.length) {\n                                writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                                for (var i = 0; i < message.bucketCounts.length; ++i)\n                                    writer.uint64(message.bucketCounts[i]);\n                                writer.ldelim();\n                            }\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified Buckets message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets} message Buckets message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Buckets.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes a Buckets message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Buckets.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.offset = reader.sint32();\n                                        break;\n                                    }\n                                case 2: {\n                                        if (!(message.bucketCounts && message.bucketCounts.length))\n                                            message.bucketCounts = [];\n                                        if ((tag & 7) === 2) {\n                                            var end2 = reader.uint32() + reader.pos;\n                                            while (reader.pos < end2)\n                                                message.bucketCounts.push(reader.uint64());\n                                        } else\n                                            message.bucketCounts.push(reader.uint64());\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes a Buckets message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Buckets.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies a Buckets message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        Buckets.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                                if (!$util.isInteger(message.offset))\n                                    return \"offset: integer expected\";\n                            if (message.bucketCounts != null && message.hasOwnProperty(\"bucketCounts\")) {\n                                if (!Array.isArray(message.bucketCounts))\n                                    return \"bucketCounts: array expected\";\n                                for (var i = 0; i < message.bucketCounts.length; ++i)\n                                    if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))\n                                        return \"bucketCounts: integer|Long[] expected\";\n                            }\n                            return null;\n                        };\n\n                        /**\n                         * Creates a Buckets message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets\n                         */\n                        Buckets.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets)\n                                return object;\n                            var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();\n                            if (object.offset != null)\n                                message.offset = object.offset | 0;\n                            if (object.bucketCounts) {\n                                if (!Array.isArray(object.bucketCounts))\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.bucketCounts: array expected\");\n                                message.bucketCounts = [];\n                                for (var i = 0; i < object.bucketCounts.length; ++i)\n                                    if ($util.Long)\n                                        (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = true;\n                                    else if (typeof object.bucketCounts[i] === \"string\")\n                                        message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);\n                                    else if (typeof object.bucketCounts[i] === \"number\")\n                                        message.bucketCounts[i] = object.bucketCounts[i];\n                                    else if (typeof object.bucketCounts[i] === \"object\")\n                                        message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber(true);\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from a Buckets message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} message Buckets\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        Buckets.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.arrays || options.defaults)\n                                object.bucketCounts = [];\n                            if (options.defaults)\n                                object.offset = 0;\n                            if (message.offset != null && message.hasOwnProperty(\"offset\"))\n                                object.offset = message.offset;\n                            if (message.bucketCounts && message.bucketCounts.length) {\n                                object.bucketCounts = [];\n                                for (var j = 0; j < message.bucketCounts.length; ++j)\n                                    if (typeof message.bucketCounts[j] === \"number\")\n                                        object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];\n                                    else\n                                        object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber(true) : message.bucketCounts[j];\n                            }\n                            return object;\n                        };\n\n                        /**\n                         * Converts this Buckets to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        Buckets.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for Buckets\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        Buckets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets\";\n                        };\n\n                        return Buckets;\n                    })();\n\n                    return ExponentialHistogramDataPoint;\n                })();\n\n                v1.SummaryDataPoint = (function() {\n\n                    /**\n                     * Properties of a SummaryDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface ISummaryDataPoint\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] SummaryDataPoint attributes\n                     * @property {number|Long|null} [startTimeUnixNano] SummaryDataPoint startTimeUnixNano\n                     * @property {number|Long|null} [timeUnixNano] SummaryDataPoint timeUnixNano\n                     * @property {number|Long|null} [count] SummaryDataPoint count\n                     * @property {number|null} [sum] SummaryDataPoint sum\n                     * @property {Array.<opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile>|null} [quantileValues] SummaryDataPoint quantileValues\n                     * @property {number|null} [flags] SummaryDataPoint flags\n                     */\n\n                    /**\n                     * Constructs a new SummaryDataPoint.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents a SummaryDataPoint.\n                     * @implements ISummaryDataPoint\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint=} [properties] Properties to set\n                     */\n                    function SummaryDataPoint(properties) {\n                        this.attributes = [];\n                        this.quantileValues = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * SummaryDataPoint attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * SummaryDataPoint startTimeUnixNano.\n                     * @member {number|Long|null|undefined} startTimeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.startTimeUnixNano = null;\n\n                    /**\n                     * SummaryDataPoint timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.timeUnixNano = null;\n\n                    /**\n                     * SummaryDataPoint count.\n                     * @member {number|Long|null|undefined} count\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.count = null;\n\n                    /**\n                     * SummaryDataPoint sum.\n                     * @member {number|null|undefined} sum\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.sum = null;\n\n                    /**\n                     * SummaryDataPoint quantileValues.\n                     * @member {Array.<opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile>} quantileValues\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.quantileValues = $util.emptyArray;\n\n                    /**\n                     * SummaryDataPoint flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     */\n                    SummaryDataPoint.prototype.flags = null;\n\n                    /**\n                     * Creates a new SummaryDataPoint instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint instance\n                     */\n                    SummaryDataPoint.create = function create(properties) {\n                        return new SummaryDataPoint(properties);\n                    };\n\n                    /**\n                     * Encodes the specified SummaryDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint} message SummaryDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SummaryDataPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, \"startTimeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.startTimeUnixNano);\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.timeUnixNano);\n                        if (message.count != null && Object.hasOwnProperty.call(message, \"count\"))\n                            writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.count);\n                        if (message.sum != null && Object.hasOwnProperty.call(message, \"sum\"))\n                            writer.uint32(/* id 5, wireType 1 =*/41).double(message.sum);\n                        if (message.quantileValues != null && message.quantileValues.length)\n                            for (var i = 0; i < message.quantileValues.length; ++i)\n                                $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.encode(message.quantileValues[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.flags);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified SummaryDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint} message SummaryDataPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SummaryDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a SummaryDataPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SummaryDataPoint.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 7: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.startTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.count = reader.fixed64();\n                                    break;\n                                }\n                            case 5: {\n                                    message.sum = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    if (!(message.quantileValues && message.quantileValues.length))\n                                        message.quantileValues = [];\n                                    message.quantileValues.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 8: {\n                                    message.flags = reader.uint32();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a SummaryDataPoint message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SummaryDataPoint.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a SummaryDataPoint message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    SummaryDataPoint.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))\n                                return \"startTimeUnixNano: integer|Long expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))\n                                return \"count: integer|Long expected\";\n                        if (message.sum != null && message.hasOwnProperty(\"sum\"))\n                            if (typeof message.sum !== \"number\")\n                                return \"sum: number expected\";\n                        if (message.quantileValues != null && message.hasOwnProperty(\"quantileValues\")) {\n                            if (!Array.isArray(message.quantileValues))\n                                return \"quantileValues: array expected\";\n                            for (var i = 0; i < message.quantileValues.length; ++i) {\n                                var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify(message.quantileValues[i]);\n                                if (error)\n                                    return \"quantileValues.\" + error;\n                            }\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a SummaryDataPoint message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint\n                     */\n                    SummaryDataPoint.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.startTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;\n                            else if (typeof object.startTimeUnixNano === \"string\")\n                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);\n                            else if (typeof object.startTimeUnixNano === \"number\")\n                                message.startTimeUnixNano = object.startTimeUnixNano;\n                            else if (typeof object.startTimeUnixNano === \"object\")\n                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.count != null)\n                            if ($util.Long)\n                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;\n                            else if (typeof object.count === \"string\")\n                                message.count = parseInt(object.count, 10);\n                            else if (typeof object.count === \"number\")\n                                message.count = object.count;\n                            else if (typeof object.count === \"object\")\n                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();\n                        if (object.sum != null)\n                            message.sum = Number(object.sum);\n                        if (object.quantileValues) {\n                            if (!Array.isArray(object.quantileValues))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: array expected\");\n                            message.quantileValues = [];\n                            for (var i = 0; i < object.quantileValues.length; ++i) {\n                                if (typeof object.quantileValues[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: object expected\");\n                                message.quantileValues[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.fromObject(object.quantileValues[i]);\n                            }\n                        }\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a SummaryDataPoint message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint} message SummaryDataPoint\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    SummaryDataPoint.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults) {\n                            object.quantileValues = [];\n                            object.attributes = [];\n                        }\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.startTimeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.count = options.longs === String ? \"0\" : 0;\n                            object.sum = 0;\n                            object.flags = 0;\n                        }\n                        if (message.startTimeUnixNano != null && message.hasOwnProperty(\"startTimeUnixNano\"))\n                            if (typeof message.startTimeUnixNano === \"number\")\n                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;\n                            else\n                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.count != null && message.hasOwnProperty(\"count\"))\n                            if (typeof message.count === \"number\")\n                                object.count = options.longs === String ? String(message.count) : message.count;\n                            else\n                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;\n                        if (message.sum != null && message.hasOwnProperty(\"sum\"))\n                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;\n                        if (message.quantileValues && message.quantileValues.length) {\n                            object.quantileValues = [];\n                            for (var j = 0; j < message.quantileValues.length; ++j)\n                                object.quantileValues[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.toObject(message.quantileValues[j], options);\n                        }\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this SummaryDataPoint to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    SummaryDataPoint.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for SummaryDataPoint\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    SummaryDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.SummaryDataPoint\";\n                    };\n\n                    SummaryDataPoint.ValueAtQuantile = (function() {\n\n                        /**\n                         * Properties of a ValueAtQuantile.\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                         * @interface IValueAtQuantile\n                         * @property {number|null} [quantile] ValueAtQuantile quantile\n                         * @property {number|null} [value] ValueAtQuantile value\n                         */\n\n                        /**\n                         * Constructs a new ValueAtQuantile.\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint\n                         * @classdesc Represents a ValueAtQuantile.\n                         * @implements IValueAtQuantile\n                         * @constructor\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile=} [properties] Properties to set\n                         */\n                        function ValueAtQuantile(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n\n                        /**\n                         * ValueAtQuantile quantile.\n                         * @member {number|null|undefined} quantile\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @instance\n                         */\n                        ValueAtQuantile.prototype.quantile = null;\n\n                        /**\n                         * ValueAtQuantile value.\n                         * @member {number|null|undefined} value\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @instance\n                         */\n                        ValueAtQuantile.prototype.value = null;\n\n                        /**\n                         * Creates a new ValueAtQuantile instance using the specified properties.\n                         * @function create\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile=} [properties] Properties to set\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile instance\n                         */\n                        ValueAtQuantile.create = function create(properties) {\n                            return new ValueAtQuantile(properties);\n                        };\n\n                        /**\n                         * Encodes the specified ValueAtQuantile message. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify|verify} messages.\n                         * @function encode\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile} message ValueAtQuantile message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ValueAtQuantile.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.quantile != null && Object.hasOwnProperty.call(message, \"quantile\"))\n                                writer.uint32(/* id 1, wireType 1 =*/9).double(message.quantile);\n                            if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n                                writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);\n                            return writer;\n                        };\n\n                        /**\n                         * Encodes the specified ValueAtQuantile message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify|verify} messages.\n                         * @function encodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile} message ValueAtQuantile message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ValueAtQuantile.encodeDelimited = function encodeDelimited(message, writer) {\n                            return this.encode(message, writer).ldelim();\n                        };\n\n                        /**\n                         * Decodes a ValueAtQuantile message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ValueAtQuantile.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1: {\n                                        message.quantile = reader.double();\n                                        break;\n                                    }\n                                case 2: {\n                                        message.value = reader.double();\n                                        break;\n                                    }\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n\n                        /**\n                         * Decodes a ValueAtQuantile message from the specified reader or buffer, length delimited.\n                         * @function decodeDelimited\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ValueAtQuantile.decodeDelimited = function decodeDelimited(reader) {\n                            if (!(reader instanceof $Reader))\n                                reader = new $Reader(reader);\n                            return this.decode(reader, reader.uint32());\n                        };\n\n                        /**\n                         * Verifies a ValueAtQuantile message.\n                         * @function verify\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {Object.<string,*>} message Plain object to verify\n                         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                         */\n                        ValueAtQuantile.verify = function verify(message) {\n                            if (typeof message !== \"object\" || message === null)\n                                return \"object expected\";\n                            if (message.quantile != null && message.hasOwnProperty(\"quantile\"))\n                                if (typeof message.quantile !== \"number\")\n                                    return \"quantile: number expected\";\n                            if (message.value != null && message.hasOwnProperty(\"value\"))\n                                if (typeof message.value !== \"number\")\n                                    return \"value: number expected\";\n                            return null;\n                        };\n\n                        /**\n                         * Creates a ValueAtQuantile message from a plain object. Also converts values to their respective internal types.\n                         * @function fromObject\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {Object.<string,*>} object Plain object\n                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile\n                         */\n                        ValueAtQuantile.fromObject = function fromObject(object) {\n                            if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile)\n                                return object;\n                            var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();\n                            if (object.quantile != null)\n                                message.quantile = Number(object.quantile);\n                            if (object.value != null)\n                                message.value = Number(object.value);\n                            return message;\n                        };\n\n                        /**\n                         * Creates a plain object from a ValueAtQuantile message. Also converts values to other types if specified.\n                         * @function toObject\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} message ValueAtQuantile\n                         * @param {$protobuf.IConversionOptions} [options] Conversion options\n                         * @returns {Object.<string,*>} Plain object\n                         */\n                        ValueAtQuantile.toObject = function toObject(message, options) {\n                            if (!options)\n                                options = {};\n                            var object = {};\n                            if (options.defaults) {\n                                object.quantile = 0;\n                                object.value = 0;\n                            }\n                            if (message.quantile != null && message.hasOwnProperty(\"quantile\"))\n                                object.quantile = options.json && !isFinite(message.quantile) ? String(message.quantile) : message.quantile;\n                            if (message.value != null && message.hasOwnProperty(\"value\"))\n                                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n                            return object;\n                        };\n\n                        /**\n                         * Converts this ValueAtQuantile to JSON.\n                         * @function toJSON\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @instance\n                         * @returns {Object.<string,*>} JSON object\n                         */\n                        ValueAtQuantile.prototype.toJSON = function toJSON() {\n                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                        };\n\n                        /**\n                         * Gets the default type url for ValueAtQuantile\n                         * @function getTypeUrl\n                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\n                         * @static\n                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                         * @returns {string} The default type url\n                         */\n                        ValueAtQuantile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                            if (typeUrlPrefix === undefined) {\n                                typeUrlPrefix = \"type.googleapis.com\";\n                            }\n                            return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile\";\n                        };\n\n                        return ValueAtQuantile;\n                    })();\n\n                    return SummaryDataPoint;\n                })();\n\n                v1.Exemplar = (function() {\n\n                    /**\n                     * Properties of an Exemplar.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @interface IExemplar\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [filteredAttributes] Exemplar filteredAttributes\n                     * @property {number|Long|null} [timeUnixNano] Exemplar timeUnixNano\n                     * @property {number|null} [asDouble] Exemplar asDouble\n                     * @property {number|Long|null} [asInt] Exemplar asInt\n                     * @property {Uint8Array|null} [spanId] Exemplar spanId\n                     * @property {Uint8Array|null} [traceId] Exemplar traceId\n                     */\n\n                    /**\n                     * Constructs a new Exemplar.\n                     * @memberof opentelemetry.proto.metrics.v1\n                     * @classdesc Represents an Exemplar.\n                     * @implements IExemplar\n                     * @constructor\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar=} [properties] Properties to set\n                     */\n                    function Exemplar(properties) {\n                        this.filteredAttributes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * Exemplar filteredAttributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} filteredAttributes\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.filteredAttributes = $util.emptyArray;\n\n                    /**\n                     * Exemplar timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.timeUnixNano = null;\n\n                    /**\n                     * Exemplar asDouble.\n                     * @member {number|null|undefined} asDouble\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.asDouble = null;\n\n                    /**\n                     * Exemplar asInt.\n                     * @member {number|Long|null|undefined} asInt\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.asInt = null;\n\n                    /**\n                     * Exemplar spanId.\n                     * @member {Uint8Array|null|undefined} spanId\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.spanId = null;\n\n                    /**\n                     * Exemplar traceId.\n                     * @member {Uint8Array|null|undefined} traceId\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Exemplar.prototype.traceId = null;\n\n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n\n                    /**\n                     * Exemplar value.\n                     * @member {\"asDouble\"|\"asInt\"|undefined} value\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     */\n                    Object.defineProperty(Exemplar.prototype, \"value\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"asDouble\", \"asInt\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n\n                    /**\n                     * Creates a new Exemplar instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar instance\n                     */\n                    Exemplar.create = function create(properties) {\n                        return new Exemplar(properties);\n                    };\n\n                    /**\n                     * Encodes the specified Exemplar message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Exemplar.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar} message Exemplar message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Exemplar.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.timeUnixNano);\n                        if (message.asDouble != null && Object.hasOwnProperty.call(message, \"asDouble\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).double(message.asDouble);\n                        if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.spanId);\n                        if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                            writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.traceId);\n                        if (message.asInt != null && Object.hasOwnProperty.call(message, \"asInt\"))\n                            writer.uint32(/* id 6, wireType 1 =*/49).sfixed64(message.asInt);\n                        if (message.filteredAttributes != null && message.filteredAttributes.length)\n                            for (var i = 0; i < message.filteredAttributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.filteredAttributes[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified Exemplar message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Exemplar.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.IExemplar} message Exemplar message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Exemplar.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes an Exemplar message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Exemplar.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Exemplar();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 7: {\n                                    if (!(message.filteredAttributes && message.filteredAttributes.length))\n                                        message.filteredAttributes = [];\n                                    message.filteredAttributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 2: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 3: {\n                                    message.asDouble = reader.double();\n                                    break;\n                                }\n                            case 6: {\n                                    message.asInt = reader.sfixed64();\n                                    break;\n                                }\n                            case 4: {\n                                    message.spanId = reader.bytes();\n                                    break;\n                                }\n                            case 5: {\n                                    message.traceId = reader.bytes();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes an Exemplar message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Exemplar.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies an Exemplar message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    Exemplar.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        var properties = {};\n                        if (message.filteredAttributes != null && message.hasOwnProperty(\"filteredAttributes\")) {\n                            if (!Array.isArray(message.filteredAttributes))\n                                return \"filteredAttributes: array expected\";\n                            for (var i = 0; i < message.filteredAttributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.filteredAttributes[i]);\n                                if (error)\n                                    return \"filteredAttributes.\" + error;\n                            }\n                        }\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            properties.value = 1;\n                            if (typeof message.asDouble !== \"number\")\n                                return \"asDouble: number expected\";\n                        }\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (properties.value === 1)\n                                return \"value: multiple values\";\n                            properties.value = 1;\n                            if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))\n                                return \"asInt: integer|Long expected\";\n                        }\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                return \"spanId: buffer expected\";\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                return \"traceId: buffer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates an Exemplar message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar\n                     */\n                    Exemplar.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Exemplar)\n                            return object;\n                        var message = new $root.opentelemetry.proto.metrics.v1.Exemplar();\n                        if (object.filteredAttributes) {\n                            if (!Array.isArray(object.filteredAttributes))\n                                throw TypeError(\".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: array expected\");\n                            message.filteredAttributes = [];\n                            for (var i = 0; i < object.filteredAttributes.length; ++i) {\n                                if (typeof object.filteredAttributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: object expected\");\n                                message.filteredAttributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.filteredAttributes[i]);\n                            }\n                        }\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.asDouble != null)\n                            message.asDouble = Number(object.asDouble);\n                        if (object.asInt != null)\n                            if ($util.Long)\n                                (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;\n                            else if (typeof object.asInt === \"string\")\n                                message.asInt = parseInt(object.asInt, 10);\n                            else if (typeof object.asInt === \"number\")\n                                message.asInt = object.asInt;\n                            else if (typeof object.asInt === \"object\")\n                                message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();\n                        if (object.spanId != null)\n                            if (typeof object.spanId === \"string\")\n                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                            else if (object.spanId.length >= 0)\n                                message.spanId = object.spanId;\n                        if (object.traceId != null)\n                            if (typeof object.traceId === \"string\")\n                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                            else if (object.traceId.length >= 0)\n                                message.traceId = object.traceId;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from an Exemplar message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {opentelemetry.proto.metrics.v1.Exemplar} message Exemplar\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    Exemplar.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.filteredAttributes = [];\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            if (options.bytes === String)\n                                object.spanId = \"\";\n                            else {\n                                object.spanId = [];\n                                if (options.bytes !== Array)\n                                    object.spanId = $util.newBuffer(object.spanId);\n                            }\n                            if (options.bytes === String)\n                                object.traceId = \"\";\n                            else {\n                                object.traceId = [];\n                                if (options.bytes !== Array)\n                                    object.traceId = $util.newBuffer(object.traceId);\n                            }\n                        }\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.asDouble != null && message.hasOwnProperty(\"asDouble\")) {\n                            object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;\n                            if (options.oneofs)\n                                object.value = \"asDouble\";\n                        }\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                        if (message.asInt != null && message.hasOwnProperty(\"asInt\")) {\n                            if (typeof message.asInt === \"number\")\n                                object.asInt = options.longs === String ? String(message.asInt) : message.asInt;\n                            else\n                                object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;\n                            if (options.oneofs)\n                                object.value = \"asInt\";\n                        }\n                        if (message.filteredAttributes && message.filteredAttributes.length) {\n                            object.filteredAttributes = [];\n                            for (var j = 0; j < message.filteredAttributes.length; ++j)\n                                object.filteredAttributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.filteredAttributes[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this Exemplar to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    Exemplar.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for Exemplar\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.metrics.v1.Exemplar\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    Exemplar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.metrics.v1.Exemplar\";\n                    };\n\n                    return Exemplar;\n                })();\n\n                return v1;\n            })();\n\n            return metrics;\n        })();\n\n        proto.logs = (function() {\n\n            /**\n             * Namespace logs.\n             * @memberof opentelemetry.proto\n             * @namespace\n             */\n            var logs = {};\n\n            logs.v1 = (function() {\n\n                /**\n                 * Namespace v1.\n                 * @memberof opentelemetry.proto.logs\n                 * @namespace\n                 */\n                var v1 = {};\n\n                v1.LogsData = (function() {\n\n                    /**\n                     * Properties of a LogsData.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface ILogsData\n                     * @property {Array.<opentelemetry.proto.logs.v1.IResourceLogs>|null} [resourceLogs] LogsData resourceLogs\n                     */\n\n                    /**\n                     * Constructs a new LogsData.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a LogsData.\n                     * @implements ILogsData\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.ILogsData=} [properties] Properties to set\n                     */\n                    function LogsData(properties) {\n                        this.resourceLogs = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * LogsData resourceLogs.\n                     * @member {Array.<opentelemetry.proto.logs.v1.IResourceLogs>} resourceLogs\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @instance\n                     */\n                    LogsData.prototype.resourceLogs = $util.emptyArray;\n\n                    /**\n                     * Creates a new LogsData instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogsData=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData instance\n                     */\n                    LogsData.create = function create(properties) {\n                        return new LogsData(properties);\n                    };\n\n                    /**\n                     * Encodes the specified LogsData message. Does not implicitly {@link opentelemetry.proto.logs.v1.LogsData.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogsData} message LogsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogsData.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resourceLogs != null && message.resourceLogs.length)\n                            for (var i = 0; i < message.resourceLogs.length; ++i)\n                                $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified LogsData message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.LogsData.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogsData} message LogsData message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogsData.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a LogsData message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogsData.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogsData();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    if (!(message.resourceLogs && message.resourceLogs.length))\n                                        message.resourceLogs = [];\n                                    message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a LogsData message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogsData.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a LogsData message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    LogsData.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resourceLogs != null && message.hasOwnProperty(\"resourceLogs\")) {\n                            if (!Array.isArray(message.resourceLogs))\n                                return \"resourceLogs: array expected\";\n                            for (var i = 0; i < message.resourceLogs.length; ++i) {\n                                var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);\n                                if (error)\n                                    return \"resourceLogs.\" + error;\n                            }\n                        }\n                        return null;\n                    };\n\n                    /**\n                     * Creates a LogsData message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData\n                     */\n                    LogsData.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.LogsData)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.LogsData();\n                        if (object.resourceLogs) {\n                            if (!Array.isArray(object.resourceLogs))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.LogsData.resourceLogs: array expected\");\n                            message.resourceLogs = [];\n                            for (var i = 0; i < object.resourceLogs.length; ++i) {\n                                if (typeof object.resourceLogs[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.LogsData.resourceLogs: object expected\");\n                                message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a LogsData message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.LogsData} message LogsData\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    LogsData.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.resourceLogs = [];\n                        if (message.resourceLogs && message.resourceLogs.length) {\n                            object.resourceLogs = [];\n                            for (var j = 0; j < message.resourceLogs.length; ++j)\n                                object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);\n                        }\n                        return object;\n                    };\n\n                    /**\n                     * Converts this LogsData to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    LogsData.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for LogsData\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.LogsData\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    LogsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.LogsData\";\n                    };\n\n                    return LogsData;\n                })();\n\n                v1.ResourceLogs = (function() {\n\n                    /**\n                     * Properties of a ResourceLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface IResourceLogs\n                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceLogs resource\n                     * @property {Array.<opentelemetry.proto.logs.v1.IScopeLogs>|null} [scopeLogs] ResourceLogs scopeLogs\n                     * @property {string|null} [schemaUrl] ResourceLogs schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ResourceLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a ResourceLogs.\n                     * @implements IResourceLogs\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs=} [properties] Properties to set\n                     */\n                    function ResourceLogs(properties) {\n                        this.scopeLogs = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ResourceLogs resource.\n                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     */\n                    ResourceLogs.prototype.resource = null;\n\n                    /**\n                     * ResourceLogs scopeLogs.\n                     * @member {Array.<opentelemetry.proto.logs.v1.IScopeLogs>} scopeLogs\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     */\n                    ResourceLogs.prototype.scopeLogs = $util.emptyArray;\n\n                    /**\n                     * ResourceLogs schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     */\n                    ResourceLogs.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ResourceLogs instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs instance\n                     */\n                    ResourceLogs.create = function create(properties) {\n                        return new ResourceLogs(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ResourceLogs message. Does not implicitly {@link opentelemetry.proto.logs.v1.ResourceLogs.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs} message ResourceLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceLogs.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.resource != null && Object.hasOwnProperty.call(message, \"resource\"))\n                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.scopeLogs != null && message.scopeLogs.length)\n                            for (var i = 0; i < message.scopeLogs.length; ++i)\n                                $root.opentelemetry.proto.logs.v1.ScopeLogs.encode(message.scopeLogs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ResourceLogs message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.ResourceLogs.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IResourceLogs} message ResourceLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResourceLogs.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ResourceLogs message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceLogs.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.scopeLogs && message.scopeLogs.length))\n                                        message.scopeLogs = [];\n                                    message.scopeLogs.push($root.opentelemetry.proto.logs.v1.ScopeLogs.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ResourceLogs message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResourceLogs.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ResourceLogs message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ResourceLogs.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.resource != null && message.hasOwnProperty(\"resource\")) {\n                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);\n                            if (error)\n                                return \"resource.\" + error;\n                        }\n                        if (message.scopeLogs != null && message.hasOwnProperty(\"scopeLogs\")) {\n                            if (!Array.isArray(message.scopeLogs))\n                                return \"scopeLogs: array expected\";\n                            for (var i = 0; i < message.scopeLogs.length; ++i) {\n                                var error = $root.opentelemetry.proto.logs.v1.ScopeLogs.verify(message.scopeLogs[i]);\n                                if (error)\n                                    return \"scopeLogs.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ResourceLogs message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs\n                     */\n                    ResourceLogs.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.ResourceLogs)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();\n                        if (object.resource != null) {\n                            if (typeof object.resource !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ResourceLogs.resource: object expected\");\n                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);\n                        }\n                        if (object.scopeLogs) {\n                            if (!Array.isArray(object.scopeLogs))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: array expected\");\n                            message.scopeLogs = [];\n                            for (var i = 0; i < object.scopeLogs.length; ++i) {\n                                if (typeof object.scopeLogs[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: object expected\");\n                                message.scopeLogs[i] = $root.opentelemetry.proto.logs.v1.ScopeLogs.fromObject(object.scopeLogs[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ResourceLogs message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ResourceLogs} message ResourceLogs\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ResourceLogs.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.scopeLogs = [];\n                        if (options.defaults) {\n                            object.resource = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.resource != null && message.hasOwnProperty(\"resource\"))\n                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);\n                        if (message.scopeLogs && message.scopeLogs.length) {\n                            object.scopeLogs = [];\n                            for (var j = 0; j < message.scopeLogs.length; ++j)\n                                object.scopeLogs[j] = $root.opentelemetry.proto.logs.v1.ScopeLogs.toObject(message.scopeLogs[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ResourceLogs to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ResourceLogs.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ResourceLogs\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ResourceLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.ResourceLogs\";\n                    };\n\n                    return ResourceLogs;\n                })();\n\n                v1.ScopeLogs = (function() {\n\n                    /**\n                     * Properties of a ScopeLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface IScopeLogs\n                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeLogs scope\n                     * @property {Array.<opentelemetry.proto.logs.v1.ILogRecord>|null} [logRecords] ScopeLogs logRecords\n                     * @property {string|null} [schemaUrl] ScopeLogs schemaUrl\n                     */\n\n                    /**\n                     * Constructs a new ScopeLogs.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a ScopeLogs.\n                     * @implements IScopeLogs\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs=} [properties] Properties to set\n                     */\n                    function ScopeLogs(properties) {\n                        this.logRecords = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * ScopeLogs scope.\n                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     */\n                    ScopeLogs.prototype.scope = null;\n\n                    /**\n                     * ScopeLogs logRecords.\n                     * @member {Array.<opentelemetry.proto.logs.v1.ILogRecord>} logRecords\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     */\n                    ScopeLogs.prototype.logRecords = $util.emptyArray;\n\n                    /**\n                     * ScopeLogs schemaUrl.\n                     * @member {string|null|undefined} schemaUrl\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     */\n                    ScopeLogs.prototype.schemaUrl = null;\n\n                    /**\n                     * Creates a new ScopeLogs instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs instance\n                     */\n                    ScopeLogs.create = function create(properties) {\n                        return new ScopeLogs(properties);\n                    };\n\n                    /**\n                     * Encodes the specified ScopeLogs message. Does not implicitly {@link opentelemetry.proto.logs.v1.ScopeLogs.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs} message ScopeLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeLogs.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.scope != null && Object.hasOwnProperty.call(message, \"scope\"))\n                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        if (message.logRecords != null && message.logRecords.length)\n                            for (var i = 0; i < message.logRecords.length; ++i)\n                                $root.opentelemetry.proto.logs.v1.LogRecord.encode(message.logRecords[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, \"schemaUrl\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.schemaUrl);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified ScopeLogs message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.ScopeLogs.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.IScopeLogs} message ScopeLogs message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScopeLogs.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a ScopeLogs message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeLogs.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 2: {\n                                    if (!(message.logRecords && message.logRecords.length))\n                                        message.logRecords = [];\n                                    message.logRecords.push($root.opentelemetry.proto.logs.v1.LogRecord.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 3: {\n                                    message.schemaUrl = reader.string();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a ScopeLogs message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScopeLogs.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a ScopeLogs message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    ScopeLogs.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.scope != null && message.hasOwnProperty(\"scope\")) {\n                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);\n                            if (error)\n                                return \"scope.\" + error;\n                        }\n                        if (message.logRecords != null && message.hasOwnProperty(\"logRecords\")) {\n                            if (!Array.isArray(message.logRecords))\n                                return \"logRecords: array expected\";\n                            for (var i = 0; i < message.logRecords.length; ++i) {\n                                var error = $root.opentelemetry.proto.logs.v1.LogRecord.verify(message.logRecords[i]);\n                                if (error)\n                                    return \"logRecords.\" + error;\n                            }\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            if (!$util.isString(message.schemaUrl))\n                                return \"schemaUrl: string expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a ScopeLogs message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs\n                     */\n                    ScopeLogs.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.ScopeLogs)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();\n                        if (object.scope != null) {\n                            if (typeof object.scope !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ScopeLogs.scope: object expected\");\n                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);\n                        }\n                        if (object.logRecords) {\n                            if (!Array.isArray(object.logRecords))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: array expected\");\n                            message.logRecords = [];\n                            for (var i = 0; i < object.logRecords.length; ++i) {\n                                if (typeof object.logRecords[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: object expected\");\n                                message.logRecords[i] = $root.opentelemetry.proto.logs.v1.LogRecord.fromObject(object.logRecords[i]);\n                            }\n                        }\n                        if (object.schemaUrl != null)\n                            message.schemaUrl = String(object.schemaUrl);\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a ScopeLogs message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ScopeLogs} message ScopeLogs\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    ScopeLogs.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.logRecords = [];\n                        if (options.defaults) {\n                            object.scope = null;\n                            object.schemaUrl = \"\";\n                        }\n                        if (message.scope != null && message.hasOwnProperty(\"scope\"))\n                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);\n                        if (message.logRecords && message.logRecords.length) {\n                            object.logRecords = [];\n                            for (var j = 0; j < message.logRecords.length; ++j)\n                                object.logRecords[j] = $root.opentelemetry.proto.logs.v1.LogRecord.toObject(message.logRecords[j], options);\n                        }\n                        if (message.schemaUrl != null && message.hasOwnProperty(\"schemaUrl\"))\n                            object.schemaUrl = message.schemaUrl;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this ScopeLogs to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    ScopeLogs.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for ScopeLogs\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    ScopeLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.ScopeLogs\";\n                    };\n\n                    return ScopeLogs;\n                })();\n\n                /**\n                 * SeverityNumber enum.\n                 * @name opentelemetry.proto.logs.v1.SeverityNumber\n                 * @enum {number}\n                 * @property {number} SEVERITY_NUMBER_UNSPECIFIED=0 SEVERITY_NUMBER_UNSPECIFIED value\n                 * @property {number} SEVERITY_NUMBER_TRACE=1 SEVERITY_NUMBER_TRACE value\n                 * @property {number} SEVERITY_NUMBER_TRACE2=2 SEVERITY_NUMBER_TRACE2 value\n                 * @property {number} SEVERITY_NUMBER_TRACE3=3 SEVERITY_NUMBER_TRACE3 value\n                 * @property {number} SEVERITY_NUMBER_TRACE4=4 SEVERITY_NUMBER_TRACE4 value\n                 * @property {number} SEVERITY_NUMBER_DEBUG=5 SEVERITY_NUMBER_DEBUG value\n                 * @property {number} SEVERITY_NUMBER_DEBUG2=6 SEVERITY_NUMBER_DEBUG2 value\n                 * @property {number} SEVERITY_NUMBER_DEBUG3=7 SEVERITY_NUMBER_DEBUG3 value\n                 * @property {number} SEVERITY_NUMBER_DEBUG4=8 SEVERITY_NUMBER_DEBUG4 value\n                 * @property {number} SEVERITY_NUMBER_INFO=9 SEVERITY_NUMBER_INFO value\n                 * @property {number} SEVERITY_NUMBER_INFO2=10 SEVERITY_NUMBER_INFO2 value\n                 * @property {number} SEVERITY_NUMBER_INFO3=11 SEVERITY_NUMBER_INFO3 value\n                 * @property {number} SEVERITY_NUMBER_INFO4=12 SEVERITY_NUMBER_INFO4 value\n                 * @property {number} SEVERITY_NUMBER_WARN=13 SEVERITY_NUMBER_WARN value\n                 * @property {number} SEVERITY_NUMBER_WARN2=14 SEVERITY_NUMBER_WARN2 value\n                 * @property {number} SEVERITY_NUMBER_WARN3=15 SEVERITY_NUMBER_WARN3 value\n                 * @property {number} SEVERITY_NUMBER_WARN4=16 SEVERITY_NUMBER_WARN4 value\n                 * @property {number} SEVERITY_NUMBER_ERROR=17 SEVERITY_NUMBER_ERROR value\n                 * @property {number} SEVERITY_NUMBER_ERROR2=18 SEVERITY_NUMBER_ERROR2 value\n                 * @property {number} SEVERITY_NUMBER_ERROR3=19 SEVERITY_NUMBER_ERROR3 value\n                 * @property {number} SEVERITY_NUMBER_ERROR4=20 SEVERITY_NUMBER_ERROR4 value\n                 * @property {number} SEVERITY_NUMBER_FATAL=21 SEVERITY_NUMBER_FATAL value\n                 * @property {number} SEVERITY_NUMBER_FATAL2=22 SEVERITY_NUMBER_FATAL2 value\n                 * @property {number} SEVERITY_NUMBER_FATAL3=23 SEVERITY_NUMBER_FATAL3 value\n                 * @property {number} SEVERITY_NUMBER_FATAL4=24 SEVERITY_NUMBER_FATAL4 value\n                 */\n                v1.SeverityNumber = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"SEVERITY_NUMBER_UNSPECIFIED\"] = 0;\n                    values[valuesById[1] = \"SEVERITY_NUMBER_TRACE\"] = 1;\n                    values[valuesById[2] = \"SEVERITY_NUMBER_TRACE2\"] = 2;\n                    values[valuesById[3] = \"SEVERITY_NUMBER_TRACE3\"] = 3;\n                    values[valuesById[4] = \"SEVERITY_NUMBER_TRACE4\"] = 4;\n                    values[valuesById[5] = \"SEVERITY_NUMBER_DEBUG\"] = 5;\n                    values[valuesById[6] = \"SEVERITY_NUMBER_DEBUG2\"] = 6;\n                    values[valuesById[7] = \"SEVERITY_NUMBER_DEBUG3\"] = 7;\n                    values[valuesById[8] = \"SEVERITY_NUMBER_DEBUG4\"] = 8;\n                    values[valuesById[9] = \"SEVERITY_NUMBER_INFO\"] = 9;\n                    values[valuesById[10] = \"SEVERITY_NUMBER_INFO2\"] = 10;\n                    values[valuesById[11] = \"SEVERITY_NUMBER_INFO3\"] = 11;\n                    values[valuesById[12] = \"SEVERITY_NUMBER_INFO4\"] = 12;\n                    values[valuesById[13] = \"SEVERITY_NUMBER_WARN\"] = 13;\n                    values[valuesById[14] = \"SEVERITY_NUMBER_WARN2\"] = 14;\n                    values[valuesById[15] = \"SEVERITY_NUMBER_WARN3\"] = 15;\n                    values[valuesById[16] = \"SEVERITY_NUMBER_WARN4\"] = 16;\n                    values[valuesById[17] = \"SEVERITY_NUMBER_ERROR\"] = 17;\n                    values[valuesById[18] = \"SEVERITY_NUMBER_ERROR2\"] = 18;\n                    values[valuesById[19] = \"SEVERITY_NUMBER_ERROR3\"] = 19;\n                    values[valuesById[20] = \"SEVERITY_NUMBER_ERROR4\"] = 20;\n                    values[valuesById[21] = \"SEVERITY_NUMBER_FATAL\"] = 21;\n                    values[valuesById[22] = \"SEVERITY_NUMBER_FATAL2\"] = 22;\n                    values[valuesById[23] = \"SEVERITY_NUMBER_FATAL3\"] = 23;\n                    values[valuesById[24] = \"SEVERITY_NUMBER_FATAL4\"] = 24;\n                    return values;\n                })();\n\n                /**\n                 * LogRecordFlags enum.\n                 * @name opentelemetry.proto.logs.v1.LogRecordFlags\n                 * @enum {number}\n                 * @property {number} LOG_RECORD_FLAGS_DO_NOT_USE=0 LOG_RECORD_FLAGS_DO_NOT_USE value\n                 * @property {number} LOG_RECORD_FLAGS_TRACE_FLAGS_MASK=255 LOG_RECORD_FLAGS_TRACE_FLAGS_MASK value\n                 */\n                v1.LogRecordFlags = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"LOG_RECORD_FLAGS_DO_NOT_USE\"] = 0;\n                    values[valuesById[255] = \"LOG_RECORD_FLAGS_TRACE_FLAGS_MASK\"] = 255;\n                    return values;\n                })();\n\n                v1.LogRecord = (function() {\n\n                    /**\n                     * Properties of a LogRecord.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @interface ILogRecord\n                     * @property {number|Long|null} [timeUnixNano] LogRecord timeUnixNano\n                     * @property {number|Long|null} [observedTimeUnixNano] LogRecord observedTimeUnixNano\n                     * @property {opentelemetry.proto.logs.v1.SeverityNumber|null} [severityNumber] LogRecord severityNumber\n                     * @property {string|null} [severityText] LogRecord severityText\n                     * @property {opentelemetry.proto.common.v1.IAnyValue|null} [body] LogRecord body\n                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] LogRecord attributes\n                     * @property {number|null} [droppedAttributesCount] LogRecord droppedAttributesCount\n                     * @property {number|null} [flags] LogRecord flags\n                     * @property {Uint8Array|null} [traceId] LogRecord traceId\n                     * @property {Uint8Array|null} [spanId] LogRecord spanId\n                     */\n\n                    /**\n                     * Constructs a new LogRecord.\n                     * @memberof opentelemetry.proto.logs.v1\n                     * @classdesc Represents a LogRecord.\n                     * @implements ILogRecord\n                     * @constructor\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord=} [properties] Properties to set\n                     */\n                    function LogRecord(properties) {\n                        this.attributes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n\n                    /**\n                     * LogRecord timeUnixNano.\n                     * @member {number|Long|null|undefined} timeUnixNano\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.timeUnixNano = null;\n\n                    /**\n                     * LogRecord observedTimeUnixNano.\n                     * @member {number|Long|null|undefined} observedTimeUnixNano\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.observedTimeUnixNano = null;\n\n                    /**\n                     * LogRecord severityNumber.\n                     * @member {opentelemetry.proto.logs.v1.SeverityNumber|null|undefined} severityNumber\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.severityNumber = null;\n\n                    /**\n                     * LogRecord severityText.\n                     * @member {string|null|undefined} severityText\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.severityText = null;\n\n                    /**\n                     * LogRecord body.\n                     * @member {opentelemetry.proto.common.v1.IAnyValue|null|undefined} body\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.body = null;\n\n                    /**\n                     * LogRecord attributes.\n                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.attributes = $util.emptyArray;\n\n                    /**\n                     * LogRecord droppedAttributesCount.\n                     * @member {number|null|undefined} droppedAttributesCount\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.droppedAttributesCount = null;\n\n                    /**\n                     * LogRecord flags.\n                     * @member {number|null|undefined} flags\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.flags = null;\n\n                    /**\n                     * LogRecord traceId.\n                     * @member {Uint8Array|null|undefined} traceId\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.traceId = null;\n\n                    /**\n                     * LogRecord spanId.\n                     * @member {Uint8Array|null|undefined} spanId\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     */\n                    LogRecord.prototype.spanId = null;\n\n                    /**\n                     * Creates a new LogRecord instance using the specified properties.\n                     * @function create\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord=} [properties] Properties to set\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord instance\n                     */\n                    LogRecord.create = function create(properties) {\n                        return new LogRecord(properties);\n                    };\n\n                    /**\n                     * Encodes the specified LogRecord message. Does not implicitly {@link opentelemetry.proto.logs.v1.LogRecord.verify|verify} messages.\n                     * @function encode\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord} message LogRecord message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogRecord.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, \"timeUnixNano\"))\n                            writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.timeUnixNano);\n                        if (message.severityNumber != null && Object.hasOwnProperty.call(message, \"severityNumber\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.severityNumber);\n                        if (message.severityText != null && Object.hasOwnProperty.call(message, \"severityText\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.severityText);\n                        if (message.body != null && Object.hasOwnProperty.call(message, \"body\"))\n                            $root.opentelemetry.proto.common.v1.AnyValue.encode(message.body, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.attributes != null && message.attributes.length)\n                            for (var i = 0; i < message.attributes.length; ++i)\n                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, \"droppedAttributesCount\"))\n                            writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.droppedAttributesCount);\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 8, wireType 5 =*/69).fixed32(message.flags);\n                        if (message.traceId != null && Object.hasOwnProperty.call(message, \"traceId\"))\n                            writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.traceId);\n                        if (message.spanId != null && Object.hasOwnProperty.call(message, \"spanId\"))\n                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.spanId);\n                        if (message.observedTimeUnixNano != null && Object.hasOwnProperty.call(message, \"observedTimeUnixNano\"))\n                            writer.uint32(/* id 11, wireType 1 =*/89).fixed64(message.observedTimeUnixNano);\n                        return writer;\n                    };\n\n                    /**\n                     * Encodes the specified LogRecord message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.LogRecord.verify|verify} messages.\n                     * @function encodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.ILogRecord} message LogRecord message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogRecord.encodeDelimited = function encodeDelimited(message, writer) {\n                        return this.encode(message, writer).ldelim();\n                    };\n\n                    /**\n                     * Decodes a LogRecord message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogRecord.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogRecord();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1: {\n                                    message.timeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 11: {\n                                    message.observedTimeUnixNano = reader.fixed64();\n                                    break;\n                                }\n                            case 2: {\n                                    message.severityNumber = reader.int32();\n                                    break;\n                                }\n                            case 3: {\n                                    message.severityText = reader.string();\n                                    break;\n                                }\n                            case 5: {\n                                    message.body = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());\n                                    break;\n                                }\n                            case 6: {\n                                    if (!(message.attributes && message.attributes.length))\n                                        message.attributes = [];\n                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));\n                                    break;\n                                }\n                            case 7: {\n                                    message.droppedAttributesCount = reader.uint32();\n                                    break;\n                                }\n                            case 8: {\n                                    message.flags = reader.fixed32();\n                                    break;\n                                }\n                            case 9: {\n                                    message.traceId = reader.bytes();\n                                    break;\n                                }\n                            case 10: {\n                                    message.spanId = reader.bytes();\n                                    break;\n                                }\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n\n                    /**\n                     * Decodes a LogRecord message from the specified reader or buffer, length delimited.\n                     * @function decodeDelimited\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogRecord.decodeDelimited = function decodeDelimited(reader) {\n                        if (!(reader instanceof $Reader))\n                            reader = new $Reader(reader);\n                        return this.decode(reader, reader.uint32());\n                    };\n\n                    /**\n                     * Verifies a LogRecord message.\n                     * @function verify\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {Object.<string,*>} message Plain object to verify\n                     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                     */\n                    LogRecord.verify = function verify(message) {\n                        if (typeof message !== \"object\" || message === null)\n                            return \"object expected\";\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))\n                                return \"timeUnixNano: integer|Long expected\";\n                        if (message.observedTimeUnixNano != null && message.hasOwnProperty(\"observedTimeUnixNano\"))\n                            if (!$util.isInteger(message.observedTimeUnixNano) && !(message.observedTimeUnixNano && $util.isInteger(message.observedTimeUnixNano.low) && $util.isInteger(message.observedTimeUnixNano.high)))\n                                return \"observedTimeUnixNano: integer|Long expected\";\n                        if (message.severityNumber != null && message.hasOwnProperty(\"severityNumber\"))\n                            switch (message.severityNumber) {\n                            default:\n                                return \"severityNumber: enum value expected\";\n                            case 0:\n                            case 1:\n                            case 2:\n                            case 3:\n                            case 4:\n                            case 5:\n                            case 6:\n                            case 7:\n                            case 8:\n                            case 9:\n                            case 10:\n                            case 11:\n                            case 12:\n                            case 13:\n                            case 14:\n                            case 15:\n                            case 16:\n                            case 17:\n                            case 18:\n                            case 19:\n                            case 20:\n                            case 21:\n                            case 22:\n                            case 23:\n                            case 24:\n                                break;\n                            }\n                        if (message.severityText != null && message.hasOwnProperty(\"severityText\"))\n                            if (!$util.isString(message.severityText))\n                                return \"severityText: string expected\";\n                        if (message.body != null && message.hasOwnProperty(\"body\")) {\n                            var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.body);\n                            if (error)\n                                return \"body.\" + error;\n                        }\n                        if (message.attributes != null && message.hasOwnProperty(\"attributes\")) {\n                            if (!Array.isArray(message.attributes))\n                                return \"attributes: array expected\";\n                            for (var i = 0; i < message.attributes.length; ++i) {\n                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);\n                                if (error)\n                                    return \"attributes.\" + error;\n                            }\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            if (!$util.isInteger(message.droppedAttributesCount))\n                                return \"droppedAttributesCount: integer expected\";\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            if (!$util.isInteger(message.flags))\n                                return \"flags: integer expected\";\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            if (!(message.traceId && typeof message.traceId.length === \"number\" || $util.isString(message.traceId)))\n                                return \"traceId: buffer expected\";\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            if (!(message.spanId && typeof message.spanId.length === \"number\" || $util.isString(message.spanId)))\n                                return \"spanId: buffer expected\";\n                        return null;\n                    };\n\n                    /**\n                     * Creates a LogRecord message from a plain object. Also converts values to their respective internal types.\n                     * @function fromObject\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {Object.<string,*>} object Plain object\n                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord\n                     */\n                    LogRecord.fromObject = function fromObject(object) {\n                        if (object instanceof $root.opentelemetry.proto.logs.v1.LogRecord)\n                            return object;\n                        var message = new $root.opentelemetry.proto.logs.v1.LogRecord();\n                        if (object.timeUnixNano != null)\n                            if ($util.Long)\n                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;\n                            else if (typeof object.timeUnixNano === \"string\")\n                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);\n                            else if (typeof object.timeUnixNano === \"number\")\n                                message.timeUnixNano = object.timeUnixNano;\n                            else if (typeof object.timeUnixNano === \"object\")\n                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();\n                        if (object.observedTimeUnixNano != null)\n                            if ($util.Long)\n                                (message.observedTimeUnixNano = $util.Long.fromValue(object.observedTimeUnixNano)).unsigned = false;\n                            else if (typeof object.observedTimeUnixNano === \"string\")\n                                message.observedTimeUnixNano = parseInt(object.observedTimeUnixNano, 10);\n                            else if (typeof object.observedTimeUnixNano === \"number\")\n                                message.observedTimeUnixNano = object.observedTimeUnixNano;\n                            else if (typeof object.observedTimeUnixNano === \"object\")\n                                message.observedTimeUnixNano = new $util.LongBits(object.observedTimeUnixNano.low >>> 0, object.observedTimeUnixNano.high >>> 0).toNumber();\n                        switch (object.severityNumber) {\n                        default:\n                            if (typeof object.severityNumber === \"number\") {\n                                message.severityNumber = object.severityNumber;\n                                break;\n                            }\n                            break;\n                        case \"SEVERITY_NUMBER_UNSPECIFIED\":\n                        case 0:\n                            message.severityNumber = 0;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE\":\n                        case 1:\n                            message.severityNumber = 1;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE2\":\n                        case 2:\n                            message.severityNumber = 2;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE3\":\n                        case 3:\n                            message.severityNumber = 3;\n                            break;\n                        case \"SEVERITY_NUMBER_TRACE4\":\n                        case 4:\n                            message.severityNumber = 4;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG\":\n                        case 5:\n                            message.severityNumber = 5;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG2\":\n                        case 6:\n                            message.severityNumber = 6;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG3\":\n                        case 7:\n                            message.severityNumber = 7;\n                            break;\n                        case \"SEVERITY_NUMBER_DEBUG4\":\n                        case 8:\n                            message.severityNumber = 8;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO\":\n                        case 9:\n                            message.severityNumber = 9;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO2\":\n                        case 10:\n                            message.severityNumber = 10;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO3\":\n                        case 11:\n                            message.severityNumber = 11;\n                            break;\n                        case \"SEVERITY_NUMBER_INFO4\":\n                        case 12:\n                            message.severityNumber = 12;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN\":\n                        case 13:\n                            message.severityNumber = 13;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN2\":\n                        case 14:\n                            message.severityNumber = 14;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN3\":\n                        case 15:\n                            message.severityNumber = 15;\n                            break;\n                        case \"SEVERITY_NUMBER_WARN4\":\n                        case 16:\n                            message.severityNumber = 16;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR\":\n                        case 17:\n                            message.severityNumber = 17;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR2\":\n                        case 18:\n                            message.severityNumber = 18;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR3\":\n                        case 19:\n                            message.severityNumber = 19;\n                            break;\n                        case \"SEVERITY_NUMBER_ERROR4\":\n                        case 20:\n                            message.severityNumber = 20;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL\":\n                        case 21:\n                            message.severityNumber = 21;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL2\":\n                        case 22:\n                            message.severityNumber = 22;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL3\":\n                        case 23:\n                            message.severityNumber = 23;\n                            break;\n                        case \"SEVERITY_NUMBER_FATAL4\":\n                        case 24:\n                            message.severityNumber = 24;\n                            break;\n                        }\n                        if (object.severityText != null)\n                            message.severityText = String(object.severityText);\n                        if (object.body != null) {\n                            if (typeof object.body !== \"object\")\n                                throw TypeError(\".opentelemetry.proto.logs.v1.LogRecord.body: object expected\");\n                            message.body = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.body);\n                        }\n                        if (object.attributes) {\n                            if (!Array.isArray(object.attributes))\n                                throw TypeError(\".opentelemetry.proto.logs.v1.LogRecord.attributes: array expected\");\n                            message.attributes = [];\n                            for (var i = 0; i < object.attributes.length; ++i) {\n                                if (typeof object.attributes[i] !== \"object\")\n                                    throw TypeError(\".opentelemetry.proto.logs.v1.LogRecord.attributes: object expected\");\n                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);\n                            }\n                        }\n                        if (object.droppedAttributesCount != null)\n                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;\n                        if (object.flags != null)\n                            message.flags = object.flags >>> 0;\n                        if (object.traceId != null)\n                            if (typeof object.traceId === \"string\")\n                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);\n                            else if (object.traceId.length >= 0)\n                                message.traceId = object.traceId;\n                        if (object.spanId != null)\n                            if (typeof object.spanId === \"string\")\n                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);\n                            else if (object.spanId.length >= 0)\n                                message.spanId = object.spanId;\n                        return message;\n                    };\n\n                    /**\n                     * Creates a plain object from a LogRecord message. Also converts values to other types if specified.\n                     * @function toObject\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {opentelemetry.proto.logs.v1.LogRecord} message LogRecord\n                     * @param {$protobuf.IConversionOptions} [options] Conversion options\n                     * @returns {Object.<string,*>} Plain object\n                     */\n                    LogRecord.toObject = function toObject(message, options) {\n                        if (!options)\n                            options = {};\n                        var object = {};\n                        if (options.arrays || options.defaults)\n                            object.attributes = [];\n                        if (options.defaults) {\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.timeUnixNano = options.longs === String ? \"0\" : 0;\n                            object.severityNumber = options.enums === String ? \"SEVERITY_NUMBER_UNSPECIFIED\" : 0;\n                            object.severityText = \"\";\n                            object.body = null;\n                            object.droppedAttributesCount = 0;\n                            object.flags = 0;\n                            if (options.bytes === String)\n                                object.traceId = \"\";\n                            else {\n                                object.traceId = [];\n                                if (options.bytes !== Array)\n                                    object.traceId = $util.newBuffer(object.traceId);\n                            }\n                            if (options.bytes === String)\n                                object.spanId = \"\";\n                            else {\n                                object.spanId = [];\n                                if (options.bytes !== Array)\n                                    object.spanId = $util.newBuffer(object.spanId);\n                            }\n                            if ($util.Long) {\n                                var long = new $util.Long(0, 0, false);\n                                object.observedTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n                            } else\n                                object.observedTimeUnixNano = options.longs === String ? \"0\" : 0;\n                        }\n                        if (message.timeUnixNano != null && message.hasOwnProperty(\"timeUnixNano\"))\n                            if (typeof message.timeUnixNano === \"number\")\n                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;\n                            else\n                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;\n                        if (message.severityNumber != null && message.hasOwnProperty(\"severityNumber\"))\n                            object.severityNumber = options.enums === String ? $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] === undefined ? message.severityNumber : $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] : message.severityNumber;\n                        if (message.severityText != null && message.hasOwnProperty(\"severityText\"))\n                            object.severityText = message.severityText;\n                        if (message.body != null && message.hasOwnProperty(\"body\"))\n                            object.body = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.body, options);\n                        if (message.attributes && message.attributes.length) {\n                            object.attributes = [];\n                            for (var j = 0; j < message.attributes.length; ++j)\n                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);\n                        }\n                        if (message.droppedAttributesCount != null && message.hasOwnProperty(\"droppedAttributesCount\"))\n                            object.droppedAttributesCount = message.droppedAttributesCount;\n                        if (message.flags != null && message.hasOwnProperty(\"flags\"))\n                            object.flags = message.flags;\n                        if (message.traceId != null && message.hasOwnProperty(\"traceId\"))\n                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;\n                        if (message.spanId != null && message.hasOwnProperty(\"spanId\"))\n                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;\n                        if (message.observedTimeUnixNano != null && message.hasOwnProperty(\"observedTimeUnixNano\"))\n                            if (typeof message.observedTimeUnixNano === \"number\")\n                                object.observedTimeUnixNano = options.longs === String ? String(message.observedTimeUnixNano) : message.observedTimeUnixNano;\n                            else\n                                object.observedTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.observedTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.observedTimeUnixNano.low >>> 0, message.observedTimeUnixNano.high >>> 0).toNumber() : message.observedTimeUnixNano;\n                        return object;\n                    };\n\n                    /**\n                     * Converts this LogRecord to JSON.\n                     * @function toJSON\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @instance\n                     * @returns {Object.<string,*>} JSON object\n                     */\n                    LogRecord.prototype.toJSON = function toJSON() {\n                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                    };\n\n                    /**\n                     * Gets the default type url for LogRecord\n                     * @function getTypeUrl\n                     * @memberof opentelemetry.proto.logs.v1.LogRecord\n                     * @static\n                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default \"type.googleapis.com\")\n                     * @returns {string} The default type url\n                     */\n                    LogRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n                        if (typeUrlPrefix === undefined) {\n                            typeUrlPrefix = \"type.googleapis.com\";\n                        }\n                        return typeUrlPrefix + \"/opentelemetry.proto.logs.v1.LogRecord\";\n                    };\n\n                    return LogRecord;\n                })();\n\n                return v1;\n            })();\n\n            return logs;\n        })();\n\n        return proto;\n    })();\n\n    return opentelemetry;\n})();\n\nmodule.exports = $root;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResult } from '@opentelemetry/core';\nimport { IOtlpExportDelegate } from './otlp-export-delegate';\n\nexport class OTLPExporterBase<Internal> {\n  constructor(private _delegate: IOtlpExportDelegate<Internal>) {}\n\n  /**\n   * Export items.\n   * @param items\n   * @param resultCallback\n   */\n  export(\n    items: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    this._delegate.export(items, resultCallback);\n  }\n\n  forceFlush(): Promise<void> {\n    return this._delegate.forceFlush();\n  }\n\n  shutdown(): Promise<void> {\n    return this._delegate.shutdown();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Interface for handling error\n */\nexport class OTLPExporterError extends Error {\n  readonly code?: number;\n  override readonly name: string = 'OTLPExporterError';\n  readonly data?: string;\n\n  constructor(message?: string, code?: number, data?: string) {\n    super(message);\n    this.data = data;\n    this.code = code;\n  }\n}\n\n/**\n * Interface for handling export service errors\n */\nexport interface ExportServiceError {\n  name: string;\n  code: number;\n  details: string;\n  metadata: { [key: string]: unknown };\n  message: string;\n  stack: string;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Configuration shared across all OTLP exporters\n *\n * Implementation note: anything added here MUST be\n * - platform-agnostic\n * - signal-agnostic\n * - transport-agnostic\n */\nexport interface OtlpSharedConfiguration {\n  timeoutMillis: number;\n  concurrencyLimit: number;\n  compression: 'gzip' | 'none';\n}\n\nexport function validateTimeoutMillis(timeoutMillis: number) {\n  if (\n    !Number.isNaN(timeoutMillis) &&\n    Number.isFinite(timeoutMillis) &&\n    timeoutMillis > 0\n  ) {\n    return timeoutMillis;\n  }\n  throw new Error(\n    `Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '${timeoutMillis}')`\n  );\n}\n\nexport function wrapStaticHeadersInFunction(\n  headers: Record<string, string> | undefined\n): (() => Record<string, string>) | undefined {\n  if (headers == null) {\n    return undefined;\n  }\n\n  return () => headers;\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpSharedConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpSharedConfiguration>,\n  fallbackConfiguration: Partial<OtlpSharedConfiguration>,\n  defaultConfiguration: OtlpSharedConfiguration\n): OtlpSharedConfiguration {\n  return {\n    timeoutMillis: validateTimeoutMillis(\n      userProvidedConfiguration.timeoutMillis ??\n        fallbackConfiguration.timeoutMillis ??\n        defaultConfiguration.timeoutMillis\n    ),\n    concurrencyLimit:\n      userProvidedConfiguration.concurrencyLimit ??\n      fallbackConfiguration.concurrencyLimit ??\n      defaultConfiguration.concurrencyLimit,\n    compression:\n      userProvidedConfiguration.compression ??\n      fallbackConfiguration.compression ??\n      defaultConfiguration.compression,\n  };\n}\n\nexport function getSharedConfigurationDefaults(): OtlpSharedConfiguration {\n  return {\n    timeoutMillis: 10000,\n    concurrencyLimit: 30,\n    compression: 'none',\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTE: do not change these imports to be actual imports, otherwise they WILL break `@opentelemetry/instrumentation-http`\nimport type * as http from 'http';\nimport type * as https from 'https';\n\nimport { OTLPExporterConfigBase } from './legacy-base-configuration';\n\n/**\n * Collector Exporter node base config\n */\nexport interface OTLPExporterNodeConfigBase extends OTLPExporterConfigBase {\n  keepAlive?: boolean;\n  compression?: CompressionAlgorithm;\n  httpAgentOptions?: http.AgentOptions | https.AgentOptions;\n}\n\nexport enum CompressionAlgorithm {\n  NONE = 'none',\n  GZIP = 'gzip',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface IExportPromiseHandler {\n  pushPromise(promise: Promise<void>): void;\n  hasReachedLimit(): boolean;\n  awaitAll(): Promise<void>;\n}\n\nclass BoundedQueueExportPromiseHandler implements IExportPromiseHandler {\n  private readonly _concurrencyLimit: number;\n  private _sendingPromises: Promise<unknown>[] = [];\n\n  /**\n   * @param concurrencyLimit maximum promises allowed in a queue at the same time.\n   */\n  constructor(concurrencyLimit: number) {\n    this._concurrencyLimit = concurrencyLimit;\n  }\n\n  public pushPromise(promise: Promise<void>): void {\n    if (this.hasReachedLimit()) {\n      throw new Error('Concurrency Limit reached');\n    }\n\n    this._sendingPromises.push(promise);\n    const popPromise = () => {\n      const index = this._sendingPromises.indexOf(promise);\n      this._sendingPromises.splice(index, 1);\n    };\n    promise.then(popPromise, popPromise);\n  }\n\n  public hasReachedLimit(): boolean {\n    return this._sendingPromises.length >= this._concurrencyLimit;\n  }\n\n  public async awaitAll(): Promise<void> {\n    await Promise.all(this._sendingPromises);\n  }\n}\n\n/**\n * Promise queue for keeping track of export promises. Finished promises will be auto-dequeued.\n * Allows for awaiting all promises in the queue.\n */\nexport function createBoundedQueueExportPromiseHandler(options: {\n  concurrencyLimit: number;\n}): IExportPromiseHandler {\n  return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { IOtlpResponseHandler } from './response-handler';\n\nfunction isPartialSuccessResponse(\n  response: unknown\n): response is { partialSuccess: never } {\n  return Object.prototype.hasOwnProperty.call(response, 'partialSuccess');\n}\n\n/**\n * Default response handler that logs a partial success to the console.\n */\nexport function createLoggingPartialSuccessResponseHandler<\n  T,\n>(): IOtlpResponseHandler<T> {\n  return {\n    handleResponse(response: T) {\n      // Partial success MUST never be an empty object according the specification\n      // see https://opentelemetry.io/docs/specs/otlp/#partial-success\n      if (\n        response == null ||\n        !isPartialSuccessResponse(response) ||\n        response.partialSuccess == null ||\n        Object.keys(response.partialSuccess).length === 0\n      ) {\n        return;\n      }\n      diag.warn(\n        'Received Partial Success response:',\n        JSON.stringify(response.partialSuccess)\n      );\n    },\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\nimport { IExporterTransport } from './exporter-transport';\nimport { IExportPromiseHandler } from './bounded-queue-export-promise-handler';\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport { OTLPExporterError } from './types';\nimport { IOtlpResponseHandler } from './response-handler';\nimport { createLoggingPartialSuccessResponseHandler } from './logging-response-handler';\nimport { diag, DiagLogger } from '@opentelemetry/api';\n\n/**\n * Internally shared export logic for OTLP.\n */\nexport interface IOtlpExportDelegate<Internal> {\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void;\n  forceFlush(): Promise<void>;\n  shutdown(): Promise<void>;\n}\n\nclass OTLPExportDelegate<Internal, Response>\n  implements IOtlpExportDelegate<Internal>\n{\n  private _diagLogger: DiagLogger;\n  constructor(\n    private _transport: IExporterTransport,\n    private _serializer: ISerializer<Internal, Response>,\n    private _responseHandler: IOtlpResponseHandler<Response>,\n    private _promiseQueue: IExportPromiseHandler,\n    private _timeout: number\n  ) {\n    this._diagLogger = diag.createComponentLogger({\n      namespace: 'OTLPExportDelegate',\n    });\n  }\n\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    this._diagLogger.debug('items to be sent', internalRepresentation);\n\n    // don't do any work if too many exports are in progress.\n    if (this._promiseQueue.hasReachedLimit()) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Concurrent export limit reached'),\n      });\n      return;\n    }\n\n    const serializedRequest = this._serializer.serializeRequest(\n      internalRepresentation\n    );\n\n    if (serializedRequest == null) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Nothing to send'),\n      });\n      return;\n    }\n\n    this._promiseQueue.pushPromise(\n      this._transport.send(serializedRequest, this._timeout).then(\n        response => {\n          if (response.status === 'success') {\n            if (response.data != null) {\n              try {\n                this._responseHandler.handleResponse(\n                  this._serializer.deserializeResponse(response.data)\n                );\n              } catch (e) {\n                this._diagLogger.warn(\n                  'Export succeeded but could not deserialize response - is the response specification compliant?',\n                  e,\n                  response.data\n                );\n              }\n            }\n            // No matter the response, we can consider the export still successful.\n            resultCallback({\n              code: ExportResultCode.SUCCESS,\n            });\n            return;\n          } else if (response.status === 'failure' && response.error) {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: response.error,\n            });\n            return;\n          } else if (response.status === 'retryable') {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: new OTLPExporterError(\n                'Export failed with retryable status'\n              ),\n            });\n          } else {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: new OTLPExporterError('Export failed with unknown error'),\n            });\n          }\n        },\n        reason =>\n          resultCallback({\n            code: ExportResultCode.FAILED,\n            error: reason,\n          })\n      )\n    );\n  }\n\n  forceFlush(): Promise<void> {\n    return this._promiseQueue.awaitAll();\n  }\n\n  async shutdown(): Promise<void> {\n    this._diagLogger.debug('shutdown started');\n    await this.forceFlush();\n    this._transport.shutdown();\n  }\n}\n\n/**\n * Creates a generic delegate for OTLP exports which only contains parts of the OTLP export that are shared across all\n * signals.\n */\nexport function createOtlpExportDelegate<Internal, Response>(\n  components: {\n    transport: IExporterTransport;\n    serializer: ISerializer<Internal, Response>;\n    promiseHandler: IExportPromiseHandler;\n  },\n  settings: { timeout: number }\n): IOtlpExportDelegate<Internal> {\n  return new OTLPExportDelegate(\n    components.transport,\n    components.serializer,\n    createLoggingPartialSuccessResponseHandler(),\n    components.promiseHandler,\n    settings.timeout\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createBoundedQueueExportPromiseHandler } from './bounded-queue-export-promise-handler';\nimport { OtlpSharedConfiguration } from './configuration/shared-configuration';\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport { IExporterTransport } from './exporter-transport';\nimport {\n  createOtlpExportDelegate,\n  IOtlpExportDelegate,\n} from './otlp-export-delegate';\n\nexport function createOtlpNetworkExportDelegate<Internal, Response>(\n  options: OtlpSharedConfiguration,\n  serializer: ISerializer<Internal, Response>,\n  transport: IExporterTransport\n): IOtlpExportDelegate<Internal> {\n  return createOtlpExportDelegate(\n    {\n      transport: transport,\n      serializer,\n      promiseHandler: createBoundedQueueExportPromiseHandler(options),\n    },\n    { timeout: options.timeoutMillis }\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OtlpEncodingOptions, Fixed64, LongBits } from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { hexToBinary, hrTimeToNanoseconds } from '@opentelemetry/core';\n\nexport function hrTimeToNanos(hrTime: HrTime): bigint {\n  const NANOSECONDS = BigInt(1_000_000_000);\n  return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);\n}\n\nexport function toLongBits(value: bigint): LongBits {\n  const low = Number(BigInt.asUintN(32, value));\n  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return { low, high };\n}\n\nexport function encodeAsLongBits(hrTime: HrTime): LongBits {\n  const nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\n\nexport function encodeAsString(hrTime: HrTime): string {\n  const nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\n\nconst encodeTimestamp =\n  typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\n\nexport type HrTimeEncodeFunction = (hrTime: HrTime) => Fixed64;\nexport type SpanContextEncodeFunction = (\n  spanContext: string\n) => string | Uint8Array;\nexport type OptionalSpanContextEncodeFunction = (\n  spanContext: string | undefined\n) => string | Uint8Array | undefined;\n\nexport interface Encoder {\n  encodeHrTime: HrTimeEncodeFunction;\n  encodeSpanContext: SpanContextEncodeFunction;\n  encodeOptionalSpanContext: OptionalSpanContextEncodeFunction;\n}\n\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nfunction optionalHexToBinary(str: string | undefined): Uint8Array | undefined {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\n\nconst DEFAULT_ENCODER: Encoder = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary,\n};\n\nexport function getOtlpEncoder(options?: OtlpEncodingOptions): Encoder {\n  if (options === undefined) {\n    return DEFAULT_ENCODER;\n  }\n\n  const useLongBits = options.useLongBits ?? true;\n  const useHex = options.useHex ?? false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary,\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Fixed64, IInstrumentationScope, IKeyValue } from '../common/types';\nimport { IResource } from '../resource/types';\n\n/** Properties of an ExportTraceServiceRequest. */\nexport interface IExportTraceServiceRequest {\n  /** ExportTraceServiceRequest resourceSpans */\n  resourceSpans?: IResourceSpans[];\n}\n\nexport interface IExportTraceServiceResponse {\n  /** ExportTraceServiceResponse partialSuccess */\n  partialSuccess?: IExportTracePartialSuccess;\n}\n\nexport interface IExportTracePartialSuccess {\n  /** ExportLogsServiceResponse rejectedLogRecords */\n  rejectedSpans?: number;\n\n  /** ExportLogsServiceResponse errorMessage */\n  errorMessage?: string;\n}\n\n/** Properties of a ResourceSpans. */\nexport interface IResourceSpans {\n  /** ResourceSpans resource */\n  resource?: IResource;\n\n  /** ResourceSpans scopeSpans */\n  scopeSpans: IScopeSpans[];\n\n  /** ResourceSpans schemaUrl */\n  schemaUrl?: string;\n}\n\n/** Properties of an ScopeSpans. */\nexport interface IScopeSpans {\n  /** IScopeSpans scope */\n  scope?: IInstrumentationScope;\n\n  /** IScopeSpans spans */\n  spans?: ISpan[];\n\n  /** IScopeSpans schemaUrl */\n  schemaUrl?: string | null;\n}\n\n/** Properties of a Span. */\nexport interface ISpan {\n  /** Span traceId */\n  traceId: string | Uint8Array;\n\n  /** Span spanId */\n  spanId: string | Uint8Array;\n\n  /** Span traceState */\n  traceState?: string | null;\n\n  /** Span parentSpanId */\n  parentSpanId?: string | Uint8Array;\n\n  /** Span name */\n  name: string;\n\n  /** Span kind */\n  kind: ESpanKind;\n\n  /** Span startTimeUnixNano */\n  startTimeUnixNano: Fixed64;\n\n  /** Span endTimeUnixNano */\n  endTimeUnixNano: Fixed64;\n\n  /** Span attributes */\n  attributes: IKeyValue[];\n\n  /** Span droppedAttributesCount */\n  droppedAttributesCount: number;\n\n  /** Span events */\n  events: IEvent[];\n\n  /** Span droppedEventsCount */\n  droppedEventsCount: number;\n\n  /** Span links */\n  links: ILink[];\n\n  /** Span droppedLinksCount */\n  droppedLinksCount: number;\n\n  /** Span status */\n  status: IStatus;\n}\n\n/**\n * SpanKind is the type of span. Can be used to specify additional relationships between spans\n * in addition to a parent/child relationship.\n */\nexport enum ESpanKind {\n  /** Unspecified. Do NOT use as default. Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED. */\n  SPAN_KIND_UNSPECIFIED = 0,\n\n  /** Indicates that the span represents an internal operation within an application,\n   * as opposed to an operation happening at the boundaries. Default value.\n   */\n  SPAN_KIND_INTERNAL = 1,\n\n  /** Indicates that the span covers server-side handling of an RPC or other\n   * remote network request.\n   */\n  SPAN_KIND_SERVER = 2,\n\n  /** Indicates that the span describes a request to some remote service.\n   */\n  SPAN_KIND_CLIENT = 3,\n\n  /** Indicates that the span describes a producer sending a message to a broker.\n   * Unlike CLIENT and SERVER, there is often no direct critical path latency relationship\n   * between producer and consumer spans. A PRODUCER span ends when the message was accepted\n   * by the broker while the logical processing of the message might span a much longer time.\n   */\n  SPAN_KIND_PRODUCER = 4,\n\n  /** Indicates that the span describes consumer receiving a message from a broker.\n   * Like the PRODUCER kind, there is often no direct critical path latency relationship\n   * between producer and consumer spans.\n   */\n  SPAN_KIND_CONSUMER = 5,\n}\n\n/** Properties of a Status. */\nexport interface IStatus {\n  /** Status message */\n  message?: string;\n\n  /** Status code */\n  code: EStatusCode;\n}\n\n/** StatusCode enum. */\nexport const enum EStatusCode {\n  /** The default status. */\n  STATUS_CODE_UNSET = 0,\n  /** The Span has been evaluated by an Application developers or Operator to have completed successfully. */\n  STATUS_CODE_OK = 1,\n  /** The Span contains an error. */\n  STATUS_CODE_ERROR = 2,\n}\n\n/** Properties of an Event. */\nexport interface IEvent {\n  /** Event timeUnixNano */\n  timeUnixNano: Fixed64;\n\n  /** Event name */\n  name: string;\n\n  /** Event attributes */\n  attributes: IKeyValue[];\n\n  /** Event droppedAttributesCount */\n  droppedAttributesCount: number;\n}\n\n/** Properties of a Link. */\nexport interface ILink {\n  /** Link traceId */\n  traceId: string | Uint8Array;\n\n  /** Link spanId */\n  spanId: string | Uint8Array;\n\n  /** Link traceState */\n  traceState?: string;\n\n  /** Link attributes */\n  attributes: IKeyValue[];\n\n  /** Link droppedAttributesCount */\n  droppedAttributesCount: number;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { IAnyValue, IInstrumentationScope, IKeyValue } from './types';\nimport { Attributes } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\n\nexport function createInstrumentationScope(\n  scope: InstrumentationScope\n): IInstrumentationScope {\n  return {\n    name: scope.name,\n    version: scope.version,\n  };\n}\n\nexport function toAttributes(attributes: Attributes): IKeyValue[] {\n  return Object.keys(attributes).map(key => toKeyValue(key, attributes[key]));\n}\n\nexport function toKeyValue(key: string, value: unknown): IKeyValue {\n  return {\n    key: key,\n    value: toAnyValue(value),\n  };\n}\n\nexport function toAnyValue(value: unknown): IAnyValue {\n  const t = typeof value;\n  if (t === 'string') return { stringValue: value as string };\n  if (t === 'number') {\n    if (!Number.isInteger(value)) return { doubleValue: value as number };\n    return { intValue: value as number };\n  }\n  if (t === 'boolean') return { boolValue: value as boolean };\n  if (value instanceof Uint8Array) return { bytesValue: value };\n  if (Array.isArray(value))\n    return { arrayValue: { values: value.map(toAnyValue) } };\n  if (t === 'object' && value != null)\n    return {\n      kvlistValue: {\n        values: Object.entries(value as object).map(([k, v]) =>\n          toKeyValue(k, v)\n        ),\n      },\n    };\n\n  return {};\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Link } from '@opentelemetry/api';\nimport type { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base';\nimport type { Encoder } from '../common';\nimport { toAttributes } from '../common/internal';\nimport { EStatusCode, IEvent, ILink, ISpan } from './types';\n\nexport function sdkSpanToOtlpSpan(span: ReadableSpan, encoder: Encoder): ISpan {\n  const ctx = span.spanContext();\n  const status = span.status;\n  return {\n    traceId: encoder.encodeSpanContext(ctx.traceId),\n    spanId: encoder.encodeSpanContext(ctx.spanId),\n    parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),\n    traceState: ctx.traceState?.serialize(),\n    name: span.name,\n    // Span kind is offset by 1 because the API does not define a value for unset\n    kind: span.kind == null ? 0 : span.kind + 1,\n    startTimeUnixNano: encoder.encodeHrTime(span.startTime),\n    endTimeUnixNano: encoder.encodeHrTime(span.endTime),\n    attributes: toAttributes(span.attributes),\n    droppedAttributesCount: span.droppedAttributesCount,\n    events: span.events.map(event => toOtlpSpanEvent(event, encoder)),\n    droppedEventsCount: span.droppedEventsCount,\n    status: {\n      // API and proto enums share the same values\n      code: status.code as unknown as EStatusCode,\n      message: status.message,\n    },\n    links: span.links.map(link => toOtlpLink(link, encoder)),\n    droppedLinksCount: span.droppedLinksCount,\n  };\n}\n\nexport function toOtlpLink(link: Link, encoder: Encoder): ILink {\n  return {\n    attributes: link.attributes ? toAttributes(link.attributes) : [],\n    spanId: encoder.encodeSpanContext(link.context.spanId),\n    traceId: encoder.encodeSpanContext(link.context.traceId),\n    traceState: link.context.traceState?.serialize(),\n    droppedAttributesCount: link.droppedAttributesCount || 0,\n  };\n}\n\nexport function toOtlpSpanEvent(\n  timedEvent: TimedEvent,\n  encoder: Encoder\n): IEvent {\n  return {\n    attributes: timedEvent.attributes\n      ? toAttributes(timedEvent.attributes)\n      : [],\n    name: timedEvent.name,\n    timeUnixNano: encoder.encodeHrTime(timedEvent.time),\n    droppedAttributesCount: timedEvent.droppedAttributesCount || 0,\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { IResource as ISdkResource } from '@opentelemetry/resources';\nimport { toAttributes } from '../common/internal';\nimport { IResource } from './types';\n\nexport function createResource(resource: ISdkResource): IResource {\n  return {\n    attributes: toAttributes(resource.attributes),\n    droppedAttributesCount: 0,\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { IResource } from '@opentelemetry/resources';\nimport type { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport type { OtlpEncodingOptions } from '../common/types';\nimport { sdkSpanToOtlpSpan } from './internal';\nimport {\n  IExportTraceServiceRequest,\n  IResourceSpans,\n  IScopeSpans,\n} from './types';\nimport { Encoder, getOtlpEncoder } from '../common';\nimport { createInstrumentationScope } from '../common/internal';\nimport { createResource } from '../resource/internal';\n\nexport function createExportTraceServiceRequest(\n  spans: ReadableSpan[],\n  options?: OtlpEncodingOptions\n): IExportTraceServiceRequest {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resourceSpans: spanRecordsToResourceSpans(spans, encoder),\n  };\n}\n\nfunction createResourceMap(readableSpans: ReadableSpan[]) {\n  const resourceMap: Map<IResource, Map<string, ReadableSpan[]>> = new Map();\n  for (const record of readableSpans) {\n    let ilmMap = resourceMap.get(record.resource);\n\n    if (!ilmMap) {\n      ilmMap = new Map();\n      resourceMap.set(record.resource, ilmMap);\n    }\n\n    // TODO this is duplicated in basic tracer. Consolidate on a common helper in core\n    const instrumentationLibraryKey = `${record.instrumentationLibrary.name}@${\n      record.instrumentationLibrary.version || ''\n    }:${record.instrumentationLibrary.schemaUrl || ''}`;\n    let records = ilmMap.get(instrumentationLibraryKey);\n\n    if (!records) {\n      records = [];\n      ilmMap.set(instrumentationLibraryKey, records);\n    }\n\n    records.push(record);\n  }\n\n  return resourceMap;\n}\n\nfunction spanRecordsToResourceSpans(\n  readableSpans: ReadableSpan[],\n  encoder: Encoder\n): IResourceSpans[] {\n  const resourceMap = createResourceMap(readableSpans);\n  const out: IResourceSpans[] = [];\n\n  const entryIterator = resourceMap.entries();\n  let entry = entryIterator.next();\n  while (!entry.done) {\n    const [resource, ilmMap] = entry.value;\n    const scopeResourceSpans: IScopeSpans[] = [];\n    const ilmIterator = ilmMap.values();\n    let ilmEntry = ilmIterator.next();\n    while (!ilmEntry.done) {\n      const scopeSpans = ilmEntry.value;\n      if (scopeSpans.length > 0) {\n        const spans = scopeSpans.map(readableSpan =>\n          sdkSpanToOtlpSpan(readableSpan, encoder)\n        );\n\n        scopeResourceSpans.push({\n          scope: createInstrumentationScope(\n            scopeSpans[0].instrumentationLibrary\n          ),\n          spans: spans,\n          schemaUrl: scopeSpans[0].instrumentationLibrary.schemaUrl,\n        });\n      }\n      ilmEntry = ilmIterator.next();\n    }\n    // TODO SDK types don't provide resource schema URL at this time\n    const transformedSpans: IResourceSpans = {\n      resource: createResource(resource),\n      scopeSpans: scopeResourceSpans,\n      schemaUrl: undefined,\n    };\n\n    out.push(transformedSpans);\n    entry = entryIterator.next();\n  }\n\n  return out;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * AggregationTemporality indicates the way additive quantities are expressed.\n */\nexport enum AggregationTemporality {\n  DELTA,\n  CUMULATIVE,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime, Attributes, ValueType } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { Histogram, ExponentialHistogram } from '../aggregator/types';\n\nexport interface MetricDescriptor {\n  readonly name: string;\n  readonly description: string;\n  readonly unit: string;\n  /**\n   * @deprecated exporter should avoid depending on the type of the instrument\n   * as their resulting aggregator can be re-mapped with views.\n   */\n  readonly type: InstrumentType;\n  readonly valueType: ValueType;\n}\n\n/**\n * Basic metric data fields.\n */\ninterface BaseMetricData {\n  readonly descriptor: MetricDescriptor;\n  readonly aggregationTemporality: AggregationTemporality;\n  /**\n   * DataPointType of the metric instrument.\n   */\n  readonly dataPointType: DataPointType;\n}\n\n/**\n * Represents a metric data aggregated by either a LastValueAggregation or\n * SumAggregation.\n */\nexport interface SumMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.SUM;\n  readonly dataPoints: DataPoint<number>[];\n  readonly isMonotonic: boolean;\n}\n\nexport interface GaugeMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.GAUGE;\n  readonly dataPoints: DataPoint<number>[];\n}\n\n/**\n * Represents a metric data aggregated by a HistogramAggregation.\n */\nexport interface HistogramMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.HISTOGRAM;\n  readonly dataPoints: DataPoint<Histogram>[];\n}\n\n/**\n * Represents a metric data aggregated by a ExponentialHistogramAggregation.\n */\nexport interface ExponentialHistogramMetricData extends BaseMetricData {\n  readonly dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM;\n  readonly dataPoints: DataPoint<ExponentialHistogram>[];\n}\n\n/**\n * Represents an aggregated metric data.\n */\nexport type MetricData =\n  | SumMetricData\n  | GaugeMetricData\n  | HistogramMetricData\n  | ExponentialHistogramMetricData;\n\nexport interface ScopeMetrics {\n  scope: InstrumentationScope;\n  metrics: MetricData[];\n}\n\nexport interface ResourceMetrics {\n  resource: IResource;\n  scopeMetrics: ScopeMetrics[];\n}\n\n/**\n * Represents the collection result of the metrics. If there are any\n * non-critical errors in the collection, like throwing in a single observable\n * callback, these errors are aggregated in the {@link CollectionResult.errors}\n * array and other successfully collected metrics are returned.\n */\nexport interface CollectionResult {\n  /**\n   * Collected metrics.\n   */\n  resourceMetrics: ResourceMetrics;\n  /**\n   * Arbitrary JavaScript exception values.\n   */\n  errors: unknown[];\n}\n\n/**\n * The aggregated point data type.\n */\nexport enum DataPointType {\n  /**\n   * A histogram data point contains a histogram statistics of collected\n   * values with a list of explicit bucket boundaries and statistics such\n   * as min, max, count, and sum of all collected values.\n   */\n  HISTOGRAM,\n  /**\n   * An exponential histogram data point contains a histogram statistics of\n   * collected values where bucket boundaries are automatically calculated\n   * using an exponential function, and statistics such as min, max, count,\n   * and sum of all collected values.\n   */\n  EXPONENTIAL_HISTOGRAM,\n  /**\n   * A gauge metric data point has only a single numeric value.\n   */\n  GAUGE,\n  /**\n   * A sum metric data point has a single numeric value and a\n   * monotonicity-indicator.\n   */\n  SUM,\n}\n\n/**\n * Represents an aggregated point data with start time, end time and their\n * associated attributes and points.\n */\nexport interface DataPoint<T> {\n  /**\n   * The start epoch timestamp of the DataPoint, usually the time when\n   * the metric was created when the preferred AggregationTemporality is\n   * CUMULATIVE, or last collection time otherwise.\n   */\n  readonly startTime: HrTime;\n  /**\n   * The end epoch timestamp when data were collected, usually it represents\n   * the moment when `MetricReader.collect` was called.\n   */\n  readonly endTime: HrTime;\n  /**\n   * The attributes associated with this DataPoint.\n   */\n  readonly attributes: Attributes;\n  /**\n   * The value for this DataPoint. The type of the value is indicated by the\n   * {@link DataPointType}.\n   */\n  readonly value: T;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\n\nexport type Maybe<T> = T | undefined;\n\nexport function isNotNullish<T>(item: Maybe<T>): item is T {\n  return item !== undefined && item !== null;\n}\n\n/**\n * Converting the unordered attributes into unique identifier string.\n * @param attributes user provided unordered Attributes.\n */\nexport function hashAttributes(attributes: Attributes): string {\n  let keys = Object.keys(attributes);\n  if (keys.length === 0) return '';\n\n  // Return a string that is stable on key orders.\n  keys = keys.sort();\n  return JSON.stringify(keys.map(key => [key, attributes[key]]));\n}\n\n/**\n * Converting the instrumentation scope object to a unique identifier string.\n * @param instrumentationScope\n */\nexport function instrumentationScopeId(\n  instrumentationScope: InstrumentationScope\n): string {\n  return `${instrumentationScope.name}:${instrumentationScope.version ?? ''}:${\n    instrumentationScope.schemaUrl ?? ''\n  }`;\n}\n\n/**\n * Error that is thrown on timeouts.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message);\n\n    // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:\n    // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n\n/**\n * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise\n * rejects, and resolves if the specified promise resolves.\n *\n * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.\n *\n * @param promise promise to use with timeout.\n * @param timeout the timeout in milliseconds until the returned promise is rejected.\n */\nexport function callWithTimeout<T>(\n  promise: Promise<T>,\n  timeout: number\n): Promise<T> {\n  let timeoutHandle: ReturnType<typeof setTimeout>;\n\n  const timeoutPromise = new Promise<never>(function timeoutFunction(\n    _resolve,\n    reject\n  ) {\n    timeoutHandle = setTimeout(function timeoutHandler() {\n      reject(new TimeoutError('Operation timed out.'));\n    }, timeout);\n  });\n\n  return Promise.race([promise, timeoutPromise]).then(\n    result => {\n      clearTimeout(timeoutHandle);\n      return result;\n    },\n    reason => {\n      clearTimeout(timeoutHandle);\n      throw reason;\n    }\n  );\n}\n\nexport interface PromiseAllSettledFulfillResult<T> {\n  status: 'fulfilled';\n  value: T;\n}\n\nexport interface PromiseAllSettledRejectionResult {\n  status: 'rejected';\n  reason: unknown;\n}\n\nexport type PromiseAllSettledResult<T> =\n  | PromiseAllSettledFulfillResult<T>\n  | PromiseAllSettledRejectionResult;\n\n/**\n * Node.js v12.9 lower and browser compatible `Promise.allSettled`.\n */\nexport async function PromiseAllSettled<T>(\n  promises: Promise<T>[]\n): Promise<PromiseAllSettledResult<T>[]> {\n  return Promise.all(\n    promises.map<Promise<PromiseAllSettledResult<T>>>(async p => {\n      try {\n        const ret = await p;\n        return {\n          status: 'fulfilled',\n          value: ret,\n        };\n      } catch (e) {\n        return {\n          status: 'rejected',\n          reason: e,\n        };\n      }\n    })\n  );\n}\n\nexport function isPromiseAllSettledRejectionResult(\n  it: PromiseAllSettledResult<unknown>\n): it is PromiseAllSettledRejectionResult {\n  return it.status === 'rejected';\n}\n\n/**\n * Node.js v11.0 lower and browser compatible `Array.prototype.flatMap`.\n */\nexport function FlatMap<T, R>(arr: T[], fn: (it: T) => R[]): R[] {\n  const result: R[] = [];\n  arr.forEach(it => {\n    result.push(...fn(it));\n  });\n  return result;\n}\n\nexport function setEquals(lhs: Set<unknown>, rhs: Set<unknown>): boolean {\n  if (lhs.size !== rhs.size) {\n    return false;\n  }\n  for (const item of lhs) {\n    if (!rhs.has(item)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Binary search the sorted array to the find upper bound for the value.\n * @param arr\n * @param value\n * @returns\n */\nexport function binarySearchUB(arr: number[], value: number): number {\n  let lo = 0;\n  let hi = arr.length - 1;\n  let ret = arr.length;\n\n  while (hi >= lo) {\n    const mid = lo + Math.trunc((hi - lo) / 2);\n    if (arr[mid] < value) {\n      lo = mid + 1;\n    } else {\n      ret = mid;\n      hi = mid - 1;\n    }\n  }\n\n  return ret;\n}\n\nexport function equalsCaseInsensitive(lhs: string, rhs: string): boolean {\n  return lhs.toLowerCase() === rhs.toLowerCase();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime, Attributes } from '@opentelemetry/api';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { MetricData, MetricDescriptor } from '../export/MetricData';\nimport { Maybe } from '../utils';\n\n/** The kind of aggregator. */\nexport enum AggregatorKind {\n  DROP,\n  SUM,\n  LAST_VALUE,\n  HISTOGRAM,\n  EXPONENTIAL_HISTOGRAM,\n}\n\n/** DataPoint value type for SumAggregation. */\nexport type Sum = number;\n\n/** DataPoint value type for LastValueAggregation. */\nexport type LastValue = number;\n\n/** DataPoint value type for HistogramAggregation. */\nexport interface Histogram {\n  /**\n   * Buckets are implemented using two different arrays:\n   *  - boundaries: contains every finite bucket boundary, which are inclusive upper bounds\n   *  - counts: contains event counts for each bucket\n   *\n   * Note that we'll always have n+1 buckets, where n is the number of boundaries.\n   * This is because we need to count events that are higher than the upper boundary.\n   *\n   * Example: if we measure the values: [5, 30, 5, 40, 5, 15, 15, 15, 25]\n   *  with the boundaries [ 10, 20, 30 ], we will have the following state:\n   *\n   * buckets: {\n   *\tboundaries: [10, 20, 30],\n   *\tcounts: [3, 3, 2, 1],\n   * }\n   */\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum?: number;\n  count: number;\n  min?: number;\n  max?: number;\n}\n\n/** DataPoint value type for ExponentialHistogramAggregation. */\nexport interface ExponentialHistogram {\n  count: number;\n  sum?: number;\n  scale: number;\n  zeroCount: number;\n  positive: {\n    offset: number;\n    bucketCounts: number[];\n  };\n  negative: {\n    offset: number;\n    bucketCounts: number[];\n  };\n  min?: number;\n  max?: number;\n}\n\n/**\n * An Aggregator accumulation state.\n */\nexport interface Accumulation {\n  setStartTime(startTime: HrTime): void;\n  record(value: number): void;\n}\n\nexport type AccumulationRecord<T> = [Attributes, T];\n\n/**\n * Base interface for aggregators. Aggregators are responsible for holding\n * aggregated values and taking a snapshot of these values upon export.\n */\nexport interface Aggregator<T> {\n  /** The kind of the aggregator. */\n  kind: AggregatorKind;\n\n  /**\n   * Create a clean state of accumulation.\n   */\n  createAccumulation(startTime: HrTime): T;\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * This should always assume that the accumulations do not overlap and merge together for a new\n   * cumulative report.\n   *\n   * @param previous the previously captured accumulation\n   * @param delta the newly captured (delta) accumulation\n   * @returns the result of the merge of the given accumulations\n   */\n  merge(previous: T, delta: T): T;\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * @param previous the previously captured accumulation\n   * @param current the newly captured (cumulative) accumulation\n   * @returns The resulting delta accumulation\n   */\n  diff(previous: T, current: T): T;\n\n  /**\n   * Returns the {@link MetricData} that this {@link Aggregator} will produce.\n   *\n   * @param descriptor the metric descriptor.\n   * @param aggregationTemporality the temporality of the resulting {@link MetricData}\n   * @param accumulationByAttributes the array of attributes and accumulation pairs.\n   * @param endTime the end time of the metric data.\n   * @return the {@link MetricData} that this {@link Aggregator} will produce.\n   */\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<T>[],\n    endTime: HrTime\n  ): Maybe<MetricData>;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { MetricData, MetricDescriptor } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregatorKind, Aggregator, AccumulationRecord } from './types';\n\n/** Basic aggregator for None which keeps no recorded value. */\nexport class DropAggregator implements Aggregator<undefined> {\n  kind: AggregatorKind.DROP = AggregatorKind.DROP;\n\n  createAccumulation() {\n    return undefined;\n  }\n\n  merge(_previous: undefined, _delta: undefined) {\n    return undefined;\n  }\n\n  diff(_previous: undefined, _current: undefined) {\n    return undefined;\n  }\n\n  toMetricData(\n    _descriptor: MetricDescriptor,\n    _aggregationTemporality: AggregationTemporality,\n    _accumulationByAttributes: AccumulationRecord<undefined>[],\n    _endTime: HrTime\n  ): Maybe<MetricData> {\n    return undefined;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MetricOptions, ValueType, diag } from '@opentelemetry/api';\nimport { View } from './view/View';\nimport { equalsCaseInsensitive } from './utils';\n\n/**\n * Supported types of metric instruments.\n */\nexport enum InstrumentType {\n  COUNTER = 'COUNTER',\n  GAUGE = 'GAUGE',\n  HISTOGRAM = 'HISTOGRAM',\n  UP_DOWN_COUNTER = 'UP_DOWN_COUNTER',\n  OBSERVABLE_COUNTER = 'OBSERVABLE_COUNTER',\n  OBSERVABLE_GAUGE = 'OBSERVABLE_GAUGE',\n  OBSERVABLE_UP_DOWN_COUNTER = 'OBSERVABLE_UP_DOWN_COUNTER',\n}\n\n/**\n * An internal interface describing the instrument.\n *\n * This is intentionally distinguished from the public MetricDescriptor (a.k.a. InstrumentDescriptor)\n * which may not contains internal fields like metric advice.\n */\nexport interface InstrumentDescriptor {\n  readonly name: string;\n  readonly description: string;\n  readonly unit: string;\n  readonly type: InstrumentType;\n  readonly valueType: ValueType;\n  /**\n   * @experimental\n   *\n   * This is intentionally not using the API's type as it's only available from @opentelemetry/api 1.7.0 and up.\n   * In SDK 2.0 we'll be able to bump the minimum API version and remove this workaround.\n   */\n  readonly advice: {\n    /**\n     * Hint the explicit bucket boundaries for SDK if the metric has been\n     * aggregated with a HistogramAggregator.\n     */\n    explicitBucketBoundaries?: number[];\n  };\n}\n\nexport function createInstrumentDescriptor(\n  name: string,\n  type: InstrumentType,\n  options?: MetricOptions\n): InstrumentDescriptor {\n  if (!isValidName(name)) {\n    diag.warn(\n      `Invalid metric name: \"${name}\". The metric name should be a ASCII string with a length no greater than 255 characters.`\n    );\n  }\n  return {\n    name,\n    type,\n    description: options?.description ?? '',\n    unit: options?.unit ?? '',\n    valueType: options?.valueType ?? ValueType.DOUBLE,\n    advice: options?.advice ?? {},\n  };\n}\n\nexport function createInstrumentDescriptorWithView(\n  view: View,\n  instrument: InstrumentDescriptor\n): InstrumentDescriptor {\n  return {\n    name: view.name ?? instrument.name,\n    description: view.description ?? instrument.description,\n    type: instrument.type,\n    unit: instrument.unit,\n    valueType: instrument.valueType,\n    advice: instrument.advice,\n  };\n}\n\nexport function isDescriptorCompatibleWith(\n  descriptor: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  // Names are case-insensitive strings.\n  return (\n    equalsCaseInsensitive(descriptor.name, otherDescriptor.name) &&\n    descriptor.unit === otherDescriptor.unit &&\n    descriptor.type === otherDescriptor.type &&\n    descriptor.valueType === otherDescriptor.valueType\n  );\n}\n\n// ASCII string with a length no greater than 255 characters.\n// NB: the first character counted separately from the rest.\nconst NAME_REGEXP = /^[a-z][a-z0-9_.\\-/]{0,254}$/i;\nexport function isValidName(name: string): boolean {\n  return name.match(NAME_REGEXP) != null;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n} from './types';\nimport {\n  DataPointType,\n  HistogramMetricData,\n  MetricDescriptor,\n} from '../export/MetricData';\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { binarySearchUB, Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\n\n/**\n * Internal value type for HistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram {\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n}\n\nfunction createNewEmptyCheckpoint(boundaries: number[]): InternalHistogram {\n  const counts = boundaries.map(() => 0);\n  counts.push(0);\n  return {\n    buckets: {\n      boundaries,\n      counts,\n    },\n    sum: 0,\n    count: 0,\n    hasMinMax: false,\n    min: Infinity,\n    max: -Infinity,\n  };\n}\n\nexport class HistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private readonly _boundaries: number[],\n    private _recordMinMax = true,\n    private _current: InternalHistogram = createNewEmptyCheckpoint(_boundaries)\n  ) {}\n\n  record(value: number): void {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    this._current.count += 1;\n    this._current.sum += value;\n\n    if (this._recordMinMax) {\n      this._current.min = Math.min(value, this._current.min);\n      this._current.max = Math.max(value, this._current.max);\n      this._current.hasMinMax = true;\n    }\n\n    const idx = binarySearchUB(this._boundaries, value);\n    this._current.buckets.counts[idx] += 1;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): InternalHistogram {\n    return this._current;\n  }\n}\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements Aggregator<HistogramAccumulation> {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n\n  /**\n   * @param _boundaries sorted upper bounds of recorded values.\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    private readonly _boundaries: number[],\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new HistogramAccumulation(\n      startTime,\n      this._boundaries,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two histogram accumulations. As long as one Aggregator\n   * instance produces all Accumulations with constant boundaries we don't need to worry about\n   * merging accumulations with different boundaries.\n   */\n  merge(\n    previous: HistogramAccumulation,\n    delta: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const deltaValue = delta.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const deltaCounts = deltaValue.buckets.counts;\n\n    const mergedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      mergedCounts[idx] = previousCounts[idx] + deltaCounts[idx];\n    }\n\n    let min = Infinity;\n    let max = -Infinity;\n\n    if (this._recordMinMax) {\n      if (previousValue.hasMinMax && deltaValue.hasMinMax) {\n        min = Math.min(previousValue.min, deltaValue.min);\n        max = Math.max(previousValue.max, deltaValue.max);\n      } else if (previousValue.hasMinMax) {\n        min = previousValue.min;\n        max = previousValue.max;\n      } else if (deltaValue.hasMinMax) {\n        min = deltaValue.min;\n        max = deltaValue.max;\n      }\n    }\n\n    return new HistogramAccumulation(\n      previous.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: mergedCounts,\n        },\n        count: previousValue.count + deltaValue.count,\n        sum: previousValue.sum + deltaValue.sum,\n        hasMinMax:\n          this._recordMinMax &&\n          (previousValue.hasMinMax || deltaValue.hasMinMax),\n        min: min,\n        max: max,\n      }\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: HistogramAccumulation,\n    current: HistogramAccumulation\n  ): HistogramAccumulation {\n    const previousValue = previous.toPointValue();\n    const currentValue = current.toPointValue();\n\n    const previousCounts = previousValue.buckets.counts;\n    const currentCounts = currentValue.buckets.counts;\n\n    const diffedCounts = new Array(previousCounts.length);\n    for (let idx = 0; idx < previousCounts.length; idx++) {\n      diffedCounts[idx] = currentCounts[idx] - previousCounts[idx];\n    }\n\n    return new HistogramAccumulation(\n      current.startTime,\n      previousValue.buckets.boundaries,\n      this._recordMinMax,\n      {\n        buckets: {\n          boundaries: previousValue.buckets.boundaries,\n          counts: diffedCounts,\n        },\n        count: currentValue.count - previousValue.count,\n        sum: currentValue.sum - previousValue.sum,\n        hasMinMax: false,\n        min: Infinity,\n        max: -Infinity,\n      }\n    );\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<HistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<HistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            buckets: pointValue.buckets,\n            count: pointValue.count,\n          },\n        };\n      }),\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class Buckets {\n  /**\n   * The term index refers to the number of the exponential histogram bucket\n   * used to determine its boundaries. The lower boundary of a bucket is\n   * determined by base ** index and the upper boundary of a bucket is\n   * determined by base ** (index + 1). index values are signed to account\n   * for values less than or equal to 1.\n   *\n   * indexBase is the index of the 0th position in the\n   * backing array, i.e., backing[0] is the count\n   * in the bucket with index `indexBase`.\n   *\n   * indexStart is the smallest index value represented\n   * in the backing array.\n   *\n   * indexEnd is the largest index value represented in\n   * the backing array.\n   */\n  constructor(\n    public backing = new BucketsBacking(),\n    public indexBase = 0,\n    public indexStart = 0,\n    public indexEnd = 0\n  ) {}\n\n  /**\n   * Offset is the bucket index of the smallest entry in the counts array\n   * @returns {number}\n   */\n  get offset(): number {\n    return this.indexStart;\n  }\n\n  /**\n   * Buckets is a view into the backing array.\n   * @returns {number}\n   */\n  get length(): number {\n    if (this.backing.length === 0) {\n      return 0;\n    }\n\n    if (this.indexEnd === this.indexStart && this.at(0) === 0) {\n      return 0;\n    }\n\n    return this.indexEnd - this.indexStart + 1;\n  }\n\n  /**\n   * An array of counts, where count[i] carries the count\n   * of the bucket at index (offset+i).  count[i] is the count of\n   * values greater than base^(offset+i) and less than or equal to\n   * base^(offset+i+1).\n   * @returns {number} The logical counts based on the backing array\n   */\n  counts(): number[] {\n    return Array.from({ length: this.length }, (_, i) => this.at(i));\n  }\n\n  /**\n   * At returns the count of the bucket at a position in the logical\n   * array of counts.\n   * @param position\n   * @returns {number}\n   */\n  at(position: number): number {\n    const bias = this.indexBase - this.indexStart;\n    if (position < bias) {\n      position += this.backing.length;\n    }\n\n    position -= bias;\n    return this.backing.countAt(position);\n  }\n\n  /**\n   * incrementBucket increments the backing array index by `increment`\n   * @param bucketIndex\n   * @param increment\n   */\n  incrementBucket(bucketIndex: number, increment: number) {\n    this.backing.increment(bucketIndex, increment);\n  }\n\n  /**\n   * decrementBucket decrements the backing array index by `decrement`\n   * if decrement is greater than the current value, it's set to 0.\n   * @param bucketIndex\n   * @param decrement\n   */\n  decrementBucket(bucketIndex: number, decrement: number) {\n    this.backing.decrement(bucketIndex, decrement);\n  }\n\n  /**\n   * trim removes leading and / or trailing zero buckets (which can occur\n   * after diffing two histos) and rotates the backing array so that the\n   * smallest non-zero index is in the 0th position of the backing array\n   */\n  trim() {\n    for (let i = 0; i < this.length; i++) {\n      if (this.at(i) !== 0) {\n        this.indexStart += i;\n        break;\n      } else if (i === this.length - 1) {\n        //the entire array is zeroed out\n        this.indexStart = this.indexEnd = this.indexBase = 0;\n        return;\n      }\n    }\n\n    for (let i = this.length - 1; i >= 0; i--) {\n      if (this.at(i) !== 0) {\n        this.indexEnd -= this.length - i - 1;\n        break;\n      }\n    }\n\n    this._rotate();\n  }\n\n  /**\n   * downscale first rotates, then collapses 2**`by`-to-1 buckets.\n   * @param by\n   */\n  downscale(by: number) {\n    this._rotate();\n\n    const size = 1 + this.indexEnd - this.indexStart;\n    const each = 1 << by;\n    let inpos = 0;\n    let outpos = 0;\n\n    for (let pos = this.indexStart; pos <= this.indexEnd; ) {\n      let mod = pos % each;\n      if (mod < 0) {\n        mod += each;\n      }\n      for (let i = mod; i < each && inpos < size; i++) {\n        this._relocateBucket(outpos, inpos);\n        inpos++;\n        pos++;\n      }\n      outpos++;\n    }\n\n    this.indexStart >>= by;\n    this.indexEnd >>= by;\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * Clone returns a deep copy of Buckets\n   * @returns {Buckets}\n   */\n  clone(): Buckets {\n    return new Buckets(\n      this.backing.clone(),\n      this.indexBase,\n      this.indexStart,\n      this.indexEnd\n    );\n  }\n\n  /**\n   * _rotate shifts the backing array contents so that indexStart ==\n   * indexBase to simplify the downscale logic.\n   */\n  private _rotate() {\n    const bias = this.indexBase - this.indexStart;\n\n    if (bias === 0) {\n      return;\n    } else if (bias > 0) {\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, bias);\n      this.backing.reverse(bias, this.backing.length);\n    } else {\n      // negative bias, this can happen when diffing two histograms\n      this.backing.reverse(0, this.backing.length);\n      this.backing.reverse(0, this.backing.length + bias);\n    }\n    this.indexBase = this.indexStart;\n  }\n\n  /**\n   * _relocateBucket adds the count in counts[src] to counts[dest] and\n   * resets count[src] to zero.\n   */\n  private _relocateBucket(dest: number, src: number) {\n    if (dest === src) {\n      return;\n    }\n    this.incrementBucket(dest, this.backing.emptyBucket(src));\n  }\n}\n\n/**\n * BucketsBacking holds the raw buckets and some utility methods to\n * manage them.\n */\nclass BucketsBacking {\n  constructor(private _counts = [0]) {}\n\n  /**\n   * length returns the physical size of the backing array, which\n   * is >= buckets.length()\n   */\n  get length(): number {\n    return this._counts.length;\n  }\n\n  /**\n   * countAt returns the count in a specific bucket\n   */\n  countAt(pos: number): number {\n    return this._counts[pos];\n  }\n\n  /**\n   * growTo grows a backing array and copies old entries\n   * into their correct new positions.\n   */\n  growTo(newSize: number, oldPositiveLimit: number, newPositiveLimit: number) {\n    const tmp = new Array<number>(newSize).fill(0);\n    tmp.splice(\n      newPositiveLimit,\n      this._counts.length - oldPositiveLimit,\n      ...this._counts.slice(oldPositiveLimit)\n    );\n    tmp.splice(0, oldPositiveLimit, ...this._counts.slice(0, oldPositiveLimit));\n    this._counts = tmp;\n  }\n\n  /**\n   * reverse the items in the backing array in the range [from, limit).\n   */\n  reverse(from: number, limit: number) {\n    const num = Math.floor((from + limit) / 2) - from;\n    for (let i = 0; i < num; i++) {\n      const tmp = this._counts[from + i];\n      this._counts[from + i] = this._counts[limit - i - 1];\n      this._counts[limit - i - 1] = tmp;\n    }\n  }\n\n  /**\n   * emptyBucket empties the count from a bucket, for\n   * moving into another.\n   */\n  emptyBucket(src: number): number {\n    const tmp = this._counts[src];\n    this._counts[src] = 0;\n    return tmp;\n  }\n\n  /**\n   * increments a bucket by `increment`\n   */\n  increment(bucketIndex: number, increment: number) {\n    this._counts[bucketIndex] += increment;\n  }\n\n  /**\n   * decrements a bucket by `decrement`\n   */\n  decrement(bucketIndex: number, decrement: number) {\n    if (this._counts[bucketIndex] >= decrement) {\n      this._counts[bucketIndex] -= decrement;\n    } else {\n      // this should not happen, but we're being defensive against\n      // negative counts.\n      this._counts[bucketIndex] = 0;\n    }\n  }\n\n  /**\n   * clone returns a deep copy of BucketsBacking\n   */\n  clone(): BucketsBacking {\n    return new BucketsBacking([...this._counts]);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The functions and constants in this file allow us to interact\n * with the internal representation of an IEEE 64-bit floating point\n * number. We need to work with all 64-bits, thus, care needs to be\n * taken when working with Javascript's bitwise operators (<<, >>, &,\n * |, etc) as they truncate operands to 32-bits. In order to work around\n * this we work with the 64-bits as two 32-bit halves, perform bitwise\n * operations on them independently, and combine the results (if needed).\n */\n\nexport const SIGNIFICAND_WIDTH = 52;\n\n/**\n * EXPONENT_MASK is set to 1 for the hi 32-bits of an IEEE 754\n * floating point exponent: 0x7ff00000.\n */\nconst EXPONENT_MASK = 0x7ff00000;\n\n/**\n * SIGNIFICAND_MASK is the mask for the significand portion of the hi 32-bits\n * of an IEEE 754 double-precision floating-point value: 0xfffff\n */\nconst SIGNIFICAND_MASK = 0xfffff;\n\n/**\n * EXPONENT_BIAS is the exponent bias specified for encoding\n * the IEEE 754 double-precision floating point exponent: 1023\n */\nconst EXPONENT_BIAS = 1023;\n\n/**\n * MIN_NORMAL_EXPONENT is the minimum exponent of a normalized\n * floating point: -1022.\n */\nexport const MIN_NORMAL_EXPONENT = -EXPONENT_BIAS + 1;\n\n/**\n * MAX_NORMAL_EXPONENT is the maximum exponent of a normalized\n * floating point: 1023.\n */\nexport const MAX_NORMAL_EXPONENT = EXPONENT_BIAS;\n\n/**\n * MIN_VALUE is the smallest normal number\n */\nexport const MIN_VALUE = Math.pow(2, -1022);\n\n/**\n * getNormalBase2 extracts the normalized base-2 fractional exponent.\n * This returns k for the equation f x 2**k where f is\n * in the range [1, 2).  Note that this function is not called for\n * subnormal numbers.\n * @param {number} value - the value to determine normalized base-2 fractional\n *    exponent for\n * @returns {number} the normalized base-2 exponent\n */\nexport function getNormalBase2(value: number): number {\n  const dv = new DataView(new ArrayBuffer(8));\n  dv.setFloat64(0, value);\n  // access the raw 64-bit float as 32-bit uints\n  const hiBits = dv.getUint32(0);\n  const expBits = (hiBits & EXPONENT_MASK) >> 20;\n  return expBits - EXPONENT_BIAS;\n}\n\n/**\n * GetSignificand returns the 52 bit (unsigned) significand as a signed value.\n * @param {number} value - the floating point number to extract the significand from\n * @returns {number} The 52-bit significand\n */\nexport function getSignificand(value: number): number {\n  const dv = new DataView(new ArrayBuffer(8));\n  dv.setFloat64(0, value);\n  // access the raw 64-bit float as two 32-bit uints\n  const hiBits = dv.getUint32(0);\n  const loBits = dv.getUint32(4);\n  // extract the significand bits from the hi bits and left shift 32 places note:\n  // we can't use the native << operator as it will truncate the result to 32-bits\n  const significandHiBits = (hiBits & SIGNIFICAND_MASK) * Math.pow(2, 32);\n  // combine the hi and lo bits and return\n  return significandHiBits + loBits;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Note: other languages provide this as a built in function. This is\n * a naive, but functionally correct implementation. This is used sparingly,\n * when creating a new mapping in a running application.\n *\n * ldexp returns frac  2**exp. With the following special cases:\n *   ldexp(0, exp) = 0\n *   ldexp(Inf, exp) = Inf\n *   ldexp(NaN, exp) = NaN\n * @param frac\n * @param exp\n * @returns {number}\n */\nexport function ldexp(frac: number, exp: number): number {\n  if (\n    frac === 0 ||\n    frac === Number.POSITIVE_INFINITY ||\n    frac === Number.NEGATIVE_INFINITY ||\n    Number.isNaN(frac)\n  ) {\n    return frac;\n  }\n  return frac * Math.pow(2, exp);\n}\n\n/**\n * Computes the next power of two that is greater than or equal to v.\n * This implementation more efficient than, but functionally equivalent\n * to Math.pow(2, Math.ceil(Math.log(x)/Math.log(2))).\n * @param v\n * @returns {number}\n */\nexport function nextGreaterSquare(v: number): number {\n  // The following expression computes the least power-of-two\n  // that is >= v.  There are a number of tricky ways to\n  // do this, see https://stackoverflow.com/questions/466204/rounding-up-to-next-power-of-2\n  v--;\n  v |= v >> 1;\n  v |= v >> 2;\n  v |= v >> 4;\n  v |= v >> 8;\n  v |= v >> 16;\n  v++;\n  return v;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport class MappingError extends Error {}\n\n/**\n * The mapping interface is used by the exponential histogram to determine\n * where to bucket values. The interface is implemented by ExponentMapping,\n * used for scales [-10, 0] and LogarithmMapping, used for scales [1, 20].\n */\nexport interface Mapping {\n  mapToIndex(value: number): number;\n  lowerBoundary(index: number): number;\n  get scale(): number;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * ExponentMapping implements exponential mapping functions for\n * scales <=0. For scales > 0 LogarithmMapping should be used.\n */\nexport class ExponentMapping implements Mapping {\n  private readonly _shift: number;\n\n  constructor(scale: number) {\n    this._shift = -scale;\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value < ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex();\n    }\n\n    const exp = ieee754.getNormalBase2(value);\n\n    // In case the value is an exact power of two, compute a\n    // correction of -1. Note, we are using a custom _rightShift\n    // to accommodate a 52-bit argument, which the native bitwise\n    // operators do not support\n    const correction = this._rightShift(\n      ieee754.getSignificand(value) - 1,\n      ieee754.SIGNIFICAND_WIDTH\n    );\n\n    return (exp + correction) >> this._shift;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index < minIndex) {\n      throw new MappingError(\n        `underflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index > maxIndex) {\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    return util.ldexp(1, index << this._shift);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    if (this._shift === 0) {\n      return 0;\n    }\n    return -this._shift;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    let index = ieee754.MIN_NORMAL_EXPONENT >> this._shift;\n    if (this._shift < 2) {\n      index--;\n    }\n\n    return index;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ieee754.MAX_NORMAL_EXPONENT >> this._shift;\n  }\n\n  private _rightShift(value: number, shift: number): number {\n    return Math.floor(value * Math.pow(2, -shift));\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as ieee754 from './ieee754';\nimport * as util from '../util';\nimport { Mapping, MappingError } from './types';\n\n/**\n * LogarithmMapping implements exponential mapping functions for scale > 0.\n * For scales <= 0 the exponent mapping should be used.\n */\nexport class LogarithmMapping implements Mapping {\n  private readonly _scale: number;\n  private readonly _scaleFactor: number;\n  private readonly _inverseFactor: number;\n\n  constructor(scale: number) {\n    this._scale = scale;\n    this._scaleFactor = util.ldexp(Math.LOG2E, scale);\n    this._inverseFactor = util.ldexp(Math.LN2, -scale);\n  }\n\n  /**\n   * Maps positive floating point values to indexes corresponding to scale\n   * @param value\n   * @returns {number} index for provided value at the current scale\n   */\n  mapToIndex(value: number): number {\n    if (value <= ieee754.MIN_VALUE) {\n      return this._minNormalLowerBoundaryIndex() - 1;\n    }\n\n    // exact power of two special case\n    if (ieee754.getSignificand(value) === 0) {\n      const exp = ieee754.getNormalBase2(value);\n      return (exp << this._scale) - 1;\n    }\n\n    // non-power of two cases. use Math.floor to round the scaled logarithm\n    const index = Math.floor(Math.log(value) * this._scaleFactor);\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      return maxIndex;\n    }\n\n    return index;\n  }\n\n  /**\n   * Returns the lower bucket boundary for the given index for scale\n   *\n   * @param index\n   * @returns {number}\n   */\n  lowerBoundary(index: number): number {\n    const maxIndex = this._maxNormalLowerBoundaryIndex();\n    if (index >= maxIndex) {\n      if (index === maxIndex) {\n        return 2 * Math.exp((index - (1 << this._scale)) / this._scaleFactor);\n      }\n      throw new MappingError(\n        `overflow: ${index} is > maximum lower boundary: ${maxIndex}`\n      );\n    }\n\n    const minIndex = this._minNormalLowerBoundaryIndex();\n    if (index <= minIndex) {\n      if (index === minIndex) {\n        return ieee754.MIN_VALUE;\n      } else if (index === minIndex - 1) {\n        return Math.exp((index + (1 << this._scale)) / this._scaleFactor) / 2;\n      }\n      throw new MappingError(\n        `overflow: ${index} is < minimum lower boundary: ${minIndex}`\n      );\n    }\n\n    return Math.exp(index * this._inverseFactor);\n  }\n\n  /**\n   * The scale used by this mapping\n   * @returns {number}\n   */\n  get scale(): number {\n    return this._scale;\n  }\n\n  private _minNormalLowerBoundaryIndex(): number {\n    return ieee754.MIN_NORMAL_EXPONENT << this._scale;\n  }\n\n  private _maxNormalLowerBoundaryIndex(): number {\n    return ((ieee754.MAX_NORMAL_EXPONENT + 1) << this._scale) - 1;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ExponentMapping } from './ExponentMapping';\nimport { LogarithmMapping } from './LogarithmMapping';\nimport { MappingError, Mapping } from './types';\n\nconst MIN_SCALE = -10;\nconst MAX_SCALE = 20;\nconst PREBUILT_MAPPINGS = Array.from({ length: 31 }, (_, i) => {\n  if (i > 10) {\n    return new LogarithmMapping(i - 10);\n  }\n  return new ExponentMapping(i - 10);\n});\n\n/**\n * getMapping returns an appropriate mapping for the given scale. For scales -10\n * to 0 the underlying type will be ExponentMapping. For scales 1 to 20 the\n * underlying type will be LogarithmMapping.\n * @param scale a number in the range [-10, 20]\n * @returns {Mapping}\n */\nexport function getMapping(scale: number): Mapping {\n  if (scale > MAX_SCALE || scale < MIN_SCALE) {\n    throw new MappingError(\n      `expected scale >= ${MIN_SCALE} && <= ${MAX_SCALE}, got: ${scale}`\n    );\n  }\n  // mappings are offset by 10. scale -10 is at position 0 and scale 20 is at 30\n  return PREBUILT_MAPPINGS[scale + 10];\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  ExponentialHistogram,\n} from './types';\nimport {\n  DataPointType,\n  ExponentialHistogramMetricData,\n  MetricDescriptor,\n} from '../export/MetricData';\nimport { diag, HrTime } from '@opentelemetry/api';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { Buckets } from './exponential-histogram/Buckets';\nimport { getMapping } from './exponential-histogram/mapping/getMapping';\nimport { Mapping } from './exponential-histogram/mapping/types';\nimport { nextGreaterSquare } from './exponential-histogram/util';\n\n/**\n * Internal value type for ExponentialHistogramAggregation.\n * Differs from the exported type as undefined sum/min/max complicate arithmetic\n * performed by this aggregation, but are required to be undefined in the exported types.\n */\ninterface InternalHistogram extends ExponentialHistogram {\n  hasMinMax: boolean;\n  min: number;\n  max: number;\n  sum: number;\n}\n\n// HighLow is a utility class used for computing a common scale for\n// two exponential histogram accumulations\nclass HighLow {\n  static combine(h1: HighLow, h2: HighLow): HighLow {\n    return new HighLow(Math.min(h1.low, h2.low), Math.max(h1.high, h2.high));\n  }\n  constructor(\n    public low: number,\n    public high: number\n  ) {}\n}\n\nconst MAX_SCALE = 20;\nconst DEFAULT_MAX_SIZE = 160;\nconst MIN_MAX_SIZE = 2;\n\nexport class ExponentialHistogramAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime = startTime,\n    private _maxSize = DEFAULT_MAX_SIZE,\n    private _recordMinMax = true,\n    private _sum = 0,\n    private _count = 0,\n    private _zeroCount = 0,\n    private _min = Number.POSITIVE_INFINITY,\n    private _max = Number.NEGATIVE_INFINITY,\n    private _positive = new Buckets(),\n    private _negative = new Buckets(),\n    private _mapping: Mapping = getMapping(MAX_SCALE)\n  ) {\n    if (this._maxSize < MIN_MAX_SIZE) {\n      diag.warn(`Exponential Histogram Max Size set to ${this._maxSize}, \\\n                changing to the minimum size of: ${MIN_MAX_SIZE}`);\n      this._maxSize = MIN_MAX_SIZE;\n    }\n  }\n\n  /**\n   * record updates a histogram with a single count\n   * @param {Number} value\n   */\n  record(value: number) {\n    this.updateByIncrement(value, 1);\n  }\n\n  /**\n   * Sets the start time for this accumulation\n   * @param {HrTime} startTime\n   */\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  /**\n   * Returns the datapoint representation of this accumulation\n   * @param {HrTime} startTime\n   */\n  toPointValue(): InternalHistogram {\n    return {\n      hasMinMax: this._recordMinMax,\n      min: this.min,\n      max: this.max,\n      sum: this.sum,\n      positive: {\n        offset: this.positive.offset,\n        bucketCounts: this.positive.counts(),\n      },\n      negative: {\n        offset: this.negative.offset,\n        bucketCounts: this.negative.counts(),\n      },\n      count: this.count,\n      scale: this.scale,\n      zeroCount: this.zeroCount,\n    };\n  }\n\n  /**\n   * @returns {Number} The sum of values recorded by this accumulation\n   */\n  get sum(): number {\n    return this._sum;\n  }\n\n  /**\n   * @returns {Number} The minimum value recorded by this accumulation\n   */\n  get min(): number {\n    return this._min;\n  }\n\n  /**\n   * @returns {Number} The maximum value recorded by this accumulation\n   */\n  get max(): number {\n    return this._max;\n  }\n\n  /**\n   * @returns {Number} The count of values recorded by this accumulation\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * @returns {Number} The number of 0 values recorded by this accumulation\n   */\n  get zeroCount(): number {\n    return this._zeroCount;\n  }\n\n  /**\n   * @returns {Number} The scale used by this accumulation\n   */\n  get scale(): number {\n    if (this._count === this._zeroCount) {\n      // all zeros! scale doesn't matter, use zero\n      return 0;\n    }\n    return this._mapping.scale;\n  }\n\n  /**\n   * positive holds the positive values\n   * @returns {Buckets}\n   */\n  get positive(): Buckets {\n    return this._positive;\n  }\n\n  /**\n   * negative holds the negative values by their absolute value\n   * @returns {Buckets}\n   */\n  get negative(): Buckets {\n    return this._negative;\n  }\n\n  /**\n   * updateByIncr supports updating a histogram with a non-negative\n   * increment.\n   * @param value\n   * @param increment\n   */\n  updateByIncrement(value: number, increment: number) {\n    // NaN does not fall into any bucket, is not zero and should not be counted,\n    // NaN is never greater than max nor less than min, therefore return as there's nothing for us to do.\n    if (Number.isNaN(value)) {\n      return;\n    }\n\n    if (value > this._max) {\n      this._max = value;\n    }\n    if (value < this._min) {\n      this._min = value;\n    }\n\n    this._count += increment;\n\n    if (value === 0) {\n      this._zeroCount += increment;\n      return;\n    }\n\n    this._sum += value * increment;\n\n    if (value > 0) {\n      this._updateBuckets(this._positive, value, increment);\n    } else {\n      this._updateBuckets(this._negative, -value, increment);\n    }\n  }\n\n  /**\n   * merge combines data from previous value into self\n   * @param {ExponentialHistogramAccumulation} previous\n   */\n  merge(previous: ExponentialHistogramAccumulation) {\n    if (this._count === 0) {\n      this._min = previous.min;\n      this._max = previous.max;\n    } else if (previous.count !== 0) {\n      if (previous.min < this.min) {\n        this._min = previous.min;\n      }\n      if (previous.max > this.max) {\n        this._max = previous.max;\n      }\n    }\n\n    this.startTime = previous.startTime;\n    this._sum += previous.sum;\n    this._count += previous.count;\n    this._zeroCount += previous.zeroCount;\n\n    const minScale = this._minScale(previous);\n\n    this._downscale(this.scale - minScale);\n\n    this._mergeBuckets(this.positive, previous, previous.positive, minScale);\n    this._mergeBuckets(this.negative, previous, previous.negative, minScale);\n  }\n\n  /**\n   * diff subtracts other from self\n   * @param {ExponentialHistogramAccumulation} other\n   */\n  diff(other: ExponentialHistogramAccumulation) {\n    this._min = Infinity;\n    this._max = -Infinity;\n    this._sum -= other.sum;\n    this._count -= other.count;\n    this._zeroCount -= other.zeroCount;\n\n    const minScale = this._minScale(other);\n\n    this._downscale(this.scale - minScale);\n\n    this._diffBuckets(this.positive, other, other.positive, minScale);\n    this._diffBuckets(this.negative, other, other.negative, minScale);\n  }\n\n  /**\n   * clone returns a deep copy of self\n   * @returns {ExponentialHistogramAccumulation}\n   */\n  clone(): ExponentialHistogramAccumulation {\n    return new ExponentialHistogramAccumulation(\n      this.startTime,\n      this._maxSize,\n      this._recordMinMax,\n      this._sum,\n      this._count,\n      this._zeroCount,\n      this._min,\n      this._max,\n      this.positive.clone(),\n      this.negative.clone(),\n      this._mapping\n    );\n  }\n\n  /**\n   * _updateBuckets maps the incoming value to a bucket index for the current\n   * scale. If the bucket index is outside of the range of the backing array,\n   * it will rescale the backing array and update the mapping for the new scale.\n   */\n  private _updateBuckets(buckets: Buckets, value: number, increment: number) {\n    let index = this._mapping.mapToIndex(value);\n\n    // rescale the mapping if needed\n    let rescalingNeeded = false;\n    let high = 0;\n    let low = 0;\n\n    if (buckets.length === 0) {\n      buckets.indexStart = index;\n      buckets.indexEnd = buckets.indexStart;\n      buckets.indexBase = buckets.indexStart;\n    } else if (\n      index < buckets.indexStart &&\n      buckets.indexEnd - index >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = index;\n      high = buckets.indexEnd;\n    } else if (\n      index > buckets.indexEnd &&\n      index - buckets.indexStart >= this._maxSize\n    ) {\n      rescalingNeeded = true;\n      low = buckets.indexStart;\n      high = index;\n    }\n\n    // rescale and compute index at new scale\n    if (rescalingNeeded) {\n      const change = this._changeScale(high, low);\n      this._downscale(change);\n      index = this._mapping.mapToIndex(value);\n    }\n\n    this._incrementIndexBy(buckets, index, increment);\n  }\n\n  /**\n   * _incrementIndexBy increments the count of the bucket specified by `index`.\n   * If the index is outside of the range [buckets.indexStart, buckets.indexEnd]\n   * the boundaries of the backing array will be adjusted and more buckets will\n   * be added if needed.\n   */\n  private _incrementIndexBy(\n    buckets: Buckets,\n    index: number,\n    increment: number\n  ) {\n    if (increment === 0) {\n      // nothing to do for a zero increment, can happen during a merge operation\n      return;\n    }\n\n    if (buckets.length === 0) {\n      buckets.indexStart = buckets.indexEnd = buckets.indexBase = index;\n    }\n\n    if (index < buckets.indexStart) {\n      const span = buckets.indexEnd - index;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexStart = index;\n    } else if (index > buckets.indexEnd) {\n      const span = index - buckets.indexStart;\n      if (span >= buckets.backing.length) {\n        this._grow(buckets, span + 1);\n      }\n      buckets.indexEnd = index;\n    }\n\n    let bucketIndex = index - buckets.indexBase;\n    if (bucketIndex < 0) {\n      bucketIndex += buckets.backing.length;\n    }\n    buckets.incrementBucket(bucketIndex, increment);\n  }\n\n  /**\n   * grow resizes the backing array by doubling in size up to maxSize.\n   * This extends the array with a bunch of zeros and copies the\n   * existing counts to the same position.\n   */\n  private _grow(buckets: Buckets, needed: number) {\n    const size = buckets.backing.length;\n    const bias = buckets.indexBase - buckets.indexStart;\n    const oldPositiveLimit = size - bias;\n    let newSize = nextGreaterSquare(needed);\n    if (newSize > this._maxSize) {\n      newSize = this._maxSize;\n    }\n    const newPositiveLimit = newSize - bias;\n    buckets.backing.growTo(newSize, oldPositiveLimit, newPositiveLimit);\n  }\n\n  /**\n   * _changeScale computes how much downscaling is needed by shifting the\n   * high and low values until they are separated by no more than size.\n   */\n  private _changeScale(high: number, low: number): number {\n    let change = 0;\n    while (high - low >= this._maxSize) {\n      high >>= 1;\n      low >>= 1;\n      change++;\n    }\n    return change;\n  }\n\n  /**\n   * _downscale subtracts `change` from the current mapping scale.\n   */\n  private _downscale(change: number) {\n    if (change === 0) {\n      return;\n    }\n    if (change < 0) {\n      // Note: this should be impossible. If we get here it's because\n      // there is a bug in the implementation.\n      throw new Error(`impossible change of scale: ${this.scale}`);\n    }\n    const newScale = this._mapping.scale - change;\n\n    this._positive.downscale(change);\n    this._negative.downscale(change);\n\n    this._mapping = getMapping(newScale);\n  }\n\n  /**\n   * _minScale is used by diff and merge to compute an ideal combined scale\n   */\n  private _minScale(other: ExponentialHistogramAccumulation): number {\n    const minScale = Math.min(this.scale, other.scale);\n\n    const highLowPos = HighLow.combine(\n      this._highLowAtScale(this.positive, this.scale, minScale),\n      this._highLowAtScale(other.positive, other.scale, minScale)\n    );\n\n    const highLowNeg = HighLow.combine(\n      this._highLowAtScale(this.negative, this.scale, minScale),\n      this._highLowAtScale(other.negative, other.scale, minScale)\n    );\n\n    return Math.min(\n      minScale - this._changeScale(highLowPos.high, highLowPos.low),\n      minScale - this._changeScale(highLowNeg.high, highLowNeg.low)\n    );\n  }\n\n  /**\n   * _highLowAtScale is used by diff and merge to compute an ideal combined scale.\n   */\n  private _highLowAtScale(\n    buckets: Buckets,\n    currentScale: number,\n    newScale: number\n  ): HighLow {\n    if (buckets.length === 0) {\n      return new HighLow(0, -1);\n    }\n    const shift = currentScale - newScale;\n    return new HighLow(buckets.indexStart >> shift, buckets.indexEnd >> shift);\n  }\n\n  /**\n   * _mergeBuckets translates index values from another histogram and\n   * adds the values into the corresponding buckets of this histogram.\n   */\n  private _mergeBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      this._incrementIndexBy(\n        ours,\n        (theirOffset + i) >> theirChange,\n        theirs.at(i)\n      );\n    }\n  }\n\n  /**\n   * _diffBuckets translates index values from another histogram and\n   * subtracts the values in the corresponding buckets of this histogram.\n   */\n  private _diffBuckets(\n    ours: Buckets,\n    other: ExponentialHistogramAccumulation,\n    theirs: Buckets,\n    scale: number\n  ) {\n    const theirOffset = theirs.offset;\n    const theirChange = other.scale - scale;\n\n    for (let i = 0; i < theirs.length; i++) {\n      const ourIndex = (theirOffset + i) >> theirChange;\n      let bucketIndex = ourIndex - ours.indexBase;\n      if (bucketIndex < 0) {\n        bucketIndex += ours.backing.length;\n      }\n      ours.decrementBucket(bucketIndex, theirs.at(i));\n    }\n\n    ours.trim();\n  }\n}\n\n/**\n * Aggregator for ExponentialHistogramAccumulations\n */\nexport class ExponentialHistogramAggregator\n  implements Aggregator<ExponentialHistogramAccumulation>\n{\n  public kind: AggregatorKind.EXPONENTIAL_HISTOGRAM =\n    AggregatorKind.EXPONENTIAL_HISTOGRAM;\n\n  /**\n   * @param _maxSize Maximum number of buckets for each of the positive\n   *    and negative ranges, exclusive of the zero-bucket.\n   * @param _recordMinMax If set to true, min and max will be recorded.\n   *    Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    readonly _maxSize: number,\n    private readonly _recordMinMax: boolean\n  ) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new ExponentialHistogramAccumulation(\n      startTime,\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n\n  /**\n   * Return the result of the merge of two exponential histogram accumulations.\n   */\n  merge(\n    previous: ExponentialHistogramAccumulation,\n    delta: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = delta.clone();\n    result.merge(previous);\n\n    return result;\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(\n    previous: ExponentialHistogramAccumulation,\n    current: ExponentialHistogramAccumulation\n  ): ExponentialHistogramAccumulation {\n    const result = current.clone();\n    result.diff(previous);\n\n    return result;\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<ExponentialHistogramAccumulation>[],\n    endTime: HrTime\n  ): Maybe<ExponentialHistogramMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.EXPONENTIAL_HISTOGRAM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        const pointValue = accumulation.toPointValue();\n\n        // determine if instrument allows negative values.\n        const allowsNegativeValues =\n          descriptor.type === InstrumentType.GAUGE ||\n          descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n          descriptor.type === InstrumentType.OBSERVABLE_GAUGE ||\n          descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER;\n\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: {\n            min: pointValue.hasMinMax ? pointValue.min : undefined,\n            max: pointValue.hasMinMax ? pointValue.max : undefined,\n            sum: !allowsNegativeValues ? pointValue.sum : undefined,\n            positive: {\n              offset: pointValue.positive.offset,\n              bucketCounts: pointValue.positive.bucketCounts,\n            },\n            negative: {\n              offset: pointValue.negative.offset,\n              bucketCounts: pointValue.negative.bucketCounts,\n            },\n            count: pointValue.count,\n            scale: pointValue.scale,\n            zeroCount: pointValue.zeroCount,\n          },\n        };\n      }),\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n  AggregatorKind,\n  LastValue,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport { millisToHrTime, hrTimeToMicroseconds } from '@opentelemetry/core';\nimport {\n  DataPointType,\n  GaugeMetricData,\n  MetricDescriptor,\n} from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\n\nexport class LastValueAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    private _current: number = 0,\n    public sampleTime: HrTime = [0, 0]\n  ) {}\n\n  record(value: number): void {\n    this._current = value;\n    this.sampleTime = millisToHrTime(Date.now());\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): LastValue {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a LastValue from individual measurements. */\nexport class LastValueAggregator implements Aggregator<LastValueAccumulation> {\n  public kind: AggregatorKind.LAST_VALUE = AggregatorKind.LAST_VALUE;\n\n  createAccumulation(startTime: HrTime) {\n    return new LastValueAccumulation(startTime);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   *\n   * Return the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  merge(\n    previous: LastValueAccumulation,\n    delta: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(delta.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? delta\n        : previous;\n    return new LastValueAccumulation(\n      previous.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   *\n   * A delta aggregation is not meaningful to LastValueAggregator, just return\n   * the newly captured (delta) accumulation for LastValueAggregator.\n   */\n  diff(\n    previous: LastValueAccumulation,\n    current: LastValueAccumulation\n  ): LastValueAccumulation {\n    // nanoseconds may lose precisions.\n    const latestAccumulation =\n      hrTimeToMicroseconds(current.sampleTime) >=\n      hrTimeToMicroseconds(previous.sampleTime)\n        ? current\n        : previous;\n    return new LastValueAccumulation(\n      current.startTime,\n      latestAccumulation.toPointValue(),\n      latestAccumulation.sampleTime\n    );\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<LastValueAccumulation>[],\n    endTime: HrTime\n  ): Maybe<GaugeMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.GAUGE,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Sum,\n  AggregatorKind,\n  Aggregator,\n  Accumulation,\n  AccumulationRecord,\n} from './types';\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  DataPointType,\n  MetricDescriptor,\n  SumMetricData,\n} from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\n\nexport class SumAccumulation implements Accumulation {\n  constructor(\n    public startTime: HrTime,\n    public monotonic: boolean,\n    private _current: number = 0,\n    public reset = false\n  ) {}\n\n  record(value: number): void {\n    if (this.monotonic && value < 0) {\n      return;\n    }\n    this._current += value;\n  }\n\n  setStartTime(startTime: HrTime): void {\n    this.startTime = startTime;\n  }\n\n  toPointValue(): Sum {\n    return this._current;\n  }\n}\n\n/** Basic aggregator which calculates a Sum from individual measurements. */\nexport class SumAggregator implements Aggregator<SumAccumulation> {\n  public kind: AggregatorKind.SUM = AggregatorKind.SUM;\n\n  constructor(public monotonic: boolean) {}\n\n  createAccumulation(startTime: HrTime) {\n    return new SumAccumulation(startTime, this.monotonic);\n  }\n\n  /**\n   * Returns the result of the merge of the given accumulations.\n   */\n  merge(previous: SumAccumulation, delta: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const deltaPv = delta.toPointValue();\n    if (delta.reset) {\n      return new SumAccumulation(\n        delta.startTime,\n        this.monotonic,\n        deltaPv,\n        delta.reset\n      );\n    }\n    return new SumAccumulation(\n      previous.startTime,\n      this.monotonic,\n      prevPv + deltaPv\n    );\n  }\n\n  /**\n   * Returns a new DELTA aggregation by comparing two cumulative measurements.\n   */\n  diff(previous: SumAccumulation, current: SumAccumulation): SumAccumulation {\n    const prevPv = previous.toPointValue();\n    const currPv = current.toPointValue();\n    /**\n     * If the SumAggregator is a monotonic one and the previous point value is\n     * greater than the current one, a reset is deemed to be happened.\n     * Return the current point value to prevent the value from been reset.\n     */\n    if (this.monotonic && prevPv > currPv) {\n      return new SumAccumulation(\n        current.startTime,\n        this.monotonic,\n        currPv,\n        true\n      );\n    }\n    return new SumAccumulation(\n      current.startTime,\n      this.monotonic,\n      currPv - prevPv\n    );\n  }\n\n  toMetricData(\n    descriptor: MetricDescriptor,\n    aggregationTemporality: AggregationTemporality,\n    accumulationByAttributes: AccumulationRecord<SumAccumulation>[],\n    endTime: HrTime\n  ): Maybe<SumMetricData> {\n    return {\n      descriptor,\n      aggregationTemporality,\n      dataPointType: DataPointType.SUM,\n      dataPoints: accumulationByAttributes.map(([attributes, accumulation]) => {\n        return {\n          attributes,\n          startTime: accumulation.startTime,\n          endTime,\n          value: accumulation.toPointValue(),\n        };\n      }),\n      isMonotonic: this.monotonic,\n    };\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  Aggregator,\n  SumAggregator,\n  DropAggregator,\n  LastValueAggregator,\n  HistogramAggregator,\n  ExponentialHistogramAggregator,\n} from '../aggregator';\nimport { Accumulation } from '../aggregator/types';\nimport { InstrumentDescriptor, InstrumentType } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\n\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nexport abstract class Aggregation {\n  abstract createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>>;\n\n  static Drop(): Aggregation {\n    return DROP_AGGREGATION;\n  }\n\n  static Sum(): Aggregation {\n    return SUM_AGGREGATION;\n  }\n\n  static LastValue(): Aggregation {\n    return LAST_VALUE_AGGREGATION;\n  }\n\n  static Histogram(): Aggregation {\n    return HISTOGRAM_AGGREGATION;\n  }\n\n  static ExponentialHistogram(): Aggregation {\n    return EXPONENTIAL_HISTOGRAM_AGGREGATION;\n  }\n\n  static Default(): Aggregation {\n    return DEFAULT_AGGREGATION;\n  }\n}\n\n/**\n * The default drop aggregation.\n */\nexport class DropAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default sum aggregation.\n */\nexport class SumAggregation extends Aggregation {\n  private static MONOTONIC_INSTANCE = new SumAggregator(true);\n  private static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument: InstrumentDescriptor) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM: {\n        return SumAggregation.MONOTONIC_INSTANCE;\n      }\n      default: {\n        return SumAggregation.NON_MONOTONIC_INSTANCE;\n      }\n    }\n  }\n}\n\n/**\n * The default last value aggregation.\n */\nexport class LastValueAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default histogram aggregation.\n */\nexport class HistogramAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new HistogramAggregator(\n    [0, 5, 10, 25, 50, 75, 100, 250, 500, 750, 1000, 2500, 5000, 7500, 10000],\n    true\n  );\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation extends Aggregation {\n  private _boundaries: number[];\n\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(\n    boundaries: number[],\n    private readonly _recordMinMax = true\n  ) {\n    super();\n    if (boundaries == null) {\n      throw new Error(\n        'ExplicitBucketHistogramAggregation should be created with explicit boundaries, if a single bucket histogram is required, please pass an empty array'\n      );\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex: number | undefined = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\n\nexport class ExponentialHistogramAggregation extends Aggregation {\n  constructor(\n    private readonly _maxSize: number = 160,\n    private readonly _recordMinMax = true\n  ) {\n    super();\n  }\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new ExponentialHistogramAggregator(\n      this._maxSize,\n      this._recordMinMax\n    );\n  }\n}\n\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation extends Aggregation {\n  private _resolve(instrument: InstrumentDescriptor): Aggregation {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type as unknown) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {\n        return SUM_AGGREGATION;\n      }\n      case InstrumentType.GAUGE:\n      case InstrumentType.OBSERVABLE_GAUGE: {\n        return LAST_VALUE_AGGREGATION;\n      }\n      case InstrumentType.HISTOGRAM: {\n        if (instrument.advice.explicitBucketBoundaries) {\n          return new ExplicitBucketHistogramAggregation(\n            instrument.advice.explicitBucketBoundaries\n          );\n        }\n        return HISTOGRAM_AGGREGATION;\n      }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n\n  createAggregator(\n    instrument: InstrumentDescriptor\n  ): Aggregator<Maybe<Accumulation>> {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\n\nconst DROP_AGGREGATION = new DropAggregation();\nconst SUM_AGGREGATION = new SumAggregation();\nconst LAST_VALUE_AGGREGATION = new LastValueAggregation();\nconst HISTOGRAM_AGGREGATION = new HistogramAggregation();\nconst EXPONENTIAL_HISTOGRAM_AGGREGATION = new ExponentialHistogramAggregation();\nconst DEFAULT_AGGREGATION = new DefaultAggregation();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { Aggregation } from '../view/Aggregation';\nimport { AggregationTemporality } from './AggregationTemporality';\n\n/**\n * Aggregation selector based on metric instrument types.\n */\nexport type AggregationSelector = (\n  instrumentType: InstrumentType\n) => Aggregation;\n\n/**\n * Aggregation temporality selector based on metric instrument types.\n */\nexport type AggregationTemporalitySelector = (\n  instrumentType: InstrumentType\n) => AggregationTemporality;\n\nexport const DEFAULT_AGGREGATION_SELECTOR: AggregationSelector =\n  _instrumentType => Aggregation.Default();\nexport const DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR: AggregationTemporalitySelector =\n  _instrumentType => AggregationTemporality.CUMULATIVE;\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { MetricProducer } from './MetricProducer';\nimport { CollectionResult } from './MetricData';\nimport { FlatMap, callWithTimeout } from '../utils';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport {\n  CollectionOptions,\n  ForceFlushOptions,\n  ShutdownOptions,\n} from '../types';\nimport { Aggregation } from '../view/Aggregation';\nimport {\n  AggregationSelector,\n  AggregationTemporalitySelector,\n  DEFAULT_AGGREGATION_SELECTOR,\n  DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR,\n} from './AggregationSelector';\nimport { CardinalitySelector } from './CardinalitySelector';\n\nexport interface MetricReaderOptions {\n  /**\n   * Aggregation selector based on metric instrument types. If no views are\n   * configured for a metric instrument, a per-metric-reader aggregation is\n   * selected with this selector.\n   */\n  aggregationSelector?: AggregationSelector;\n  /**\n   * Aggregation temporality selector based on metric instrument types. If\n   * not configured, cumulative is used for all instruments.\n   */\n  aggregationTemporalitySelector?: AggregationTemporalitySelector;\n  /**\n   * Cardinality selector based on metric instrument types. If not configured,\n   * a default value is used.\n   */\n  cardinalitySelector?: CardinalitySelector;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n}\n\n/**\n * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global\n * control over metrics.\n */\nexport abstract class MetricReader {\n  // Tracks the shutdown state.\n  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.\n  private _shutdown = false;\n  // Additional MetricProducers which will be combined with the SDK's output\n  private _metricProducers: MetricProducer[];\n  // MetricProducer used by this instance which produces metrics from the SDK\n  private _sdkMetricProducer?: MetricProducer;\n  private readonly _aggregationTemporalitySelector: AggregationTemporalitySelector;\n  private readonly _aggregationSelector: AggregationSelector;\n  private readonly _cardinalitySelector?: CardinalitySelector;\n\n  constructor(options?: MetricReaderOptions) {\n    this._aggregationSelector =\n      options?.aggregationSelector ?? DEFAULT_AGGREGATION_SELECTOR;\n    this._aggregationTemporalitySelector =\n      options?.aggregationTemporalitySelector ??\n      DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n    this._metricProducers = options?.metricProducers ?? [];\n    this._cardinalitySelector = options?.cardinalitySelector;\n  }\n\n  /**\n   * Set the {@link MetricProducer} used by this instance. **This should only be called by the\n   * SDK and should be considered internal.**\n   *\n   * To add additional {@link MetricProducer}s to a {@link MetricReader}, pass them to the\n   * constructor as {@link MetricReaderOptions.metricProducers}.\n   *\n   * @internal\n   * @param metricProducer\n   */\n  setMetricProducer(metricProducer: MetricProducer) {\n    if (this._sdkMetricProducer) {\n      throw new Error(\n        'MetricReader can not be bound to a MeterProvider again.'\n      );\n    }\n    this._sdkMetricProducer = metricProducer;\n    this.onInitialized();\n  }\n\n  /**\n   * Select the {@link Aggregation} for the given {@link InstrumentType} for this\n   * reader.\n   */\n  selectAggregation(instrumentType: InstrumentType): Aggregation {\n    return this._aggregationSelector(instrumentType);\n  }\n\n  /**\n   * Select the {@link AggregationTemporality} for the given\n   * {@link InstrumentType} for this reader.\n   */\n  selectAggregationTemporality(\n    instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporalitySelector(instrumentType);\n  }\n\n  /**\n   * Select the cardinality limit for the given {@link InstrumentType} for this\n   * reader.\n   */\n  selectCardinalityLimit(instrumentType: InstrumentType): number {\n    return this._cardinalitySelector\n      ? this._cardinalitySelector(instrumentType)\n      : 2000; // default value if no selector is provided\n  }\n\n  /**\n   * Handle once the SDK has initialized this {@link MetricReader}\n   * Overriding this method is optional.\n   */\n  protected onInitialized(): void {\n    // Default implementation is empty.\n  }\n\n  /**\n   * Handle a shutdown signal by the SDK.\n   *\n   * <p> For push exporters, this should shut down any intervals and close any open connections.\n   * @protected\n   */\n  protected abstract onShutdown(): Promise<void>;\n\n  /**\n   * Handle a force flush signal by the SDK.\n   *\n   * <p> In all scenarios metrics should be collected via {@link collect()}.\n   * <p> For push exporters, this should collect and report metrics.\n   * @protected\n   */\n  protected abstract onForceFlush(): Promise<void>;\n\n  /**\n   * Collect all metrics from the associated {@link MetricProducer}\n   */\n  async collect(options?: CollectionOptions): Promise<CollectionResult> {\n    if (this._sdkMetricProducer === undefined) {\n      throw new Error('MetricReader is not bound to a MetricProducer');\n    }\n\n    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.\n    if (this._shutdown) {\n      throw new Error('MetricReader is shutdown');\n    }\n\n    const [sdkCollectionResults, ...additionalCollectionResults] =\n      await Promise.all([\n        this._sdkMetricProducer.collect({\n          timeoutMillis: options?.timeoutMillis,\n        }),\n        ...this._metricProducers.map(producer =>\n          producer.collect({\n            timeoutMillis: options?.timeoutMillis,\n          })\n        ),\n      ]);\n\n    // Merge the results, keeping the SDK's Resource\n    const errors = sdkCollectionResults.errors.concat(\n      FlatMap(additionalCollectionResults, result => result.errors)\n    );\n    const resource = sdkCollectionResults.resourceMetrics.resource;\n    const scopeMetrics =\n      sdkCollectionResults.resourceMetrics.scopeMetrics.concat(\n        FlatMap(\n          additionalCollectionResults,\n          result => result.resourceMetrics.scopeMetrics\n        )\n      );\n    return {\n      resourceMetrics: {\n        resource,\n        scopeMetrics,\n      },\n      errors,\n    };\n  }\n\n  /**\n   * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    // Do not call shutdown again if it has already been called.\n    if (this._shutdown) {\n      api.diag.error('Cannot call shutdown twice.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onShutdown();\n    } else {\n      await callWithTimeout(this.onShutdown(), options.timeoutMillis);\n    }\n\n    this._shutdown = true;\n  }\n\n  /**\n   * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    if (this._shutdown) {\n      api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onForceFlush();\n      return;\n    }\n\n    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n  unrefTimer,\n} from '@opentelemetry/core';\nimport { MetricReader } from './MetricReader';\nimport { PushMetricExporter } from './MetricExporter';\nimport { callWithTimeout, TimeoutError } from '../utils';\nimport { MetricProducer } from './MetricProducer';\n\nexport type PeriodicExportingMetricReaderOptions = {\n  /**\n   * The backing exporter for the metric reader.\n   */\n  exporter: PushMetricExporter;\n  /**\n   * An internal milliseconds for the metric reader to initiate metric\n   * collection.\n   */\n  exportIntervalMillis?: number;\n  /**\n   * Milliseconds for the async observable callback to timeout.\n   */\n  exportTimeoutMillis?: number;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n};\n\n/**\n * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to\n * the configured {@link PushMetricExporter}\n */\nexport class PeriodicExportingMetricReader extends MetricReader {\n  private _interval?: ReturnType<typeof setInterval>;\n  private _exporter: PushMetricExporter;\n  private readonly _exportInterval: number;\n  private readonly _exportTimeout: number;\n\n  constructor(options: PeriodicExportingMetricReaderOptions) {\n    super({\n      aggregationSelector: options.exporter.selectAggregation?.bind(\n        options.exporter\n      ),\n      aggregationTemporalitySelector:\n        options.exporter.selectAggregationTemporality?.bind(options.exporter),\n      metricProducers: options.metricProducers,\n    });\n\n    if (\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis <= 0\n    ) {\n      throw Error('exportIntervalMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportTimeoutMillis <= 0\n    ) {\n      throw Error('exportTimeoutMillis must be greater than 0');\n    }\n\n    if (\n      options.exportTimeoutMillis !== undefined &&\n      options.exportIntervalMillis !== undefined &&\n      options.exportIntervalMillis < options.exportTimeoutMillis\n    ) {\n      throw Error(\n        'exportIntervalMillis must be greater than or equal to exportTimeoutMillis'\n      );\n    }\n\n    this._exportInterval = options.exportIntervalMillis ?? 60000;\n    this._exportTimeout = options.exportTimeoutMillis ?? 30000;\n    this._exporter = options.exporter;\n  }\n\n  private async _runOnce(): Promise<void> {\n    try {\n      await callWithTimeout(this._doRun(), this._exportTimeout);\n    } catch (err) {\n      if (err instanceof TimeoutError) {\n        api.diag.error(\n          'Export took longer than %s milliseconds and timed out.',\n          this._exportTimeout\n        );\n        return;\n      }\n\n      globalErrorHandler(err);\n    }\n  }\n\n  private async _doRun(): Promise<void> {\n    const { resourceMetrics, errors } = await this.collect({\n      timeoutMillis: this._exportTimeout,\n    });\n\n    if (errors.length > 0) {\n      api.diag.error(\n        'PeriodicExportingMetricReader: metrics collection errors',\n        ...errors\n      );\n    }\n\n    if (resourceMetrics.resource.asyncAttributesPending) {\n      try {\n        await resourceMetrics.resource.waitForAsyncAttributes?.();\n      } catch (e) {\n        api.diag.debug('Error while resolving async portion of resource: ', e);\n        globalErrorHandler(e);\n      }\n    }\n\n    const result = await internal._export(this._exporter, resourceMetrics);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw new Error(\n        `PeriodicExportingMetricReader: metrics export failed (error ${result.error})`\n      );\n    }\n  }\n\n  protected override onInitialized(): void {\n    // start running the interval as soon as this reader is initialized and keep handle for shutdown.\n    this._interval = setInterval(() => {\n      // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.\n      void this._runOnce();\n    }, this._exportInterval);\n    unrefTimer(this._interval);\n  }\n\n  protected async onForceFlush(): Promise<void> {\n    await this._runOnce();\n    await this._exporter.forceFlush();\n  }\n\n  protected async onShutdown(): Promise<void> {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n\n    await this._exporter.shutdown();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResultCode } from '@opentelemetry/core';\nimport { ExportResult } from '@opentelemetry/core';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { ResourceMetrics } from './MetricData';\nimport { PushMetricExporter } from './MetricExporter';\n\n/**\n * In-memory Metrics Exporter is a Push Metric Exporter\n * which accumulates metrics data in the local memory and\n * allows to inspect it (useful for e.g. unit tests).\n */\nexport class InMemoryMetricExporter implements PushMetricExporter {\n  protected _shutdown = false;\n  protected _aggregationTemporality: AggregationTemporality;\n  private _metrics: ResourceMetrics[] = [];\n\n  constructor(aggregationTemporality: AggregationTemporality) {\n    this._aggregationTemporality = aggregationTemporality;\n  }\n\n  /**\n   * @inheritedDoc\n   */\n  export(\n    metrics: ResourceMetrics,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    // Avoid storing metrics when exporter is shutdown\n    if (this._shutdown) {\n      setTimeout(() => resultCallback({ code: ExportResultCode.FAILED }), 0);\n      return;\n    }\n\n    this._metrics.push(metrics);\n    setTimeout(() => resultCallback({ code: ExportResultCode.SUCCESS }), 0);\n  }\n\n  /**\n   * Returns all the collected resource metrics\n   * @returns ResourceMetrics[]\n   */\n  public getMetrics(): ResourceMetrics[] {\n    return this._metrics;\n  }\n\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  reset() {\n    this._metrics = [];\n  }\n\n  selectAggregationTemporality(\n    _instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._aggregationTemporality;\n  }\n\n  shutdown(): Promise<void> {\n    this._shutdown = true;\n    return Promise.resolve();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { ResourceMetrics } from './MetricData';\nimport { PushMetricExporter } from './MetricExporter';\nimport {\n  AggregationTemporalitySelector,\n  DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR,\n} from './AggregationSelector';\n\ninterface ConsoleMetricExporterOptions {\n  temporalitySelector?: AggregationTemporalitySelector;\n}\n\n/**\n * This is an implementation of {@link PushMetricExporter} that prints metrics to the\n * console. This class can be used for diagnostic purposes.\n *\n * NOTE: This {@link PushMetricExporter} is intended for diagnostics use only, output rendered to the console may change at any time.\n */\n\n/* eslint-disable no-console */\nexport class ConsoleMetricExporter implements PushMetricExporter {\n  protected _shutdown = false;\n  protected _temporalitySelector: AggregationTemporalitySelector;\n\n  constructor(options?: ConsoleMetricExporterOptions) {\n    this._temporalitySelector =\n      options?.temporalitySelector ?? DEFAULT_AGGREGATION_TEMPORALITY_SELECTOR;\n  }\n\n  export(\n    metrics: ResourceMetrics,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    if (this._shutdown) {\n      // If the exporter is shutting down, by spec, we need to return FAILED as export result\n      setImmediate(resultCallback, { code: ExportResultCode.FAILED });\n      return;\n    }\n\n    return ConsoleMetricExporter._sendMetrics(metrics, resultCallback);\n  }\n\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  selectAggregationTemporality(\n    _instrumentType: InstrumentType\n  ): AggregationTemporality {\n    return this._temporalitySelector(_instrumentType);\n  }\n\n  shutdown(): Promise<void> {\n    this._shutdown = true;\n    return Promise.resolve();\n  }\n\n  private static _sendMetrics(\n    metrics: ResourceMetrics,\n    done: (result: ExportResult) => void\n  ): void {\n    for (const scopeMetrics of metrics.scopeMetrics) {\n      for (const metric of scopeMetrics.metrics) {\n        console.dir(\n          {\n            descriptor: metric.descriptor,\n            dataPointType: metric.dataPointType,\n            dataPoints: metric.dataPoints,\n          },\n          { depth: null }\n        );\n      }\n    }\n\n    done({ code: ExportResultCode.SUCCESS });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { InstrumentSelector } from './InstrumentSelector';\nimport { MeterSelector } from './MeterSelector';\nimport { View } from './View';\n\nexport class ViewRegistry {\n  private _registeredViews: View[] = [];\n\n  addView(view: View) {\n    this._registeredViews.push(view);\n  }\n\n  findViews(\n    instrument: InstrumentDescriptor,\n    meter: InstrumentationScope\n  ): View[] {\n    const views = this._registeredViews.filter(registeredView => {\n      return (\n        this._matchInstrument(registeredView.instrumentSelector, instrument) &&\n        this._matchMeter(registeredView.meterSelector, meter)\n      );\n    });\n\n    return views;\n  }\n\n  private _matchInstrument(\n    selector: InstrumentSelector,\n    instrument: InstrumentDescriptor\n  ): boolean {\n    return (\n      (selector.getType() === undefined ||\n        instrument.type === selector.getType()) &&\n      selector.getNameFilter().match(instrument.name) &&\n      selector.getUnitFilter().match(instrument.unit)\n    );\n  }\n\n  private _matchMeter(\n    selector: MeterSelector,\n    meter: InstrumentationScope\n  ): boolean {\n    return (\n      selector.getNameFilter().match(meter.name) &&\n      (meter.version === undefined ||\n        selector.getVersionFilter().match(meter.version)) &&\n      (meter.schemaUrl === undefined ||\n        selector.getSchemaUrlFilter().match(meter.schemaUrl))\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  context as contextApi,\n  diag,\n  Context,\n  Attributes,\n  ValueType,\n  UpDownCounter,\n  Counter,\n  Histogram,\n  Observable,\n  ObservableCallback,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n} from '@opentelemetry/api';\nimport { millisToHrTime } from '@opentelemetry/core';\nimport { InstrumentDescriptor } from './InstrumentDescriptor';\nimport { ObservableRegistry } from './state/ObservableRegistry';\nimport {\n  AsyncWritableMetricStorage,\n  WritableMetricStorage,\n} from './state/WritableMetricStorage';\nimport { Gauge } from './types';\n\nexport class SyncInstrument {\n  constructor(\n    private _writableMetricStorage: WritableMetricStorage,\n    protected _descriptor: InstrumentDescriptor\n  ) {}\n\n  protected _record(\n    value: number,\n    attributes: Attributes = {},\n    context: Context = contextApi.active()\n  ) {\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${this._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    if (\n      this._descriptor.valueType === ValueType.INT &&\n      !Number.isInteger(value)\n    ) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    this._writableMetricStorage.record(\n      value,\n      attributes,\n      context,\n      millisToHrTime(Date.now())\n    );\n  }\n}\n\n/**\n * The class implements {@link UpDownCounter} interface.\n */\nexport class UpDownCounterInstrument\n  extends SyncInstrument\n  implements UpDownCounter\n{\n  /**\n   * Increment value of counter by the input. Inputs may be negative.\n   */\n  add(value: number, attributes?: Attributes, ctx?: Context): void {\n    this._record(value, attributes, ctx);\n  }\n}\n\n/**\n * The class implements {@link Counter} interface.\n */\nexport class CounterInstrument extends SyncInstrument implements Counter {\n  /**\n   * Increment value of counter by the input. Inputs may not be negative.\n   */\n  add(value: number, attributes?: Attributes, ctx?: Context): void {\n    if (value < 0) {\n      diag.warn(\n        `negative value provided to counter ${this._descriptor.name}: ${value}`\n      );\n      return;\n    }\n\n    this._record(value, attributes, ctx);\n  }\n}\n\n/**\n * The class implements {@link Gauge} interface.\n */\nexport class GaugeInstrument extends SyncInstrument implements Gauge {\n  /**\n   * Records a measurement.\n   */\n  record(value: number, attributes?: Attributes, ctx?: Context): void {\n    this._record(value, attributes, ctx);\n  }\n}\n\n/**\n * The class implements {@link Histogram} interface.\n */\nexport class HistogramInstrument extends SyncInstrument implements Histogram {\n  /**\n   * Records a measurement. Value of the measurement must not be negative.\n   */\n  record(value: number, attributes?: Attributes, ctx?: Context): void {\n    if (value < 0) {\n      diag.warn(\n        `negative value provided to histogram ${this._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    this._record(value, attributes, ctx);\n  }\n}\n\nexport class ObservableInstrument implements Observable {\n  /** @internal */\n  _metricStorages: AsyncWritableMetricStorage[];\n  /** @internal */\n  _descriptor: InstrumentDescriptor;\n\n  constructor(\n    descriptor: InstrumentDescriptor,\n    metricStorages: AsyncWritableMetricStorage[],\n    private _observableRegistry: ObservableRegistry\n  ) {\n    this._descriptor = descriptor;\n    this._metricStorages = metricStorages;\n  }\n\n  /**\n   * @see {Observable.addCallback}\n   */\n  addCallback(callback: ObservableCallback) {\n    this._observableRegistry.addCallback(callback, this);\n  }\n\n  /**\n   * @see {Observable.removeCallback}\n   */\n  removeCallback(callback: ObservableCallback) {\n    this._observableRegistry.removeCallback(callback, this);\n  }\n}\n\nexport class ObservableCounterInstrument\n  extends ObservableInstrument\n  implements ObservableCounter {}\nexport class ObservableGaugeInstrument\n  extends ObservableInstrument\n  implements ObservableGauge {}\nexport class ObservableUpDownCounterInstrument\n  extends ObservableInstrument\n  implements ObservableUpDownCounter {}\n\nexport function isObservableInstrument(\n  it: unknown\n): it is ObservableInstrument {\n  return it instanceof ObservableInstrument;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Meter as IMeter,\n  MetricOptions,\n  Histogram,\n  Counter,\n  UpDownCounter,\n  ObservableGauge,\n  ObservableCounter,\n  ObservableUpDownCounter,\n  BatchObservableCallback,\n  Observable,\n} from '@opentelemetry/api';\nimport {\n  createInstrumentDescriptor,\n  InstrumentType,\n} from './InstrumentDescriptor';\nimport {\n  CounterInstrument,\n  GaugeInstrument,\n  HistogramInstrument,\n  ObservableCounterInstrument,\n  ObservableGaugeInstrument,\n  ObservableUpDownCounterInstrument,\n  UpDownCounterInstrument,\n} from './Instruments';\nimport { MeterSharedState } from './state/MeterSharedState';\nimport { Gauge } from './types';\n\n/**\n * This class implements the {@link IMeter} interface.\n */\nexport class Meter implements IMeter {\n  constructor(private _meterSharedState: MeterSharedState) {}\n\n  /**\n   * Create a {@link Gauge} instrument.\n   */\n  createGauge(name: string, options?: MetricOptions): Gauge {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.GAUGE,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new GaugeInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link Histogram} instrument.\n   */\n  createHistogram(name: string, options?: MetricOptions): Histogram {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.HISTOGRAM,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new HistogramInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link Counter} instrument.\n   */\n  createCounter(name: string, options?: MetricOptions): Counter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.COUNTER,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new CounterInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link UpDownCounter} instrument.\n   */\n  createUpDownCounter(name: string, options?: MetricOptions): UpDownCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.UP_DOWN_COUNTER,\n      options\n    );\n    const storage = this._meterSharedState.registerMetricStorage(descriptor);\n    return new UpDownCounterInstrument(storage, descriptor);\n  }\n\n  /**\n   * Create a {@link ObservableGauge} instrument.\n   */\n  createObservableGauge(\n    name: string,\n    options?: MetricOptions\n  ): ObservableGauge {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_GAUGE,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableGaugeInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * Create a {@link ObservableCounter} instrument.\n   */\n  createObservableCounter(\n    name: string,\n    options?: MetricOptions\n  ): ObservableCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_COUNTER,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableCounterInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * Create a {@link ObservableUpDownCounter} instrument.\n   */\n  createObservableUpDownCounter(\n    name: string,\n    options?: MetricOptions\n  ): ObservableUpDownCounter {\n    const descriptor = createInstrumentDescriptor(\n      name,\n      InstrumentType.OBSERVABLE_UP_DOWN_COUNTER,\n      options\n    );\n    const storages =\n      this._meterSharedState.registerAsyncMetricStorage(descriptor);\n    return new ObservableUpDownCounterInstrument(\n      descriptor,\n      storages,\n      this._meterSharedState.observableRegistry\n    );\n  }\n\n  /**\n   * @see {@link Meter.addBatchObservableCallback}\n   */\n  addBatchObservableCallback(\n    callback: BatchObservableCallback,\n    observables: Observable[]\n  ) {\n    this._meterSharedState.observableRegistry.addBatchCallback(\n      callback,\n      observables\n    );\n  }\n\n  /**\n   * @see {@link Meter.removeBatchObservableCallback}\n   */\n  removeBatchObservableCallback(\n    callback: BatchObservableCallback,\n    observables: Observable[]\n  ) {\n    this._meterSharedState.observableRegistry.removeBatchCallback(\n      callback,\n      observables\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { MetricData } from '../export/MetricData';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport {\n  createInstrumentDescriptor,\n  InstrumentDescriptor,\n} from '../InstrumentDescriptor';\n\n/**\n * Internal interface.\n *\n * Represents a storage from which we can collect metrics.\n */\nexport abstract class MetricStorage {\n  constructor(protected _instrumentDescriptor: InstrumentDescriptor) {}\n\n  /**\n   * Collects the metrics from this storage.\n   *\n   * Note: This is a stateful operation and may reset any interval-related\n   * state for the MetricCollector.\n   */\n  abstract collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime\n  ): Maybe<MetricData>;\n\n  getInstrumentDescriptor(): Readonly<InstrumentDescriptor> {\n    return this._instrumentDescriptor;\n  }\n\n  updateDescription(description: string): void {\n    this._instrumentDescriptor = createInstrumentDescriptor(\n      this._instrumentDescriptor.name,\n      this._instrumentDescriptor.type,\n      {\n        description: description,\n        valueType: this._instrumentDescriptor.valueType,\n        unit: this._instrumentDescriptor.unit,\n        advice: this._instrumentDescriptor.advice,\n      }\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Attributes } from '@opentelemetry/api';\nimport { hashAttributes } from '../utils';\n\nexport interface Hash<ValueType, HashCodeType> {\n  (value: ValueType): HashCodeType;\n}\n\nexport class HashMap<KeyType, ValueType, HashCodeType> {\n  private _valueMap = new Map<HashCodeType, ValueType>();\n  private _keyMap = new Map<HashCodeType, KeyType>();\n\n  constructor(private _hash: Hash<KeyType, HashCodeType>) {}\n\n  get(key: KeyType, hashCode?: HashCodeType) {\n    hashCode ??= this._hash(key);\n    return this._valueMap.get(hashCode);\n  }\n\n  getOrDefault(key: KeyType, defaultFactory: () => ValueType) {\n    const hash = this._hash(key);\n    if (this._valueMap.has(hash)) {\n      return this._valueMap.get(hash);\n    }\n    const val = defaultFactory();\n    if (!this._keyMap.has(hash)) {\n      this._keyMap.set(hash, key);\n    }\n    this._valueMap.set(hash, val);\n    return val;\n  }\n\n  set(key: KeyType, value: ValueType, hashCode?: HashCodeType) {\n    hashCode ??= this._hash(key);\n    if (!this._keyMap.has(hashCode)) {\n      this._keyMap.set(hashCode, key);\n    }\n    this._valueMap.set(hashCode, value);\n  }\n\n  has(key: KeyType, hashCode?: HashCodeType) {\n    hashCode ??= this._hash(key);\n    return this._valueMap.has(hashCode);\n  }\n\n  *keys(): IterableIterator<[KeyType, HashCodeType]> {\n    const keyIterator = this._keyMap.entries();\n    let next = keyIterator.next();\n    while (next.done !== true) {\n      yield [next.value[1], next.value[0]];\n      next = keyIterator.next();\n    }\n  }\n\n  *entries(): IterableIterator<[KeyType, ValueType, HashCodeType]> {\n    const valueIterator = this._valueMap.entries();\n    let next = valueIterator.next();\n    while (next.done !== true) {\n      // next.value[0] here can not be undefined\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      yield [this._keyMap.get(next.value[0])!, next.value[1], next.value[0]];\n      next = valueIterator.next();\n    }\n  }\n\n  get size() {\n    return this._valueMap.size;\n  }\n}\n\nexport class AttributeHashMap<ValueType> extends HashMap<\n  Attributes,\n  ValueType,\n  string\n> {\n  constructor() {\n    super(hashAttributes);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, Attributes } from '@opentelemetry/api';\nimport { Maybe, hashAttributes } from '../utils';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Internal interface.\n *\n * Allows synchronous collection of metrics. This processor should allow\n * allocation of new aggregation cells for metrics and convert cumulative\n * recording to delta data points.\n */\nexport class DeltaMetricProcessor<T extends Maybe<Accumulation>> {\n  private _activeCollectionStorage = new AttributeHashMap<T>();\n  // TODO: find a reasonable mean to clean the memo;\n  // https://github.com/open-telemetry/opentelemetry-specification/pull/2208\n  private _cumulativeMemoStorage = new AttributeHashMap<T>();\n  private _cardinalityLimit: number;\n  private _overflowAttributes = { 'otel.metric.overflow': true };\n  private _overflowHashCode: string;\n\n  constructor(\n    private _aggregator: Aggregator<T>,\n    aggregationCardinalityLimit?: number\n  ) {\n    this._cardinalityLimit = (aggregationCardinalityLimit ?? 2000) - 1;\n    this._overflowHashCode = hashAttributes(this._overflowAttributes);\n  }\n\n  record(\n    value: number,\n    attributes: Attributes,\n    _context: Context,\n    collectionTime: HrTime\n  ) {\n    let accumulation = this._activeCollectionStorage.get(attributes);\n\n    if (!accumulation) {\n      if (this._activeCollectionStorage.size >= this._cardinalityLimit) {\n        const overflowAccumulation = this._activeCollectionStorage.getOrDefault(\n          this._overflowAttributes,\n          () => this._aggregator.createAccumulation(collectionTime)\n        );\n        overflowAccumulation?.record(value);\n        return;\n      }\n\n      accumulation = this._aggregator.createAccumulation(collectionTime);\n      this._activeCollectionStorage.set(attributes, accumulation);\n    }\n\n    accumulation?.record(value);\n  }\n\n  batchCumulate(\n    measurements: AttributeHashMap<number>,\n    collectionTime: HrTime\n  ) {\n    Array.from(measurements.entries()).forEach(\n      ([attributes, value, hashCode]) => {\n        const accumulation =\n          this._aggregator.createAccumulation(collectionTime);\n        accumulation?.record(value);\n        let delta = accumulation;\n        // Diff with recorded cumulative memo.\n        if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n          // has() returned true, previous is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const previous = this._cumulativeMemoStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.diff(previous, accumulation);\n        } else {\n          // If the cardinality limit is reached, we need to change the attributes\n          if (this._cumulativeMemoStorage.size >= this._cardinalityLimit) {\n            attributes = this._overflowAttributes;\n            hashCode = this._overflowHashCode;\n            if (this._cumulativeMemoStorage.has(attributes, hashCode)) {\n              const previous = this._cumulativeMemoStorage.get(\n                attributes,\n                hashCode\n              )!;\n              delta = this._aggregator.diff(previous, accumulation);\n            }\n          }\n        }\n        // Merge with uncollected active delta.\n        if (this._activeCollectionStorage.has(attributes, hashCode)) {\n          // has() returned true, previous is present.\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const active = this._activeCollectionStorage.get(\n            attributes,\n            hashCode\n          )!;\n          delta = this._aggregator.merge(active, delta);\n        }\n\n        // Save the current record and the delta record.\n        this._cumulativeMemoStorage.set(attributes, accumulation, hashCode);\n        this._activeCollectionStorage.set(attributes, delta, hashCode);\n      }\n    );\n  }\n\n  /**\n   * Returns a collection of delta metrics. Start time is the when first\n   * time event collected.\n   */\n  collect() {\n    const unreportedDelta = this._activeCollectionStorage;\n    this._activeCollectionStorage = new AttributeHashMap();\n\n    return unreportedDelta;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  Accumulation,\n  AccumulationRecord,\n  Aggregator,\n} from '../aggregator/types';\nimport { MetricData } from '../export/MetricData';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { AggregationTemporality } from '../export/AggregationTemporality';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { AttributeHashMap } from './HashMap';\n\n/**\n * Remembers what was presented to a specific exporter.\n */\ninterface LastReportedHistory<T extends Maybe<Accumulation>> {\n  /**\n   * The last accumulation of metric data.\n   */\n  accumulations: AttributeHashMap<T>;\n  /**\n   * The timestamp the data was reported.\n   */\n  collectionTime: HrTime;\n  /**\n   * The AggregationTemporality used to aggregate reports.\n   */\n  aggregationTemporality: AggregationTemporality;\n}\n\n/**\n * Internal interface.\n *\n * Provides unique reporting for each collector. Allows synchronous collection\n * of metrics and reports given temporality values.\n */\nexport class TemporalMetricProcessor<T extends Maybe<Accumulation>> {\n  private _unreportedAccumulations = new Map<\n    MetricCollectorHandle,\n    AttributeHashMap<T>[]\n  >();\n  private _reportHistory = new Map<\n    MetricCollectorHandle,\n    LastReportedHistory<T>\n  >();\n\n  constructor(\n    private _aggregator: Aggregator<T>,\n    collectorHandles: MetricCollectorHandle[]\n  ) {\n    collectorHandles.forEach(handle => {\n      this._unreportedAccumulations.set(handle, []);\n    });\n  }\n\n  /**\n   * Builds the {@link MetricData} streams to report against a specific MetricCollector.\n   * @param collector The information of the MetricCollector.\n   * @param collectors The registered collectors.\n   * @param instrumentDescriptor The instrumentation descriptor that these metrics generated with.\n   * @param currentAccumulations The current accumulation of metric data from instruments.\n   * @param collectionTime The current collection timestamp.\n   * @returns The {@link MetricData} points or `null`.\n   */\n  buildMetrics(\n    collector: MetricCollectorHandle,\n    instrumentDescriptor: InstrumentDescriptor,\n    currentAccumulations: AttributeHashMap<T>,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    this._stashAccumulations(currentAccumulations);\n    const unreportedAccumulations =\n      this._getMergedUnreportedAccumulations(collector);\n\n    let result = unreportedAccumulations;\n    let aggregationTemporality: AggregationTemporality;\n    // Check our last report time.\n    if (this._reportHistory.has(collector)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const last = this._reportHistory.get(collector)!;\n      const lastCollectionTime = last.collectionTime;\n      aggregationTemporality = last.aggregationTemporality;\n\n      // Use aggregation temporality + instrument to determine if we do a merge or a diff of\n      // previous. We have the following four scenarios:\n      // 1. Cumulative Aggregation (temporality) + Delta recording (sync instrument).\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 2. Cumulative Aggregation + Cumulative recording (async instrument).\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Here we merge with our last record to get a cumulative aggregation.\n      // 3. Delta Aggregation + Delta recording\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      // 4. Delta Aggregation + Cumulative recording.\n      //    Cumulative records are converted to delta recording with DeltaMetricProcessor.\n      //    Calibrate the startTime of metric streams to be the reader's lastCollectionTime.\n      if (aggregationTemporality === AggregationTemporality.CUMULATIVE) {\n        // We need to make sure the current delta recording gets merged into the previous cumulative\n        // for the next cumulative recording.\n        result = TemporalMetricProcessor.merge(\n          last.accumulations,\n          unreportedAccumulations,\n          this._aggregator\n        );\n      } else {\n        result = TemporalMetricProcessor.calibrateStartTime(\n          last.accumulations,\n          unreportedAccumulations,\n          lastCollectionTime\n        );\n      }\n    } else {\n      // Call into user code to select aggregation temporality for the instrument.\n      aggregationTemporality = collector.selectAggregationTemporality(\n        instrumentDescriptor.type\n      );\n    }\n\n    // Update last reported (cumulative) accumulation.\n    this._reportHistory.set(collector, {\n      accumulations: result,\n      collectionTime,\n      aggregationTemporality,\n    });\n\n    const accumulationRecords = AttributesMapToAccumulationRecords(result);\n\n    // do not convert to metric data if there is nothing to convert.\n    if (accumulationRecords.length === 0) {\n      return undefined;\n    }\n\n    return this._aggregator.toMetricData(\n      instrumentDescriptor,\n      aggregationTemporality,\n      accumulationRecords,\n      /* endTime */ collectionTime\n    );\n  }\n\n  private _stashAccumulations(currentAccumulation: AttributeHashMap<T>) {\n    const registeredCollectors = this._unreportedAccumulations.keys();\n    for (const collector of registeredCollectors) {\n      let stash = this._unreportedAccumulations.get(collector);\n      if (stash === undefined) {\n        stash = [];\n        this._unreportedAccumulations.set(collector, stash);\n      }\n      stash.push(currentAccumulation);\n    }\n  }\n\n  private _getMergedUnreportedAccumulations(collector: MetricCollectorHandle) {\n    let result = new AttributeHashMap<T>();\n    const unreportedList = this._unreportedAccumulations.get(collector);\n    this._unreportedAccumulations.set(collector, []);\n    if (unreportedList === undefined) {\n      return result;\n    }\n    for (const it of unreportedList) {\n      result = TemporalMetricProcessor.merge(result, it, this._aggregator);\n    }\n    return result;\n  }\n\n  static merge<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    aggregator: Aggregator<T>\n  ) {\n    const result = last;\n    const iterator = current.entries();\n    let next = iterator.next();\n    while (next.done !== true) {\n      const [key, record, hash] = next.value;\n      if (last.has(key, hash)) {\n        const lastAccumulation = last.get(key, hash);\n        // last.has() returned true, lastAccumulation is present.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const accumulation = aggregator.merge(lastAccumulation!, record);\n        result.set(key, accumulation, hash);\n      } else {\n        result.set(key, record, hash);\n      }\n\n      next = iterator.next();\n    }\n    return result;\n  }\n\n  /**\n   * Calibrate the reported metric streams' startTime to lastCollectionTime. Leaves\n   * the new stream to be the initial observation time unchanged.\n   */\n  static calibrateStartTime<T extends Maybe<Accumulation>>(\n    last: AttributeHashMap<T>,\n    current: AttributeHashMap<T>,\n    lastCollectionTime: HrTime\n  ) {\n    for (const [key, hash] of last.keys()) {\n      const currentAccumulation = current.get(key, hash);\n      currentAccumulation?.setStartTime(lastCollectionTime);\n    }\n    return current;\n  }\n}\n\n// TypeScript complains about converting 3 elements tuple to AccumulationRecord<T>.\nfunction AttributesMapToAccumulationRecords<T>(\n  map: AttributeHashMap<T>\n): AccumulationRecord<T>[] {\n  return Array.from(map.entries()) as unknown as AccumulationRecord<T>[];\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { AttributesProcessor } from '../view/AttributesProcessor';\nimport { MetricStorage } from './MetricStorage';\nimport { MetricData } from '../export/MetricData';\nimport { DeltaMetricProcessor } from './DeltaMetricProcessor';\nimport { TemporalMetricProcessor } from './TemporalMetricProcessor';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { AttributeHashMap } from './HashMap';\nimport { AsyncWritableMetricStorage } from './WritableMetricStorage';\n\n/**\n * Internal interface.\n *\n * Stores and aggregates {@link MetricData} for asynchronous instruments.\n */\nexport class AsyncMetricStorage<T extends Maybe<Accumulation>>\n  extends MetricStorage\n  implements AsyncWritableMetricStorage\n{\n  private _deltaMetricStorage: DeltaMetricProcessor<T>;\n  private _temporalMetricStorage: TemporalMetricProcessor<T>;\n\n  constructor(\n    _instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<T>,\n    private _attributesProcessor: AttributesProcessor,\n    collectorHandles: MetricCollectorHandle[],\n    private _aggregationCardinalityLimit?: number\n  ) {\n    super(_instrumentDescriptor);\n    this._deltaMetricStorage = new DeltaMetricProcessor(\n      aggregator,\n      this._aggregationCardinalityLimit\n    );\n    this._temporalMetricStorage = new TemporalMetricProcessor(\n      aggregator,\n      collectorHandles\n    );\n  }\n\n  record(measurements: AttributeHashMap<number>, observationTime: HrTime) {\n    const processed = new AttributeHashMap<number>();\n    Array.from(measurements.entries()).forEach(([attributes, value]) => {\n      processed.set(this._attributesProcessor.process(attributes), value);\n    });\n    this._deltaMetricStorage.batchCumulate(processed, observationTime);\n  }\n\n  /**\n   * Collects the metrics from this storage. The ObservableCallback is invoked\n   * during the collection.\n   *\n   * Note: This is a stateful operation and may reset any interval-related\n   * state for the MetricCollector.\n   */\n  collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    const accumulations = this._deltaMetricStorage.collect();\n\n    return this._temporalMetricStorage.buildMetrics(\n      collector,\n      this._instrumentDescriptor,\n      accumulations,\n      collectionTime\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentSelectorCriteria } from './InstrumentSelector';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\n\nexport function getIncompatibilityDetails(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  let incompatibility = '';\n  if (existing.unit !== otherDescriptor.unit) {\n    incompatibility += `\\t- Unit '${existing.unit}' does not match '${otherDescriptor.unit}'\\n`;\n  }\n  if (existing.type !== otherDescriptor.type) {\n    incompatibility += `\\t- Type '${existing.type}' does not match '${otherDescriptor.type}'\\n`;\n  }\n  if (existing.valueType !== otherDescriptor.valueType) {\n    incompatibility += `\\t- Value Type '${existing.valueType}' does not match '${otherDescriptor.valueType}'\\n`;\n  }\n  if (existing.description !== otherDescriptor.description) {\n    incompatibility += `\\t- Description '${existing.description}' does not match '${otherDescriptor.description}'\\n`;\n  }\n\n  return incompatibility;\n}\n\nexport function getValueTypeConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  return `\\t- use valueType '${existing.valueType}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;\n}\n\nexport function getUnitConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  return `\\t- use unit '${existing.unit}' on instrument creation or use an instrument name other than '${otherDescriptor.name}'`;\n}\n\nexport function getTypeConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n) {\n  const selector: InstrumentSelectorCriteria = {\n    name: otherDescriptor.name,\n    type: otherDescriptor.type,\n    unit: otherDescriptor.unit,\n  };\n\n  const selectorString = JSON.stringify(selector);\n\n  return `\\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'`;\n}\n\nexport function getDescriptionResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n): string {\n  const selector: InstrumentSelectorCriteria = {\n    name: otherDescriptor.name,\n    type: otherDescriptor.type,\n    unit: otherDescriptor.unit,\n  };\n\n  const selectorString = JSON.stringify(selector);\n\n  return `\\t- create a new view with a name other than '${existing.name}' and InstrumentSelector '${selectorString}'\n    \\t- OR - create a new view with the name ${existing.name} and description '${existing.description}' and InstrumentSelector ${selectorString}\n    \\t- OR - create a new view with the name ${otherDescriptor.name} and description '${existing.description}' and InstrumentSelector ${selectorString}`;\n}\n\nexport function getConflictResolutionRecipe(\n  existing: InstrumentDescriptor,\n  otherDescriptor: InstrumentDescriptor\n): string {\n  // Conflicts that cannot be solved via views.\n  if (existing.valueType !== otherDescriptor.valueType) {\n    return getValueTypeConflictResolutionRecipe(existing, otherDescriptor);\n  }\n\n  if (existing.unit !== otherDescriptor.unit) {\n    return getUnitConflictResolutionRecipe(existing, otherDescriptor);\n  }\n\n  // Conflicts that can be solved via views.\n  if (existing.type !== otherDescriptor.type) {\n    // this will automatically solve possible description conflicts.\n    return getTypeConflictResolutionRecipe(existing, otherDescriptor);\n  }\n\n  if (existing.description !== otherDescriptor.description) {\n    return getDescriptionResolutionRecipe(existing, otherDescriptor);\n  }\n\n  return '';\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MetricStorage } from './MetricStorage';\nimport {\n  InstrumentDescriptor,\n  isDescriptorCompatibleWith,\n} from '../InstrumentDescriptor';\nimport * as api from '@opentelemetry/api';\nimport {\n  getConflictResolutionRecipe,\n  getIncompatibilityDetails,\n} from '../view/RegistrationConflicts';\nimport { MetricCollectorHandle } from './MetricCollector';\n\ntype StorageMap = Map<string, MetricStorage[]>;\n\n/**\n * Internal class for storing {@link MetricStorage}\n */\nexport class MetricStorageRegistry {\n  private readonly _sharedRegistry: StorageMap = new Map();\n  private readonly _perCollectorRegistry = new Map<\n    MetricCollectorHandle,\n    StorageMap\n  >();\n\n  static create() {\n    return new MetricStorageRegistry();\n  }\n\n  getStorages(collector: MetricCollectorHandle): MetricStorage[] {\n    let storages: MetricStorage[] = [];\n    for (const metricStorages of this._sharedRegistry.values()) {\n      storages = storages.concat(metricStorages);\n    }\n\n    const perCollectorStorages = this._perCollectorRegistry.get(collector);\n    if (perCollectorStorages != null) {\n      for (const metricStorages of perCollectorStorages.values()) {\n        storages = storages.concat(metricStorages);\n      }\n    }\n\n    return storages;\n  }\n\n  register(storage: MetricStorage) {\n    this._registerStorage(storage, this._sharedRegistry);\n  }\n\n  registerForCollector(\n    collector: MetricCollectorHandle,\n    storage: MetricStorage\n  ) {\n    let storageMap = this._perCollectorRegistry.get(collector);\n    if (storageMap == null) {\n      storageMap = new Map();\n      this._perCollectorRegistry.set(collector, storageMap);\n    }\n    this._registerStorage(storage, storageMap);\n  }\n\n  findOrUpdateCompatibleStorage<T extends MetricStorage>(\n    expectedDescriptor: InstrumentDescriptor\n  ): T | null {\n    const storages = this._sharedRegistry.get(expectedDescriptor.name);\n    if (storages === undefined) {\n      return null;\n    }\n\n    // If the descriptor is compatible, the type of their metric storage\n    // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.\n    return this._findOrUpdateCompatibleStorage<T>(expectedDescriptor, storages);\n  }\n\n  findOrUpdateCompatibleCollectorStorage<T extends MetricStorage>(\n    collector: MetricCollectorHandle,\n    expectedDescriptor: InstrumentDescriptor\n  ): T | null {\n    const storageMap = this._perCollectorRegistry.get(collector);\n    if (storageMap === undefined) {\n      return null;\n    }\n\n    const storages = storageMap.get(expectedDescriptor.name);\n    if (storages === undefined) {\n      return null;\n    }\n\n    // If the descriptor is compatible, the type of their metric storage\n    // (either SyncMetricStorage or AsyncMetricStorage) must be compatible.\n    return this._findOrUpdateCompatibleStorage<T>(expectedDescriptor, storages);\n  }\n\n  private _registerStorage(storage: MetricStorage, storageMap: StorageMap) {\n    const descriptor = storage.getInstrumentDescriptor();\n    const storages = storageMap.get(descriptor.name);\n\n    if (storages === undefined) {\n      storageMap.set(descriptor.name, [storage]);\n      return;\n    }\n\n    storages.push(storage);\n  }\n\n  private _findOrUpdateCompatibleStorage<T extends MetricStorage>(\n    expectedDescriptor: InstrumentDescriptor,\n    existingStorages: MetricStorage[]\n  ): T | null {\n    let compatibleStorage = null;\n\n    for (const existingStorage of existingStorages) {\n      const existingDescriptor = existingStorage.getInstrumentDescriptor();\n\n      if (isDescriptorCompatibleWith(existingDescriptor, expectedDescriptor)) {\n        // Use the longer description if it does not match.\n        if (existingDescriptor.description !== expectedDescriptor.description) {\n          if (\n            expectedDescriptor.description.length >\n            existingDescriptor.description.length\n          ) {\n            existingStorage.updateDescription(expectedDescriptor.description);\n          }\n\n          api.diag.warn(\n            'A view or instrument with the name ',\n            expectedDescriptor.name,\n            ' has already been registered, but has a different description and is incompatible with another registered view.\\n',\n            'Details:\\n',\n            getIncompatibilityDetails(existingDescriptor, expectedDescriptor),\n            'The longer description will be used.\\nTo resolve the conflict:',\n            getConflictResolutionRecipe(existingDescriptor, expectedDescriptor)\n          );\n        }\n        // Storage is fully compatible. There will never be more than one pre-existing fully compatible storage.\n        compatibleStorage = existingStorage as T;\n      } else {\n        // The implementation SHOULD warn about duplicate instrument registration\n        // conflicts after applying View configuration.\n        api.diag.warn(\n          'A view or instrument with the name ',\n          expectedDescriptor.name,\n          ' has already been registered and is incompatible with another registered view.\\n',\n          'Details:\\n',\n          getIncompatibilityDetails(existingDescriptor, expectedDescriptor),\n          'To resolve the conflict:\\n',\n          getConflictResolutionRecipe(existingDescriptor, expectedDescriptor)\n        );\n      }\n    }\n\n    return compatibleStorage;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, Attributes } from '@opentelemetry/api';\nimport { WritableMetricStorage } from './WritableMetricStorage';\n\n/**\n * Internal interface.\n */\nexport class MultiMetricStorage implements WritableMetricStorage {\n  constructor(private readonly _backingStorages: WritableMetricStorage[]) {}\n\n  record(\n    value: number,\n    attributes: Attributes,\n    context: Context,\n    recordTime: HrTime\n  ) {\n    this._backingStorages.forEach(it => {\n      it.record(value, attributes, context, recordTime);\n    });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  ObservableResult,\n  Attributes,\n  ValueType,\n  BatchObservableResult,\n  Observable,\n} from '@opentelemetry/api';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument, ObservableInstrument } from './Instruments';\n\n/**\n * The class implements {@link ObservableResult} interface.\n */\nexport class ObservableResultImpl implements ObservableResult {\n  /**\n   * @internal\n   */\n  _buffer = new AttributeHashMap<number>();\n\n  constructor(\n    private _instrumentName: string,\n    private _valueType: ValueType\n  ) {}\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(value: number, attributes: Attributes = {}): void {\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${this._instrumentName}: ${value}`\n      );\n      return;\n    }\n    if (this._valueType === ValueType.INT && !Number.isInteger(value)) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${this._instrumentName}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    this._buffer.set(attributes, value);\n  }\n}\n\n/**\n * The class implements {@link BatchObservableCallback} interface.\n */\nexport class BatchObservableResultImpl implements BatchObservableResult {\n  /**\n   * @internal\n   */\n  _buffer: Map<ObservableInstrument, AttributeHashMap<number>> = new Map();\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(\n    metric: Observable,\n    value: number,\n    attributes: Attributes = {}\n  ): void {\n    if (!isObservableInstrument(metric)) {\n      return;\n    }\n    let map = this._buffer.get(metric);\n    if (map == null) {\n      map = new AttributeHashMap();\n      this._buffer.set(metric, map);\n    }\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${metric._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    if (\n      metric._descriptor.valueType === ValueType.INT &&\n      !Number.isInteger(value)\n    ) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    map.set(attributes, value);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  HrTime,\n  BatchObservableCallback,\n  Observable,\n  ObservableCallback,\n} from '@opentelemetry/api';\nimport { isObservableInstrument, ObservableInstrument } from '../Instruments';\nimport {\n  BatchObservableResultImpl,\n  ObservableResultImpl,\n} from '../ObservableResult';\nimport {\n  callWithTimeout,\n  PromiseAllSettled,\n  isPromiseAllSettledRejectionResult,\n  setEquals,\n} from '../utils';\n\n/**\n * Records for single instrument observable callback.\n */\ninterface ObservableCallbackRecord {\n  callback: ObservableCallback;\n  instrument: ObservableInstrument;\n}\n\n/**\n * Records for multiple instruments observable callback.\n */\ninterface BatchObservableCallbackRecord {\n  callback: BatchObservableCallback;\n  instruments: Set<ObservableInstrument>;\n}\n\n/**\n * An internal interface for managing ObservableCallbacks.\n *\n * Every registered callback associated with a set of instruments are be evaluated\n * exactly once during collection prior to reading data for that instrument.\n */\nexport class ObservableRegistry {\n  private _callbacks: ObservableCallbackRecord[] = [];\n  private _batchCallbacks: BatchObservableCallbackRecord[] = [];\n\n  addCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx >= 0) {\n      return;\n    }\n    this._callbacks.push({ callback, instrument });\n  }\n\n  removeCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx < 0) {\n      return;\n    }\n    this._callbacks.splice(idx, 1);\n  }\n\n  addBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    if (observableInstruments.size === 0) {\n      diag.error(\n        'BatchObservableCallback is not associated with valid instruments',\n        instruments\n      );\n      return;\n    }\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx >= 0) {\n      return;\n    }\n    this._batchCallbacks.push({ callback, instruments: observableInstruments });\n  }\n\n  removeBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Observable[]\n  ) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(\n      instruments.filter(isObservableInstrument)\n    );\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx < 0) {\n      return;\n    }\n    this._batchCallbacks.splice(idx, 1);\n  }\n\n  /**\n   * @returns a promise of rejected reasons for invoking callbacks.\n   */\n  async observe(\n    collectionTime: HrTime,\n    timeoutMillis?: number\n  ): Promise<unknown[]> {\n    const callbackFutures = this._observeCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n    const batchCallbackFutures = this._observeBatchCallbacks(\n      collectionTime,\n      timeoutMillis\n    );\n\n    const results = await PromiseAllSettled([\n      ...callbackFutures,\n      ...batchCallbackFutures,\n    ]);\n\n    const rejections = results\n      .filter(isPromiseAllSettledRejectionResult)\n      .map(it => it.reason);\n    return rejections;\n  }\n\n  private _observeCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._callbacks.map(async ({ callback, instrument }) => {\n      const observableResult = new ObservableResultImpl(\n        instrument._descriptor.name,\n        instrument._descriptor.valueType\n      );\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instrument._metricStorages.forEach(metricStorage => {\n        metricStorage.record(observableResult._buffer, observationTime);\n      });\n    });\n  }\n\n  private _observeBatchCallbacks(\n    observationTime: HrTime,\n    timeoutMillis?: number\n  ) {\n    return this._batchCallbacks.map(async ({ callback, instruments }) => {\n      const observableResult = new BatchObservableResultImpl();\n      let callPromise: Promise<void> = Promise.resolve(\n        callback(observableResult)\n      );\n      if (timeoutMillis != null) {\n        callPromise = callWithTimeout(callPromise, timeoutMillis);\n      }\n      await callPromise;\n      instruments.forEach(instrument => {\n        const buffer = observableResult._buffer.get(instrument);\n        if (buffer == null) {\n          return;\n        }\n        instrument._metricStorages.forEach(metricStorage => {\n          metricStorage.record(buffer, observationTime);\n        });\n      });\n    });\n  }\n\n  private _findCallback(\n    callback: ObservableCallback,\n    instrument: ObservableInstrument\n  ) {\n    return this._callbacks.findIndex(record => {\n      return record.callback === callback && record.instrument === instrument;\n    });\n  }\n\n  private _findBatchCallback(\n    callback: BatchObservableCallback,\n    instruments: Set<ObservableInstrument>\n  ) {\n    return this._batchCallbacks.findIndex(record => {\n      return (\n        record.callback === callback &&\n        setEquals(record.instruments, instruments)\n      );\n    });\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, HrTime, Attributes } from '@opentelemetry/api';\nimport { WritableMetricStorage } from './WritableMetricStorage';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { InstrumentDescriptor } from '../InstrumentDescriptor';\nimport { AttributesProcessor } from '../view/AttributesProcessor';\nimport { MetricStorage } from './MetricStorage';\nimport { MetricData } from '../export/MetricData';\nimport { DeltaMetricProcessor } from './DeltaMetricProcessor';\nimport { TemporalMetricProcessor } from './TemporalMetricProcessor';\nimport { Maybe } from '../utils';\nimport { MetricCollectorHandle } from './MetricCollector';\n\n/**\n * Internal interface.\n *\n * Stores and aggregates {@link MetricData} for synchronous instruments.\n */\nexport class SyncMetricStorage<T extends Maybe<Accumulation>>\n  extends MetricStorage\n  implements WritableMetricStorage\n{\n  private _deltaMetricStorage: DeltaMetricProcessor<T>;\n  private _temporalMetricStorage: TemporalMetricProcessor<T>;\n\n  constructor(\n    instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<T>,\n    private _attributesProcessor: AttributesProcessor,\n    collectorHandles: MetricCollectorHandle[],\n    private _aggregationCardinalityLimit?: number\n  ) {\n    super(instrumentDescriptor);\n    this._deltaMetricStorage = new DeltaMetricProcessor(\n      aggregator,\n      this._aggregationCardinalityLimit\n    );\n    this._temporalMetricStorage = new TemporalMetricProcessor(\n      aggregator,\n      collectorHandles\n    );\n  }\n\n  record(\n    value: number,\n    attributes: Attributes,\n    context: Context,\n    recordTime: HrTime\n  ) {\n    attributes = this._attributesProcessor.process(attributes, context);\n    this._deltaMetricStorage.record(value, attributes, context, recordTime);\n  }\n\n  /**\n   * Collects the metrics from this storage.\n   *\n   * Note: This is a stateful operation and may reset any interval-related\n   * state for the MetricCollector.\n   */\n  collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime\n  ): Maybe<MetricData> {\n    const accumulations = this._deltaMetricStorage.collect();\n\n    return this._temporalMetricStorage.buildMetrics(\n      collector,\n      this._instrumentDescriptor,\n      accumulations,\n      collectionTime\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, MetricAttributes } from '@opentelemetry/api';\n\n/**\n * The {@link AttributesProcessor} is responsible for customizing which\n * attribute(s) are to be reported as metrics dimension(s) and adding\n * additional dimension(s) from the {@link Context}.\n */\nexport abstract class AttributesProcessor {\n  /**\n   * Process the metric instrument attributes.\n   *\n   * @param incoming The metric instrument attributes.\n   * @param context The active context when the instrument is synchronous.\n   * `undefined` otherwise.\n   */\n  abstract process(\n    incoming: MetricAttributes,\n    context?: Context\n  ): MetricAttributes;\n\n  static Noop() {\n    return NOOP;\n  }\n}\n\nexport class NoopAttributesProcessor extends AttributesProcessor {\n  process(incoming: MetricAttributes, _context?: Context) {\n    return incoming;\n  }\n}\n\n/**\n * {@link AttributesProcessor} that filters by allowed attribute names and drops any names that are not in the\n * allow list.\n */\nexport class FilteringAttributesProcessor extends AttributesProcessor {\n  constructor(private _allowedAttributeNames: string[]) {\n    super();\n  }\n\n  process(incoming: MetricAttributes, _context: Context): MetricAttributes {\n    const filteredAttributes: MetricAttributes = {};\n    Object.keys(incoming)\n      .filter(attributeName =>\n        this._allowedAttributeNames.includes(attributeName)\n      )\n      .forEach(\n        attributeName =>\n          (filteredAttributes[attributeName] = incoming[attributeName])\n      );\n    return filteredAttributes;\n  }\n}\n\nconst NOOP = new NoopAttributesProcessor();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { MetricCollectOptions } from '../export/MetricProducer';\nimport { ScopeMetrics } from '../export/MetricData';\nimport {\n  createInstrumentDescriptorWithView,\n  InstrumentDescriptor,\n} from '../InstrumentDescriptor';\nimport { Meter } from '../Meter';\nimport { isNotNullish, Maybe } from '../utils';\nimport { AsyncMetricStorage } from './AsyncMetricStorage';\nimport { MeterProviderSharedState } from './MeterProviderSharedState';\nimport { MetricCollectorHandle } from './MetricCollector';\nimport { MetricStorageRegistry } from './MetricStorageRegistry';\nimport { MultiMetricStorage } from './MultiWritableMetricStorage';\nimport { ObservableRegistry } from './ObservableRegistry';\nimport { SyncMetricStorage } from './SyncMetricStorage';\nimport { Accumulation, Aggregator } from '../aggregator/types';\nimport { AttributesProcessor } from '../view/AttributesProcessor';\nimport { MetricStorage } from './MetricStorage';\n\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterSharedState {\n  metricStorageRegistry = new MetricStorageRegistry();\n  observableRegistry = new ObservableRegistry();\n  meter: Meter;\n\n  constructor(\n    private _meterProviderSharedState: MeterProviderSharedState,\n    private _instrumentationScope: InstrumentationScope\n  ) {\n    this.meter = new Meter(this);\n  }\n\n  registerMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(descriptor, SyncMetricStorage);\n\n    if (storages.length === 1) {\n      return storages[0];\n    }\n    return new MultiMetricStorage(storages);\n  }\n\n  registerAsyncMetricStorage(descriptor: InstrumentDescriptor) {\n    const storages = this._registerMetricStorage(\n      descriptor,\n      AsyncMetricStorage\n    );\n\n    return storages;\n  }\n\n  /**\n   * @param collector opaque handle of {@link MetricCollector} which initiated the collection.\n   * @param collectionTime the HrTime at which the collection was initiated.\n   * @param options options for collection.\n   * @returns the list of metric data collected.\n   */\n  async collect(\n    collector: MetricCollectorHandle,\n    collectionTime: HrTime,\n    options?: MetricCollectOptions\n  ): Promise<ScopeMetricsResult | null> {\n    /**\n     * 1. Call all observable callbacks first.\n     * 2. Collect metric result for the collector.\n     */\n    const errors = await this.observableRegistry.observe(\n      collectionTime,\n      options?.timeoutMillis\n    );\n    const storages = this.metricStorageRegistry.getStorages(collector);\n\n    // prevent more allocations if there are no storages.\n    if (storages.length === 0) {\n      return null;\n    }\n\n    const metricDataList = storages\n      .map(metricStorage => {\n        return metricStorage.collect(collector, collectionTime);\n      })\n      .filter(isNotNullish);\n\n    // skip this scope if no data was collected (storage created, but no data observed)\n    if (metricDataList.length === 0) {\n      return { errors };\n    }\n\n    return {\n      scopeMetrics: {\n        scope: this._instrumentationScope,\n        metrics: metricDataList,\n      },\n      errors,\n    };\n  }\n\n  private _registerMetricStorage<\n    MetricStorageType extends MetricStorageConstructor,\n    R extends InstanceType<MetricStorageType>,\n  >(\n    descriptor: InstrumentDescriptor,\n    MetricStorageType: MetricStorageType\n  ): R[] {\n    const views = this._meterProviderSharedState.viewRegistry.findViews(\n      descriptor,\n      this._instrumentationScope\n    );\n    let storages = views.map(view => {\n      const viewDescriptor = createInstrumentDescriptorWithView(\n        view,\n        descriptor\n      );\n      const compatibleStorage =\n        this.metricStorageRegistry.findOrUpdateCompatibleStorage<R>(\n          viewDescriptor\n        );\n      if (compatibleStorage != null) {\n        return compatibleStorage;\n      }\n      const aggregator = view.aggregation.createAggregator(viewDescriptor);\n      const viewStorage = new MetricStorageType(\n        viewDescriptor,\n        aggregator,\n        view.attributesProcessor,\n        this._meterProviderSharedState.metricCollectors,\n        view.aggregationCardinalityLimit\n      ) as R;\n      this.metricStorageRegistry.register(viewStorage);\n      return viewStorage;\n    });\n\n    // Fallback to the per-collector aggregations if no view is configured for the instrument.\n    if (storages.length === 0) {\n      const perCollectorAggregations =\n        this._meterProviderSharedState.selectAggregations(descriptor.type);\n      const collectorStorages = perCollectorAggregations.map(\n        ([collector, aggregation]) => {\n          const compatibleStorage =\n            this.metricStorageRegistry.findOrUpdateCompatibleCollectorStorage<R>(\n              collector,\n              descriptor\n            );\n          if (compatibleStorage != null) {\n            return compatibleStorage;\n          }\n\n          const aggregator = aggregation.createAggregator(descriptor);\n          const cardinalityLimit = collector.selectCardinalityLimit(\n            descriptor.type\n          );\n          const storage = new MetricStorageType(\n            descriptor,\n            aggregator,\n            AttributesProcessor.Noop(),\n            [collector],\n            cardinalityLimit\n          ) as R;\n          this.metricStorageRegistry.registerForCollector(collector, storage);\n          return storage;\n        }\n      );\n      storages = storages.concat(collectorStorages);\n    }\n\n    return storages;\n  }\n}\n\ninterface ScopeMetricsResult {\n  scopeMetrics?: ScopeMetrics;\n  errors: unknown[];\n}\n\ninterface MetricStorageConstructor {\n  new (\n    instrumentDescriptor: InstrumentDescriptor,\n    aggregator: Aggregator<Maybe<Accumulation>>,\n    attributesProcessor: AttributesProcessor,\n    collectors: MetricCollectorHandle[],\n    aggregationCardinalityLimit?: number\n  ): MetricStorage;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { IResource } from '@opentelemetry/resources';\nimport { Aggregation, InstrumentType } from '..';\nimport { instrumentationScopeId } from '../utils';\nimport { ViewRegistry } from '../view/ViewRegistry';\nimport { MeterSharedState } from './MeterSharedState';\nimport { MetricCollector, MetricCollectorHandle } from './MetricCollector';\n\n/**\n * An internal record for shared meter provider states.\n */\nexport class MeterProviderSharedState {\n  viewRegistry = new ViewRegistry();\n\n  metricCollectors: MetricCollector[] = [];\n\n  meterSharedStates: Map<string, MeterSharedState> = new Map();\n\n  constructor(public resource: IResource) {}\n\n  getMeterSharedState(instrumentationScope: InstrumentationScope) {\n    const id = instrumentationScopeId(instrumentationScope);\n    let meterSharedState = this.meterSharedStates.get(id);\n    if (meterSharedState == null) {\n      meterSharedState = new MeterSharedState(this, instrumentationScope);\n      this.meterSharedStates.set(id, meterSharedState);\n    }\n    return meterSharedState;\n  }\n\n  selectAggregations(instrumentType: InstrumentType) {\n    const result: [MetricCollectorHandle, Aggregation][] = [];\n    for (const collector of this.metricCollectors) {\n      result.push([collector, collector.selectAggregation(instrumentType)]);\n    }\n    return result;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { millisToHrTime } from '@opentelemetry/core';\nimport { AggregationTemporalitySelector } from '../export/AggregationSelector';\nimport { CollectionResult, ScopeMetrics } from '../export/MetricData';\nimport { MetricProducer, MetricCollectOptions } from '../export/MetricProducer';\nimport { MetricReader } from '../export/MetricReader';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { ForceFlushOptions, ShutdownOptions } from '../types';\nimport { MeterProviderSharedState } from './MeterProviderSharedState';\n\n/**\n * An internal opaque interface that the MetricReader receives as\n * MetricProducer. It acts as the storage key to the internal metric stream\n * state for each MetricReader.\n */\nexport class MetricCollector implements MetricProducer {\n  constructor(\n    private _sharedState: MeterProviderSharedState,\n    private _metricReader: MetricReader\n  ) {}\n\n  async collect(options?: MetricCollectOptions): Promise<CollectionResult> {\n    const collectionTime = millisToHrTime(Date.now());\n    const scopeMetrics: ScopeMetrics[] = [];\n    const errors: unknown[] = [];\n\n    const meterCollectionPromises = Array.from(\n      this._sharedState.meterSharedStates.values()\n    ).map(async meterSharedState => {\n      const current = await meterSharedState.collect(\n        this,\n        collectionTime,\n        options\n      );\n\n      // only add scope metrics if available\n      if (current?.scopeMetrics != null) {\n        scopeMetrics.push(current.scopeMetrics);\n      }\n\n      // only add errors if available\n      if (current?.errors != null) {\n        errors.push(...current.errors);\n      }\n    });\n    await Promise.all(meterCollectionPromises);\n\n    return {\n      resourceMetrics: {\n        resource: this._sharedState.resource,\n        scopeMetrics: scopeMetrics,\n      },\n      errors: errors,\n    };\n  }\n\n  /**\n   * Delegates for MetricReader.forceFlush.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    await this._metricReader.forceFlush(options);\n  }\n\n  /**\n   * Delegates for MetricReader.shutdown.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    await this._metricReader.shutdown(options);\n  }\n\n  selectAggregationTemporality(instrumentType: InstrumentType) {\n    return this._metricReader.selectAggregationTemporality(instrumentType);\n  }\n\n  selectAggregation(instrumentType: InstrumentType) {\n    return this._metricReader.selectAggregation(instrumentType);\n  }\n\n  /**\n   * Select the cardinality limit for the given {@link InstrumentType} for this\n   * collector.\n   */\n  selectCardinalityLimit(instrumentType: InstrumentType): number {\n    return this._metricReader.selectCardinalityLimit?.(instrumentType) ?? 2000;\n  }\n}\n\n/**\n * An internal interface for MetricCollector. Exposes the necessary\n * information for metric collection.\n */\nexport interface MetricCollectorHandle {\n  selectAggregationTemporality: AggregationTemporalitySelector;\n  selectCardinalityLimit(instrumentType: InstrumentType): number;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  MeterProvider as IMeterProvider,\n  Meter as IMeter,\n  MeterOptions,\n  createNoopMeter,\n} from '@opentelemetry/api';\nimport { IResource, Resource } from '@opentelemetry/resources';\nimport { MetricReader } from './export/MetricReader';\nimport { MeterProviderSharedState } from './state/MeterProviderSharedState';\nimport { MetricCollector } from './state/MetricCollector';\nimport { ForceFlushOptions, ShutdownOptions } from './types';\nimport { View } from './view/View';\n\n/**\n * MeterProviderOptions provides an interface for configuring a MeterProvider.\n */\nexport interface MeterProviderOptions {\n  /** Resource associated with metric telemetry  */\n  resource?: IResource;\n  views?: View[];\n  readers?: MetricReader[];\n  /**\n   * Merge resource with {@link Resource.default()}?\n   * Default: {@code true}\n   */\n  mergeResourceWithDefaults?: boolean;\n}\n\n/**\n * @param mergeWithDefaults\n * @param providedResource\n */\nfunction prepareResource(\n  mergeWithDefaults: boolean,\n  providedResource: Resource | undefined\n) {\n  const resource = providedResource ?? Resource.empty();\n\n  if (mergeWithDefaults) {\n    return Resource.default().merge(resource);\n  }\n  return resource;\n}\n\n/**\n * This class implements the {@link MeterProvider} interface.\n */\nexport class MeterProvider implements IMeterProvider {\n  private _sharedState: MeterProviderSharedState;\n  private _shutdown = false;\n\n  constructor(options?: MeterProviderOptions) {\n    this._sharedState = new MeterProviderSharedState(\n      prepareResource(\n        options?.mergeResourceWithDefaults ?? true,\n        options?.resource\n      )\n    );\n    if (options?.views != null && options.views.length > 0) {\n      for (const view of options.views) {\n        this._sharedState.viewRegistry.addView(view);\n      }\n    }\n\n    if (options?.readers != null && options.readers.length > 0) {\n      for (const metricReader of options.readers) {\n        this.addMetricReader(metricReader);\n      }\n    }\n  }\n\n  /**\n   * Get a meter with the configuration of the MeterProvider.\n   */\n  getMeter(name: string, version = '', options: MeterOptions = {}): IMeter {\n    // https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/sdk.md#meter-creation\n    if (this._shutdown) {\n      diag.warn('A shutdown MeterProvider cannot provide a Meter');\n      return createNoopMeter();\n    }\n\n    return this._sharedState.getMeterSharedState({\n      name,\n      version,\n      schemaUrl: options.schemaUrl,\n    }).meter;\n  }\n\n  /**\n   * Register a {@link MetricReader} to the meter provider. After the\n   * registration, the MetricReader can start metrics collection.\n   *\n   * <p> NOTE: {@link MetricReader} instances MUST be added before creating any instruments.\n   * A {@link MetricReader} instance registered later may receive no or incomplete metric data.\n   *\n   * @param metricReader the metric reader to be registered.\n   *\n   * @deprecated This method will be removed in SDK 2.0. Please use\n   * {@link MeterProviderOptions.readers} via the {@link MeterProvider} constructor instead\n   */\n  addMetricReader(metricReader: MetricReader) {\n    const collector = new MetricCollector(this._sharedState, metricReader);\n    metricReader.setMetricProducer(collector);\n    this._sharedState.metricCollectors.push(collector);\n  }\n\n  /**\n   * Flush all buffered data and shut down the MeterProvider and all registered\n   * MetricReaders.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    if (this._shutdown) {\n      diag.warn('shutdown may only be called once per MeterProvider');\n      return;\n    }\n\n    this._shutdown = true;\n\n    await Promise.all(\n      this._sharedState.metricCollectors.map(collector => {\n        return collector.shutdown(options);\n      })\n    );\n  }\n\n  /**\n   * Notifies all registered MetricReaders to flush any buffered data.\n   *\n   * Returns a promise which is resolved when all flushes are complete.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    // do not flush after shutdown\n    if (this._shutdown) {\n      diag.warn('invalid attempt to force flush after MeterProvider shutdown');\n      return;\n    }\n\n    await Promise.all(\n      this._sharedState.metricCollectors.map(collector => {\n        return collector.forceFlush(options);\n      })\n    );\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// https://tc39.es/proposal-regex-escaping\n// escape ^ $ \\ .  + ? ( ) [ ] { } |\n// do not need to escape * as we interpret it as wildcard\nconst ESCAPE = /[\\^$\\\\.+?()[\\]{}|]/g;\n\nexport interface Predicate {\n  match(str: string): boolean;\n}\n\n/**\n * Wildcard pattern predicate, supports patterns like `*`, `foo*`, `*bar`.\n */\nexport class PatternPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _regexp: RegExp;\n\n  constructor(pattern: string) {\n    if (pattern === '*') {\n      this._matchAll = true;\n      this._regexp = /.*/;\n    } else {\n      this._matchAll = false;\n      this._regexp = new RegExp(PatternPredicate.escapePattern(pattern));\n    }\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n\n    return this._regexp.test(str);\n  }\n\n  static escapePattern(pattern: string): string {\n    return `^${pattern.replace(ESCAPE, '\\\\$&').replace('*', '.*')}$`;\n  }\n\n  static hasWildcard(pattern: string): boolean {\n    return pattern.includes('*');\n  }\n}\n\nexport class ExactPredicate implements Predicate {\n  private _matchAll: boolean;\n  private _pattern?: string;\n\n  constructor(pattern?: string) {\n    this._matchAll = pattern === undefined;\n    this._pattern = pattern;\n  }\n\n  match(str: string): boolean {\n    if (this._matchAll) {\n      return true;\n    }\n    if (str === this._pattern) {\n      return true;\n    }\n    return false;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { ExactPredicate, PatternPredicate, Predicate } from './Predicate';\n\nexport interface InstrumentSelectorCriteria {\n  name?: string;\n  type?: InstrumentType;\n  unit?: string;\n}\n\nexport class InstrumentSelector {\n  private _nameFilter: Predicate;\n  private _type?: InstrumentType;\n  private _unitFilter: Predicate;\n\n  constructor(criteria?: InstrumentSelectorCriteria) {\n    this._nameFilter = new PatternPredicate(criteria?.name ?? '*');\n    this._type = criteria?.type;\n    this._unitFilter = new ExactPredicate(criteria?.unit);\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  getNameFilter() {\n    return this._nameFilter;\n  }\n\n  getUnitFilter() {\n    return this._unitFilter;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExactPredicate, Predicate } from './Predicate';\n\nexport interface MeterSelectorCriteria {\n  name?: string;\n  version?: string;\n  schemaUrl?: string;\n}\n\nexport class MeterSelector {\n  private _nameFilter: Predicate;\n  private _versionFilter: Predicate;\n  private _schemaUrlFilter: Predicate;\n\n  constructor(criteria?: MeterSelectorCriteria) {\n    this._nameFilter = new ExactPredicate(criteria?.name);\n    this._versionFilter = new ExactPredicate(criteria?.version);\n    this._schemaUrlFilter = new ExactPredicate(criteria?.schemaUrl);\n  }\n\n  getNameFilter() {\n    return this._nameFilter;\n  }\n\n  /**\n   * TODO: semver filter? no spec yet.\n   */\n  getVersionFilter() {\n    return this._versionFilter;\n  }\n\n  getSchemaUrlFilter() {\n    return this._schemaUrlFilter;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PatternPredicate } from './Predicate';\nimport {\n  AttributesProcessor,\n  FilteringAttributesProcessor,\n} from './AttributesProcessor';\nimport { InstrumentSelector } from './InstrumentSelector';\nimport { MeterSelector } from './MeterSelector';\nimport { Aggregation } from './Aggregation';\nimport { InstrumentType } from '../InstrumentDescriptor';\n\nexport type ViewOptions = {\n  /**\n   *  Alters the metric stream:\n   *  This will be used as the name of the metrics stream.\n   *  If not provided, the original Instrument name will be used.\n   */\n  name?: string;\n  /**\n   * Alters the metric stream:\n   * This will be used as the description of the metrics stream.\n   * If not provided, the original Instrument description will be used by default.\n   *\n   * @example <caption>changes the description of all selected instruments to 'sample description'</caption>\n   * description: 'sample description'\n   */\n  description?: string;\n  /**\n   * Alters the metric stream:\n   * If provided, the attributes that are not in the list will be ignored.\n   * If not provided, all attribute keys will be used by default.\n   *\n   * @example <caption>drops all attributes with top-level keys except for 'myAttr' and 'myOtherAttr'</caption>\n   * attributeKeys: ['myAttr', 'myOtherAttr']\n   * @example <caption>drops all attributes</caption>\n   * attributeKeys: []\n   */\n  attributeKeys?: string[];\n  /**\n   * Alters the metric stream:\n   * Alters the {@link Aggregation} of the metric stream.\n   *\n   * @example <caption>changes the aggregation of the selected instrument(s) to ExplicitBucketHistogramAggregation</caption>\n   * aggregation: new ExplicitBucketHistogramAggregation([1, 10, 100])\n   * @example <caption>changes the aggregation of the selected instrument(s) to LastValueAggregation</caption>\n   * aggregation: new LastValueAggregation()\n   */\n  aggregation?: Aggregation;\n  /**\n   * Alters the metric stream:\n   * Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.\n   * If not provided, the default limit will be used.\n   *\n   * @example <caption>sets the cardinality limit to 1000</caption>\n   * aggregationCardinalityLimit: 1000\n   */\n  aggregationCardinalityLimit?: number;\n  /**\n   * Instrument selection criteria:\n   * The original type of the Instrument(s).\n   *\n   * @example <caption>selects all counters</caption>\n   * instrumentType: InstrumentType.COUNTER\n   * @example <caption>selects all histograms</caption>\n   * instrumentType: InstrumentType.HISTOGRAM\n   */\n  instrumentType?: InstrumentType;\n  /**\n   * Instrument selection criteria:\n   * Original name of the Instrument(s) with wildcard support.\n   *\n   * @example <caption>select all instruments</caption>\n   * instrumentName: '*'\n   * @example <caption>select all instruments starting with 'my.instruments.'</caption>\n   * instrumentName: 'my.instruments.*'\n   * @example <caption>select all instruments named 'my.instrument.requests' exactly</caption>\n   * instrumentName: 'my.instruments.requests'\n   */\n  instrumentName?: string;\n  /**\n   * Instrument selection criteria:\n   * The unit of the Instrument(s).\n   *\n   * @example <caption>select all instruments with unit 'ms'</caption>\n   * instrumentUnit: 'ms'\n   */\n  instrumentUnit?: string;\n  /**\n   * Instrument selection criteria:\n   * The name of the Meter. No wildcard support, name must match the meter exactly.\n   *\n   * @example <caption>select all meters named 'example.component.app' exactly</caption>\n   * meterName: 'example.component.app'\n   */\n  meterName?: string;\n  /**\n   * Instrument selection criteria:\n   * The version of the Meter. No wildcard support, version must match exactly.\n   *\n   * @example\n   * meterVersion: '1.0.1'\n   */\n  meterVersion?: string;\n  /**\n   * Instrument selection criteria:\n   * The schema URL of the Meter. No wildcard support, schema URL must match exactly.\n   *\n   * @example <caption>Select all meters with schema URL 'https://example.com/schema' exactly.</caption>\n   * meterSchemaUrl: 'https://example.com/schema'\n   */\n  meterSchemaUrl?: string;\n};\n\nfunction isSelectorNotProvided(options: ViewOptions): boolean {\n  return (\n    options.instrumentName == null &&\n    options.instrumentType == null &&\n    options.instrumentUnit == null &&\n    options.meterName == null &&\n    options.meterVersion == null &&\n    options.meterSchemaUrl == null\n  );\n}\n\n/**\n * Can be passed to a {@link MeterProvider} to select instruments and alter their metric stream.\n */\nexport class View {\n  readonly name?: string;\n  readonly description?: string;\n  readonly aggregation: Aggregation;\n  readonly attributesProcessor: AttributesProcessor;\n  readonly instrumentSelector: InstrumentSelector;\n  readonly meterSelector: MeterSelector;\n  readonly aggregationCardinalityLimit?: number;\n\n  /**\n   * Create a new {@link View} instance.\n   *\n   * Parameters can be categorized as two types:\n   *  Instrument selection criteria: Used to describe the instrument(s) this view will be applied to.\n   *  Will be treated as additive (the Instrument has to meet all the provided criteria to be selected).\n   *\n   *  Metric stream altering: Alter the metric stream of instruments selected by instrument selection criteria.\n   *\n   * @param viewOptions {@link ViewOptions} for altering the metric stream and instrument selection.\n   * @param viewOptions.name\n   * Alters the metric stream:\n   *  This will be used as the name of the metrics stream.\n   *  If not provided, the original Instrument name will be used.\n   * @param viewOptions.description\n   * Alters the metric stream:\n   *  This will be used as the description of the metrics stream.\n   *  If not provided, the original Instrument description will be used by default.\n   * @param viewOptions.attributeKeys\n   * Alters the metric stream:\n   *  If provided, the attributes that are not in the list will be ignored.\n   *  If not provided, all attribute keys will be used by default.\n   * @param viewOptions.aggregationCardinalityLimit\n   * Alters the metric stream:\n   *  Sets a limit on the number of unique attribute combinations (cardinality) that can be aggregated.\n   *  If not provided, the default limit of 2000 will be used.\n   * @param viewOptions.aggregation\n   * Alters the metric stream:\n   *  Alters the {@link Aggregation} of the metric stream.\n   * @param viewOptions.instrumentName\n   * Instrument selection criteria:\n   *  Original name of the Instrument(s) with wildcard support.\n   * @param viewOptions.instrumentType\n   * Instrument selection criteria:\n   *  The original type of the Instrument(s).\n   * @param viewOptions.instrumentUnit\n   * Instrument selection criteria:\n   *  The unit of the Instrument(s).\n   * @param viewOptions.meterName\n   * Instrument selection criteria:\n   *  The name of the Meter. No wildcard support, name must match the meter exactly.\n   * @param viewOptions.meterVersion\n   * Instrument selection criteria:\n   *  The version of the Meter. No wildcard support, version must match exactly.\n   * @param viewOptions.meterSchemaUrl\n   * Instrument selection criteria:\n   *  The schema URL of the Meter. No wildcard support, schema URL must match exactly.\n   *\n   * @example\n   * // Create a view that changes the Instrument 'my.instrument' to use to an\n   * // ExplicitBucketHistogramAggregation with the boundaries [20, 30, 40]\n   * new View({\n   *   aggregation: new ExplicitBucketHistogramAggregation([20, 30, 40]),\n   *   instrumentName: 'my.instrument'\n   * })\n   */\n  constructor(viewOptions: ViewOptions) {\n    // If no criteria is provided, the SDK SHOULD treat it as an error.\n    // It is recommended that the SDK implementations fail fast.\n    if (isSelectorNotProvided(viewOptions)) {\n      throw new Error('Cannot create view with no selector arguments supplied');\n    }\n\n    // the SDK SHOULD NOT allow Views with a specified name to be declared with instrument selectors that\n    // may select more than one instrument (e.g. wild card instrument name) in the same Meter.\n    if (\n      viewOptions.name != null &&\n      (viewOptions?.instrumentName == null ||\n        PatternPredicate.hasWildcard(viewOptions.instrumentName))\n    ) {\n      throw new Error(\n        'Views with a specified name must be declared with an instrument selector that selects at most one instrument per meter.'\n      );\n    }\n\n    // Create AttributesProcessor if attributeKeys are defined set.\n    if (viewOptions.attributeKeys != null) {\n      this.attributesProcessor = new FilteringAttributesProcessor(\n        viewOptions.attributeKeys\n      );\n    } else {\n      this.attributesProcessor = AttributesProcessor.Noop();\n    }\n\n    this.name = viewOptions.name;\n    this.description = viewOptions.description;\n    this.aggregation = viewOptions.aggregation ?? Aggregation.Default();\n    this.instrumentSelector = new InstrumentSelector({\n      name: viewOptions.instrumentName,\n      type: viewOptions.instrumentType,\n      unit: viewOptions.instrumentUnit,\n    });\n    this.meterSelector = new MeterSelector({\n      name: viewOptions.meterName,\n      version: viewOptions.meterVersion,\n      schemaUrl: viewOptions.meterSchemaUrl,\n    });\n    this.aggregationCardinalityLimit = viewOptions.aggregationCardinalityLimit;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as root from '../generated/root';\nimport { ISerializer } from '../common/i-serializer';\nimport {\n  IExportMetricsServiceRequest,\n  IExportMetricsServiceResponse,\n} from '../metrics/types';\nimport { ExportType } from './protobuf-export-type';\nimport {\n  IExportTraceServiceRequest,\n  IExportTraceServiceResponse,\n} from '../trace/types';\nimport {\n  IExportLogsServiceRequest,\n  IExportLogsServiceResponse,\n} from '../logs/types';\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { createExportTraceServiceRequest } from '../trace';\nimport { createExportMetricsServiceRequest } from '../metrics';\nimport { ResourceMetrics } from '@opentelemetry/sdk-metrics';\nimport { createExportLogsServiceRequest } from '../logs';\nimport { ReadableLogRecord } from '@opentelemetry/sdk-logs';\n\nconst logsResponseType = root.opentelemetry.proto.collector.logs.v1\n  .ExportLogsServiceResponse as ExportType<IExportLogsServiceResponse>;\n\nconst logsRequestType = root.opentelemetry.proto.collector.logs.v1\n  .ExportLogsServiceRequest as ExportType<IExportLogsServiceRequest>;\n\nconst metricsResponseType = root.opentelemetry.proto.collector.metrics.v1\n  .ExportMetricsServiceResponse as ExportType<IExportMetricsServiceResponse>;\n\nconst metricsRequestType = root.opentelemetry.proto.collector.metrics.v1\n  .ExportMetricsServiceRequest as ExportType<IExportMetricsServiceRequest>;\n\nconst traceResponseType = root.opentelemetry.proto.collector.trace.v1\n  .ExportTraceServiceResponse as ExportType<IExportTraceServiceResponse>;\n\nconst traceRequestType = root.opentelemetry.proto.collector.trace.v1\n  .ExportTraceServiceRequest as ExportType<IExportTraceServiceRequest>;\n\nexport const ProtobufLogsSerializer: ISerializer<\n  ReadableLogRecord[],\n  IExportLogsServiceResponse\n> = {\n  serializeRequest: (arg: ReadableLogRecord[]) => {\n    const request = createExportLogsServiceRequest(arg);\n    return logsRequestType.encode(request).finish();\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    return logsResponseType.decode(arg);\n  },\n};\n\nexport const ProtobufMetricsSerializer: ISerializer<\n  ResourceMetrics,\n  IExportMetricsServiceResponse\n> = {\n  serializeRequest: (arg: ResourceMetrics) => {\n    const request = createExportMetricsServiceRequest([arg]);\n    return metricsRequestType.encode(request).finish();\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    return metricsResponseType.decode(arg);\n  },\n};\n\nexport const ProtobufTraceSerializer: ISerializer<\n  ReadableSpan[],\n  IExportTraceServiceResponse\n> = {\n  serializeRequest: (arg: ReadableSpan[]) => {\n    const request = createExportTraceServiceRequest(arg);\n    return traceRequestType.encode(request).finish();\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    return traceResponseType.decode(arg);\n  },\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ISerializer } from '../common/i-serializer';\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { IExportTraceServiceResponse } from '../trace/types';\nimport { createExportTraceServiceRequest } from '../trace';\nimport { ResourceMetrics } from '@opentelemetry/sdk-metrics';\nimport { createExportMetricsServiceRequest } from '../metrics';\nimport { ReadableLogRecord } from '@opentelemetry/sdk-logs';\nimport { IExportMetricsServiceResponse } from '../metrics/types';\nimport { IExportLogsServiceResponse } from '../logs/types';\nimport { createExportLogsServiceRequest } from '../logs';\n\nexport const JsonTraceSerializer: ISerializer<\n  ReadableSpan[],\n  IExportTraceServiceResponse\n> = {\n  serializeRequest: (arg: ReadableSpan[]) => {\n    const request = createExportTraceServiceRequest(arg, {\n      useHex: true,\n      useLongBits: false,\n    });\n    const encoder = new TextEncoder();\n    return encoder.encode(JSON.stringify(request));\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(arg)) as IExportTraceServiceResponse;\n  },\n};\n\nexport const JsonMetricsSerializer: ISerializer<\n  ResourceMetrics,\n  IExportMetricsServiceResponse\n> = {\n  serializeRequest: (arg: ResourceMetrics) => {\n    const request = createExportMetricsServiceRequest([arg], {\n      useLongBits: false,\n    });\n    const encoder = new TextEncoder();\n    return encoder.encode(JSON.stringify(request));\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(arg)) as IExportMetricsServiceResponse;\n  },\n};\n\nexport const JsonLogsSerializer: ISerializer<\n  ReadableLogRecord[],\n  IExportLogsServiceResponse\n> = {\n  serializeRequest: (arg: ReadableLogRecord[]) => {\n    const request = createExportLogsServiceRequest(arg, {\n      useHex: true,\n      useLongBits: false,\n    });\n    const encoder = new TextEncoder();\n    return encoder.encode(JSON.stringify(request));\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(arg)) as IExportLogsServiceResponse;\n  },\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from './exporter-transport';\nimport { ExportResponse } from './export-response';\n\nconst MAX_ATTEMPTS = 5;\nconst INITIAL_BACKOFF = 1000;\nconst MAX_BACKOFF = 5000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst JITTER = 0.2;\n\n/**\n * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]\n */\nfunction getJitter() {\n  return Math.random() * (2 * JITTER) - JITTER;\n}\n\nclass RetryingTransport implements IExporterTransport {\n  constructor(private _transport: IExporterTransport) {}\n\n  private retry(\n    data: Uint8Array,\n    timeoutMillis: number,\n    inMillis: number\n  ): Promise<ExportResponse> {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        this._transport.send(data, timeoutMillis).then(resolve, reject);\n      }, inMillis);\n    });\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    const deadline = Date.now() + timeoutMillis;\n    let result = await this._transport.send(data, timeoutMillis);\n    let attempts = MAX_ATTEMPTS;\n    let nextBackoff = INITIAL_BACKOFF;\n\n    while (result.status === 'retryable' && attempts > 0) {\n      attempts--;\n\n      // use maximum of computed backoff and 0 to avoid negative timeouts\n      const backoff = Math.max(\n        Math.min(nextBackoff, MAX_BACKOFF) + getJitter(),\n        0\n      );\n      nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;\n      const retryInMillis = result.retryInMillis ?? backoff;\n\n      // return when expected retry time is after the export deadline.\n      const remainingTimeoutMillis = deadline - Date.now();\n      if (retryInMillis > remainingTimeoutMillis) {\n        return result;\n      }\n\n      result = await this.retry(data, remainingTimeoutMillis, retryInMillis);\n    }\n\n    return result;\n  }\n\n  shutdown() {\n    return this._transport.shutdown();\n  }\n}\n\n/**\n * Creates an Exporter Transport that retries on 'retryable' response.\n */\nexport function createRetryingTransport(options: {\n  // Underlying transport to wrap.\n  transport: IExporterTransport;\n}): IExporterTransport {\n  return new RetryingTransport(options.transport);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function isExportRetryable(statusCode: number): boolean {\n  const retryCodes = [429, 502, 503, 504];\n  return retryCodes.includes(statusCode);\n}\n\nexport function parseRetryAfterToMills(\n  retryAfter?: string | undefined | null\n): number | undefined {\n  if (retryAfter == null) {\n    return undefined;\n  }\n\n  const seconds = Number.parseInt(retryAfter, 10);\n  if (Number.isInteger(seconds)) {\n    return seconds > 0 ? seconds * 1000 : -1;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#directives\n  const delay = new Date(retryAfter).getTime() - Date.now();\n\n  if (delay >= 0) {\n    return delay;\n  }\n  return 0;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from '../exporter-transport';\nimport { ExportResponse } from '../export-response';\nimport { diag } from '@opentelemetry/api';\nimport {\n  isExportRetryable,\n  parseRetryAfterToMills,\n} from '../is-export-retryable';\n\nexport interface XhrRequestParameters {\n  url: string;\n  headers: () => Record<string, string>;\n}\n\nclass XhrTransport implements IExporterTransport {\n  constructor(private _parameters: XhrRequestParameters) {}\n\n  send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    return new Promise<ExportResponse>(resolve => {\n      const xhr = new XMLHttpRequest();\n      xhr.timeout = timeoutMillis;\n      xhr.open('POST', this._parameters.url);\n      const headers = this._parameters.headers();\n      Object.entries(headers).forEach(([k, v]) => {\n        xhr.setRequestHeader(k, v);\n      });\n\n      xhr.ontimeout = _ => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request timed out'),\n        });\n      };\n\n      xhr.onreadystatechange = () => {\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          diag.debug('XHR success');\n          resolve({\n            status: 'success',\n          });\n        } else if (xhr.status && isExportRetryable(xhr.status)) {\n          resolve({\n            status: 'retryable',\n            retryInMillis: parseRetryAfterToMills(\n              xhr.getResponseHeader('Retry-After')\n            ),\n          });\n        } else if (xhr.status !== 0) {\n          resolve({\n            status: 'failure',\n            error: new Error('XHR request failed with non-retryable status'),\n          });\n        }\n      };\n\n      xhr.onabort = () => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request aborted'),\n        });\n      };\n      xhr.onerror = () => {\n        resolve({\n          status: 'failure',\n          error: new Error('XHR request errored'),\n        });\n      };\n\n      xhr.send(data);\n    });\n  }\n\n  shutdown() {\n    // Intentionally left empty, nothing to do.\n  }\n}\n\n/**\n * Creates an exporter transport that uses XHR to send the data\n * @param parameters applied to each request made by transport\n */\nexport function createXhrTransport(\n  parameters: XhrRequestParameters\n): IExporterTransport {\n  return new XhrTransport(parameters);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from '../exporter-transport';\nimport { ExportResponse } from '../export-response';\nimport { diag } from '@opentelemetry/api';\n\nexport interface SendBeaconParameters {\n  url: string;\n  /**\n   * for instance 'application/x-protobuf'\n   */\n  blobType: string;\n}\n\nclass SendBeaconTransport implements IExporterTransport {\n  constructor(private _params: SendBeaconParameters) {}\n  send(data: Uint8Array): Promise<ExportResponse> {\n    return new Promise<ExportResponse>(resolve => {\n      if (\n        navigator.sendBeacon(\n          this._params.url,\n          new Blob([data], { type: this._params.blobType })\n        )\n      ) {\n        // no way to signal retry, treat everything as success\n        diag.debug('SendBeacon success');\n        resolve({\n          status: 'success',\n        });\n      } else {\n        resolve({\n          status: 'failure',\n          error: new Error('SendBeacon failed'),\n        });\n      }\n    });\n  }\n\n  shutdown(): void {\n    // Intentionally left empty, nothing to do.\n  }\n}\n\nexport function createSendBeaconTransport(\n  parameters: SendBeaconParameters\n): IExporterTransport {\n  return new SendBeaconTransport(parameters);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OtlpHttpConfiguration } from './configuration/otlp-http-configuration';\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport { IOtlpExportDelegate } from './otlp-export-delegate';\nimport { createRetryingTransport } from './retrying-transport';\nimport { createXhrTransport } from './transport/xhr-transport';\nimport { createSendBeaconTransport } from './transport/send-beacon-transport';\nimport { createOtlpNetworkExportDelegate } from './otlp-network-export-delegate';\n\nexport function createOtlpXhrExportDelegate<Internal, Response>(\n  options: OtlpHttpConfiguration,\n  serializer: ISerializer<Internal, Response>\n): IOtlpExportDelegate<Internal> {\n  return createOtlpNetworkExportDelegate(\n    options,\n    serializer,\n    createRetryingTransport({\n      transport: createXhrTransport(options),\n    })\n  );\n}\n\nexport function createOtlpSendBeaconExportDelegate<Internal, Response>(\n  options: OtlpHttpConfiguration,\n  serializer: ISerializer<Internal, Response>\n): IOtlpExportDelegate<Internal> {\n  return createOtlpNetworkExportDelegate(\n    options,\n    serializer,\n    createRetryingTransport({\n      transport: createSendBeaconTransport({\n        url: options.url,\n        blobType: options.headers()['Content-Type'],\n      }),\n    })\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\n\n/**\n * Parses headers from config leaving only those that have defined values\n * @param partialHeaders\n */\nexport function validateAndNormalizeHeaders(\n  partialHeaders: (() => Record<string, string>) | undefined\n): () => Record<string, string> {\n  return () => {\n    const headers: Record<string, string> = {};\n    Object.entries(partialHeaders?.() ?? {}).forEach(([key, value]) => {\n      if (typeof value !== 'undefined') {\n        headers[key] = String(value);\n      } else {\n        diag.warn(\n          `Header \"${key}\" has invalid value (${value}) and will be ignored`\n        );\n      }\n    });\n    return headers;\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getSharedConfigurationDefaults,\n  mergeOtlpSharedConfigurationWithDefaults,\n  OtlpSharedConfiguration,\n} from './shared-configuration';\nimport { validateAndNormalizeHeaders } from '../util';\n\n// NOTE: do not change these imports to be actual imports, otherwise they WILL break `@opentelemetry/instrumentation-http`\nimport type * as http from 'http';\nimport type * as https from 'https';\n\nexport interface OtlpHttpConfiguration extends OtlpSharedConfiguration {\n  url: string;\n  headers: () => Record<string, string>;\n  agentOptions: http.AgentOptions | https.AgentOptions;\n}\n\nfunction mergeHeaders(\n  userProvidedHeaders: (() => Record<string, string>) | undefined | null,\n  fallbackHeaders: (() => Record<string, string>) | undefined | null,\n  defaultHeaders: () => Record<string, string>\n): () => Record<string, string> {\n  const requiredHeaders = {\n    ...defaultHeaders(),\n  };\n  const headers = {};\n\n  return () => {\n    // add fallback ones first\n    if (fallbackHeaders != null) {\n      Object.assign(headers, fallbackHeaders());\n    }\n\n    // override with user-provided ones\n    if (userProvidedHeaders != null) {\n      Object.assign(headers, userProvidedHeaders());\n    }\n\n    // override required ones.\n    return Object.assign(headers, requiredHeaders);\n  };\n}\n\nfunction validateUserProvidedUrl(url: string | undefined): string | undefined {\n  if (url == null) {\n    return undefined;\n  }\n  try {\n    new URL(url);\n    return url;\n  } catch (e) {\n    throw new Error(\n      `Configuration: Could not parse user-provided export URL: '${url}'`\n    );\n  }\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpHttpConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpHttpConfiguration>,\n  fallbackConfiguration: Partial<OtlpHttpConfiguration>,\n  defaultConfiguration: OtlpHttpConfiguration\n): OtlpHttpConfiguration {\n  return {\n    ...mergeOtlpSharedConfigurationWithDefaults(\n      userProvidedConfiguration,\n      fallbackConfiguration,\n      defaultConfiguration\n    ),\n    headers: mergeHeaders(\n      validateAndNormalizeHeaders(userProvidedConfiguration.headers),\n      fallbackConfiguration.headers,\n      defaultConfiguration.headers\n    ),\n    url:\n      validateUserProvidedUrl(userProvidedConfiguration.url) ??\n      fallbackConfiguration.url ??\n      defaultConfiguration.url,\n    agentOptions:\n      userProvidedConfiguration.agentOptions ??\n      fallbackConfiguration.agentOptions ??\n      defaultConfiguration.agentOptions,\n  };\n}\n\nexport function getHttpConfigurationDefaults(\n  requiredHeaders: Record<string, string>,\n  signalResourcePath: string\n): OtlpHttpConfiguration {\n  return {\n    ...getSharedConfigurationDefaults(),\n    headers: () => requiredHeaders,\n    url: 'http://localhost:4318/' + signalResourcePath,\n    agentOptions: { keepAlive: true },\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  getHttpConfigurationDefaults,\n  mergeOtlpHttpConfigurationWithDefaults,\n  OtlpHttpConfiguration,\n} from './otlp-http-configuration';\nimport { OTLPExporterNodeConfigBase } from './legacy-node-configuration';\nimport { wrapStaticHeadersInFunction } from './shared-configuration';\n\n/**\n * @deprecated this will be removed in 2.0\n *\n * @param config\n * @param signalResourcePath\n * @param requiredHeaders\n */\nexport function convertLegacyBrowserHttpOptions(\n  config: OTLPExporterNodeConfigBase,\n  signalResourcePath: string,\n  requiredHeaders: Record<string, string>\n): OtlpHttpConfiguration {\n  return mergeOtlpHttpConfigurationWithDefaults(\n    {\n      url: config.url,\n      timeoutMillis: config.timeoutMillis,\n      headers: wrapStaticHeadersInFunction(config.headers),\n      concurrencyLimit: config.concurrencyLimit,\n    },\n    {}, // no fallback for browser case\n    getHttpConfigurationDefaults(requiredHeaders, signalResourcePath)\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport {\n  createOtlpSendBeaconExportDelegate,\n  createOtlpXhrExportDelegate,\n} from '../otlp-browser-http-export-delegate';\nimport { convertLegacyBrowserHttpOptions } from './convert-legacy-browser-http-options';\nimport { IOtlpExportDelegate } from '../otlp-export-delegate';\nimport { OTLPExporterConfigBase } from './legacy-base-configuration';\n\n/**\n * @deprecated\n * @param config\n * @param serializer\n * @param signalResourcePath\n * @param requiredHeaders\n */\nexport function createLegacyOtlpBrowserExportDelegate<Internal, Response>(\n  config: OTLPExporterConfigBase,\n  serializer: ISerializer<Internal, Response>,\n  signalResourcePath: string,\n  requiredHeaders: Record<string, string>\n): IOtlpExportDelegate<Internal> {\n  const useXhr = !!config.headers || typeof navigator.sendBeacon !== 'function';\n\n  const options = convertLegacyBrowserHttpOptions(\n    config,\n    signalResourcePath,\n    requiredHeaders\n  );\n\n  if (useXhr) {\n    return createOtlpXhrExportDelegate(options, serializer);\n  } else {\n    return createOtlpSendBeaconExportDelegate(options, serializer);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\nimport {\n  OTLPExporterConfigBase,\n  OTLPExporterBase,\n} from '@opentelemetry/otlp-exporter-base';\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer';\nimport { createLegacyOtlpBrowserExportDelegate } from '@opentelemetry/otlp-exporter-base/browser-http';\n\n/**\n * Collector Trace Exporter for Web\n */\nexport class OTLPTraceExporter\n  extends OTLPExporterBase<ReadableSpan[]>\n  implements SpanExporter\n{\n  constructor(config: OTLPExporterConfigBase = {}) {\n    super(\n      createLegacyOtlpBrowserExportDelegate(\n        config,\n        JsonTraceSerializer,\n        'v1/traces',\n        { 'Content-Type': 'application/json' }\n      )\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": ["exports", "module", "params", "offset", "exports", "i", "exports", "module", "exports", "module", "exports", "exports", "module", "size", "exports", "module", "exports", "i", "exports", "module", "create", "exports", "module", "exports", "module", "create_array", "create", "buffer", "exports", "module", "exports", "module", "self", "err", "exports", "exports", "module", "exports", "require_minimal", "exports", "module", "exports", "module", "opentelemetry", "Resource", "Buckets", "OTLPExporterBase", "OTLPExporterError", "CompressionAlgorithm", "BoundedQueueExportPromiseHandler", "OTLPExportDelegate", "ESpanKind", "__read", "AggregationTemporality", "DataPointType", "__extends", "TimeoutError", "__awaiter", "_a", "__read", "__values", "AggregatorKind", "DropAggregator", "InstrumentType", "HistogramAccumulation", "HistogramAggregator", "__read", "Buckets", "mod", "BucketsBacking", "__spreadArray", "__read", "__extends", "MappingError", "ExponentMapping", "LogarithmMapping", "HighLow", "MAX_SCALE", "ExponentialHistogramAccumulation", "ExponentialHistogramAggregator", "__read", "LastValueAccumulation", "LastValueAggregator", "__read", "SumAccumulation", "SumAggregator", "__read", "Aggregation", "__extends", "DropAggregation", "__extends", "SumAggregation", "__extends", "LastValueAggregation", "__extends", "HistogramAggregation", "__extends", "ExplicitBucketHistogramAggregation", "__extends", "ExponentialHistogramAggregation", "__extends", "DefaultAggregation", "MetricReader", "__spreadArray", "__read", "__extends", "PeriodicExportingMetricReader", "__spreadArray", "__read", "InMemoryMetricExporter", "ConsoleMetricExporter", "__values", "ViewRegistry", "SyncInstrument", "context", "__extends", "UpDownCounterInstrument", "__extends", "CounterInstrument", "__extends", "GaugeInstrument", "__extends", "HistogramInstrument", "ObservableInstrument", "__extends", "ObservableCounterInstrument", "__extends", "ObservableGaugeInstrument", "__extends", "ObservableUpDownCounterInstrument", "Meter", "MetricStorage", "HashMap", "__extends", "AttributeHashMap", "DeltaMetricProcessor", "__read", "TemporalMetricProcessor", "__values", "__read", "__extends", "AsyncMetricStorage", "__read", "MetricStorageRegistry", "__values", "MultiMetricStorage", "context", "ObservableResultImpl", "BatchObservableResultImpl", "ObservableRegistry", "__spreadArray", "__read", "__extends", "SyncMetricStorage", "context", "AttributesProcessor", "__extends", "NoopAttributesProcessor", "__extends", "FilteringAttributesProcessor", "MeterSharedState", "__read", "MeterProviderSharedState", "__values", "MetricCollector", "__awaiter", "_a", "__spreadArray", "__read", "MeterProvider", "__values", "PatternPredicate", "ExactPredicate", "InstrumentSelector", "MeterSelector", "View", "RetryingTransport", "XhrTransport", "__read", "SendBeaconTransport", "_a", "__read", "__extends", "OTLPTraceExporter"]
}
