{
  "version": 3,
  "sources": ["../../@opentelemetry/sdk-trace-web/src/StackContextManager.ts", "../../@opentelemetry/sdk-trace-web/src/WebTracerProvider.ts", "../../@opentelemetry/sdk-trace-web/src/enums/PerformanceTimingNames.ts", "../../@opentelemetry/sdk-trace-web/src/utils.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context, ContextManager, ROOT_CONTEXT } from '@opentelemetry/api';\n\n/**\n * Stack Context Manager for managing the state in web\n * it doesn't fully support the async calls though\n */\nexport class StackContextManager implements ContextManager {\n  /**\n   * whether the context manager is enabled or not\n   */\n  private _enabled = false;\n\n  /**\n   * Keeps the reference to current context\n   */\n  public _currentContext = ROOT_CONTEXT;\n\n  /**\n   *\n   * @param context\n   * @param target Function to be executed within the context\n   */\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private _bindFunction<T extends Function>(\n    context = ROOT_CONTEXT,\n    target: T\n  ): T {\n    const manager = this;\n    const contextWrapper = function (this: unknown, ...args: unknown[]) {\n      return manager.with(context, () => target.apply(this, args));\n    };\n    Object.defineProperty(contextWrapper, 'length', {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: target.length,\n    });\n    return contextWrapper as unknown as T;\n  }\n\n  /**\n   * Returns the active context\n   */\n  active(): Context {\n    return this._currentContext;\n  }\n\n  /**\n   * Binds a the certain context or the active one to the target function and then returns the target\n   * @param context A context (span) to be bind to target\n   * @param target a function or event emitter. When target or one of its callbacks is called,\n   *  the provided context will be used as the active context for the duration of the call.\n   */\n  bind<T>(context: Context, target: T): T {\n    // if no specific context to propagate is given, we use the current one\n    if (context === undefined) {\n      context = this.active();\n    }\n    if (typeof target === 'function') {\n      return this._bindFunction(context, target);\n    }\n    return target;\n  }\n\n  /**\n   * Disable the context manager (clears the current context)\n   */\n  disable(): this {\n    this._currentContext = ROOT_CONTEXT;\n    this._enabled = false;\n    return this;\n  }\n\n  /**\n   * Enables the context manager and creates a default(root) context\n   */\n  enable(): this {\n    if (this._enabled) {\n      return this;\n    }\n    this._enabled = true;\n    this._currentContext = ROOT_CONTEXT;\n    return this;\n  }\n\n  /**\n   * Calls the callback function [fn] with the provided [context]. If [context] is undefined then it will use the window.\n   * The context will be set as active\n   * @param context\n   * @param fn Callback function\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context | null,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    const previousContext = this._currentContext;\n    this._currentContext = context || ROOT_CONTEXT;\n\n    try {\n      return fn.call(thisArg, ...args);\n    } finally {\n      this._currentContext = previousContext;\n    }\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BasicTracerProvider,\n  SDKRegistrationConfig,\n  TracerConfig,\n} from '@opentelemetry/sdk-trace-base';\nimport { StackContextManager } from './StackContextManager';\n\n/**\n * WebTracerConfig provides an interface for configuring a Web Tracer.\n */\nexport type WebTracerConfig = TracerConfig;\n\n/**\n * This class represents a web tracer with {@link StackContextManager}\n */\nexport class WebTracerProvider extends BasicTracerProvider {\n  /**\n   * Constructs a new Tracer instance.\n   * @param config Web Tracer config\n   */\n  constructor(config: WebTracerConfig = {}) {\n    super(config);\n\n    if ((config as SDKRegistrationConfig).contextManager) {\n      throw (\n        'contextManager should be defined in register method not in' +\n        ' constructor'\n      );\n    }\n    if ((config as SDKRegistrationConfig).propagator) {\n      throw 'propagator should be defined in register method not in constructor';\n    }\n  }\n\n  /**\n   * Register this TracerProvider for use with the OpenTelemetry API.\n   * Undefined values may be replaced with defaults, and\n   * null values will be skipped.\n   *\n   * @param config Configuration object for SDK registration\n   */\n  override register(config: SDKRegistrationConfig = {}): void {\n    if (config.contextManager === undefined) {\n      config.contextManager = new StackContextManager();\n    }\n    if (config.contextManager) {\n      config.contextManager.enable();\n    }\n\n    super.register(config);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum PerformanceTimingNames {\n  CONNECT_END = 'connectEnd',\n  CONNECT_START = 'connectStart',\n  DECODED_BODY_SIZE = 'decodedBodySize',\n  DOM_COMPLETE = 'domComplete',\n  DOM_CONTENT_LOADED_EVENT_END = 'domContentLoadedEventEnd',\n  DOM_CONTENT_LOADED_EVENT_START = 'domContentLoadedEventStart',\n  DOM_INTERACTIVE = 'domInteractive',\n  DOMAIN_LOOKUP_END = 'domainLookupEnd',\n  DOMAIN_LOOKUP_START = 'domainLookupStart',\n  ENCODED_BODY_SIZE = 'encodedBodySize',\n  FETCH_START = 'fetchStart',\n  LOAD_EVENT_END = 'loadEventEnd',\n  LOAD_EVENT_START = 'loadEventStart',\n  NAVIGATION_START = 'navigationStart',\n  REDIRECT_END = 'redirectEnd',\n  REDIRECT_START = 'redirectStart',\n  REQUEST_START = 'requestStart',\n  RESPONSE_END = 'responseEnd',\n  RESPONSE_START = 'responseStart',\n  SECURE_CONNECTION_START = 'secureConnectionStart',\n  UNLOAD_EVENT_END = 'unloadEventEnd',\n  UNLOAD_EVENT_START = 'unloadEventStart',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  PerformanceEntries,\n  PerformanceResourceTimingInfo,\n  PropagateTraceHeaderCorsUrls,\n} from './types';\nimport { PerformanceTimingNames as PTN } from './enums/PerformanceTimingNames';\nimport * as api from '@opentelemetry/api';\nimport {\n  hrTimeToNanoseconds,\n  timeInputToHrTime,\n  urlMatches,\n} from '@opentelemetry/core';\nimport {\n  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,\n  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,\n} from '@opentelemetry/semantic-conventions';\n\n// Used to normalize relative URLs\nlet urlNormalizingAnchor: HTMLAnchorElement | undefined;\nfunction getUrlNormalizingAnchor(): HTMLAnchorElement {\n  if (!urlNormalizingAnchor) {\n    urlNormalizingAnchor = document.createElement('a');\n  }\n\n  return urlNormalizingAnchor;\n}\n\n/**\n * Helper function to be able to use enum as typed key in type and in interface when using forEach\n * @param obj\n * @param key\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function hasKey<O extends object>(\n  obj: O,\n  key: keyof any\n): key is keyof O {\n  return key in obj;\n}\n\n/**\n * Helper function for starting an event on span based on {@link PerformanceEntries}\n * @param span\n * @param performanceName name of performance entry for time start\n * @param entries\n * @param refPerfName name of performance entry to use for reference\n */\nexport function addSpanNetworkEvent(\n  span: api.Span,\n  performanceName: string,\n  entries: PerformanceEntries,\n  refPerfName?: string\n): api.Span | undefined {\n  let perfTime = undefined;\n  let refTime = undefined;\n  if (\n    hasKey(entries, performanceName) &&\n    typeof entries[performanceName] === 'number'\n  ) {\n    perfTime = entries[performanceName];\n  }\n  const refName = refPerfName || PTN.FETCH_START;\n  // Use a reference time which is the earliest possible value so that the performance timings that are earlier should not be added\n  // using FETCH START time in case no reference is provided\n  if (hasKey(entries, refName) && typeof entries[refName] === 'number') {\n    refTime = entries[refName];\n  }\n  if (perfTime !== undefined && refTime !== undefined && perfTime >= refTime) {\n    span.addEvent(performanceName, perfTime);\n    return span;\n  }\n  return undefined;\n}\n\n/**\n * Helper function for adding network events\n * @param span\n * @param resource\n */\nexport function addSpanNetworkEvents(\n  span: api.Span,\n  resource: PerformanceEntries\n): void {\n  addSpanNetworkEvent(span, PTN.FETCH_START, resource);\n  addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_START, resource);\n  addSpanNetworkEvent(span, PTN.DOMAIN_LOOKUP_END, resource);\n  addSpanNetworkEvent(span, PTN.CONNECT_START, resource);\n  if (\n    hasKey(resource as PerformanceResourceTiming, 'name') &&\n    (resource as PerformanceResourceTiming)['name'].startsWith('https:')\n  ) {\n    addSpanNetworkEvent(span, PTN.SECURE_CONNECTION_START, resource);\n  }\n  addSpanNetworkEvent(span, PTN.CONNECT_END, resource);\n  addSpanNetworkEvent(span, PTN.REQUEST_START, resource);\n  addSpanNetworkEvent(span, PTN.RESPONSE_START, resource);\n  addSpanNetworkEvent(span, PTN.RESPONSE_END, resource);\n  const encodedLength = resource[PTN.ENCODED_BODY_SIZE];\n  if (encodedLength !== undefined) {\n    span.setAttribute(SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, encodedLength);\n  }\n  const decodedLength = resource[PTN.DECODED_BODY_SIZE];\n  // Spec: Not set if transport encoding not used (in which case encoded and decoded sizes match)\n  if (decodedLength !== undefined && encodedLength !== decodedLength) {\n    span.setAttribute(\n      SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,\n      decodedLength\n    );\n  }\n}\n\n/**\n * sort resources by startTime\n * @param filteredResources\n */\nexport function sortResources(\n  filteredResources: PerformanceResourceTiming[]\n): PerformanceResourceTiming[] {\n  return filteredResources.slice().sort((a, b) => {\n    const valueA = a[PTN.FETCH_START];\n    const valueB = b[PTN.FETCH_START];\n    if (valueA > valueB) {\n      return 1;\n    } else if (valueA < valueB) {\n      return -1;\n    }\n    return 0;\n  });\n}\n\n/** Returns the origin if present (if in browser context). */\nfunction getOrigin(): string | undefined {\n  return typeof location !== 'undefined' ? location.origin : undefined;\n}\n\n/**\n * Get closest performance resource ignoring the resources that have been\n * already used.\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n * @param initiatorType\n */\nexport function getResource(\n  spanUrl: string,\n  startTimeHR: api.HrTime,\n  endTimeHR: api.HrTime,\n  resources: PerformanceResourceTiming[],\n  ignoredResources: WeakSet<PerformanceResourceTiming> = new WeakSet<PerformanceResourceTiming>(),\n  initiatorType?: string\n): PerformanceResourceTimingInfo {\n  // de-relativize the URL before usage (does no harm to absolute URLs)\n  const parsedSpanUrl = parseUrl(spanUrl);\n  spanUrl = parsedSpanUrl.toString();\n\n  const filteredResources = filterResourcesForSpan(\n    spanUrl,\n    startTimeHR,\n    endTimeHR,\n    resources,\n    ignoredResources,\n    initiatorType\n  );\n\n  if (filteredResources.length === 0) {\n    return {\n      mainRequest: undefined,\n    };\n  }\n  if (filteredResources.length === 1) {\n    return {\n      mainRequest: filteredResources[0],\n    };\n  }\n  const sorted = sortResources(filteredResources);\n\n  if (parsedSpanUrl.origin !== getOrigin() && sorted.length > 1) {\n    let corsPreFlightRequest: PerformanceResourceTiming | undefined = sorted[0];\n    let mainRequest: PerformanceResourceTiming = findMainRequest(\n      sorted,\n      corsPreFlightRequest[PTN.RESPONSE_END],\n      endTimeHR\n    );\n\n    const responseEnd = corsPreFlightRequest[PTN.RESPONSE_END];\n    const fetchStart = mainRequest[PTN.FETCH_START];\n\n    // no corsPreFlightRequest\n    if (fetchStart < responseEnd) {\n      mainRequest = corsPreFlightRequest;\n      corsPreFlightRequest = undefined;\n    }\n\n    return {\n      corsPreFlightRequest,\n      mainRequest,\n    };\n  } else {\n    return {\n      mainRequest: filteredResources[0],\n    };\n  }\n}\n\n/**\n * Will find the main request skipping the cors pre flight requests\n * @param resources\n * @param corsPreFlightRequestEndTime\n * @param spanEndTimeHR\n */\nfunction findMainRequest(\n  resources: PerformanceResourceTiming[],\n  corsPreFlightRequestEndTime: number,\n  spanEndTimeHR: api.HrTime\n): PerformanceResourceTiming {\n  const spanEndTime = hrTimeToNanoseconds(spanEndTimeHR);\n  const minTime = hrTimeToNanoseconds(\n    timeInputToHrTime(corsPreFlightRequestEndTime)\n  );\n\n  let mainRequest: PerformanceResourceTiming = resources[1];\n  let bestGap;\n\n  const length = resources.length;\n  for (let i = 1; i < length; i++) {\n    const resource = resources[i];\n    const resourceStartTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.FETCH_START])\n    );\n\n    const resourceEndTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.RESPONSE_END])\n    );\n\n    const currentGap = spanEndTime - resourceEndTime;\n\n    if (resourceStartTime >= minTime && (!bestGap || currentGap < bestGap)) {\n      bestGap = currentGap;\n      mainRequest = resource;\n    }\n  }\n  return mainRequest;\n}\n\n/**\n * Filter all resources that has started and finished according to span start time and end time.\n *     It will return the closest resource to a start time\n * @param spanUrl\n * @param startTimeHR\n * @param endTimeHR\n * @param resources\n * @param ignoredResources\n */\nfunction filterResourcesForSpan(\n  spanUrl: string,\n  startTimeHR: api.HrTime,\n  endTimeHR: api.HrTime,\n  resources: PerformanceResourceTiming[],\n  ignoredResources: WeakSet<PerformanceResourceTiming>,\n  initiatorType?: string\n) {\n  const startTime = hrTimeToNanoseconds(startTimeHR);\n  const endTime = hrTimeToNanoseconds(endTimeHR);\n  let filteredResources = resources.filter(resource => {\n    const resourceStartTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.FETCH_START])\n    );\n    const resourceEndTime = hrTimeToNanoseconds(\n      timeInputToHrTime(resource[PTN.RESPONSE_END])\n    );\n\n    return (\n      resource.initiatorType.toLowerCase() ===\n        (initiatorType || 'xmlhttprequest') &&\n      resource.name === spanUrl &&\n      resourceStartTime >= startTime &&\n      resourceEndTime <= endTime\n    );\n  });\n\n  if (filteredResources.length > 0) {\n    filteredResources = filteredResources.filter(resource => {\n      return !ignoredResources.has(resource);\n    });\n  }\n\n  return filteredResources;\n}\n\n/**\n * The URLLike interface represents an URL and HTMLAnchorElement compatible fields.\n */\nexport interface URLLike {\n  hash: string;\n  host: string;\n  hostname: string;\n  href: string;\n  readonly origin: string;\n  password: string;\n  pathname: string;\n  port: string;\n  protocol: string;\n  search: string;\n  username: string;\n}\n\n/**\n * Parses url using URL constructor or fallback to anchor element.\n * @param url\n */\nexport function parseUrl(url: string): URLLike {\n  if (typeof URL === 'function') {\n    return new URL(\n      url,\n      typeof document !== 'undefined'\n        ? document.baseURI\n        : typeof location !== 'undefined' // Some JS runtimes (e.g. Deno) don't define this\n          ? location.href\n          : undefined\n    );\n  }\n  const element = getUrlNormalizingAnchor();\n  element.href = url;\n  return element;\n}\n\n/**\n * Parses url using URL constructor or fallback to anchor element and serialize\n * it to a string.\n *\n * Performs the steps described in https://html.spec.whatwg.org/multipage/urls-and-fetching.html#parse-a-url\n *\n * @param url\n */\nexport function normalizeUrl(url: string): string {\n  const urlLike = parseUrl(url);\n  return urlLike.href;\n}\n\n/**\n * Get element XPath\n * @param target - target element\n * @param optimised - when id attribute of element is present the xpath can be\n * simplified to contain id\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nexport function getElementXPath(target: any, optimised?: boolean): string {\n  if (target.nodeType === Node.DOCUMENT_NODE) {\n    return '/';\n  }\n  const targetValue = getNodeValue(target, optimised);\n  if (optimised && targetValue.indexOf('@id') > 0) {\n    return targetValue;\n  }\n  let xpath = '';\n  if (target.parentNode) {\n    xpath += getElementXPath(target.parentNode, false);\n  }\n  xpath += targetValue;\n\n  return xpath;\n}\n\n/**\n * get node index within the siblings\n * @param target\n */\nfunction getNodeIndex(target: HTMLElement): number {\n  if (!target.parentNode) {\n    return 0;\n  }\n  const allowedTypes = [target.nodeType];\n  if (target.nodeType === Node.CDATA_SECTION_NODE) {\n    allowedTypes.push(Node.TEXT_NODE);\n  }\n  let elements = Array.from(target.parentNode.childNodes);\n  elements = elements.filter((element: Node) => {\n    const localName = (element as HTMLElement).localName;\n    return (\n      allowedTypes.indexOf(element.nodeType) >= 0 &&\n      localName === target.localName\n    );\n  });\n  if (elements.length >= 1) {\n    return elements.indexOf(target) + 1; // xpath starts from 1\n  }\n  // if there are no other similar child xpath doesn't need index\n  return 0;\n}\n\n/**\n * get node value for xpath\n * @param target\n * @param optimised\n */\nfunction getNodeValue(target: HTMLElement, optimised?: boolean): string {\n  const nodeType = target.nodeType;\n  const index = getNodeIndex(target);\n  let nodeValue = '';\n  if (nodeType === Node.ELEMENT_NODE) {\n    const id = target.getAttribute('id');\n    if (optimised && id) {\n      return `//*[@id=\"${id}\"]`;\n    }\n    nodeValue = target.localName;\n  } else if (\n    nodeType === Node.TEXT_NODE ||\n    nodeType === Node.CDATA_SECTION_NODE\n  ) {\n    nodeValue = 'text()';\n  } else if (nodeType === Node.COMMENT_NODE) {\n    nodeValue = 'comment()';\n  } else {\n    return '';\n  }\n  // if index is 1 it can be omitted in xpath\n  if (nodeValue && index > 1) {\n    return `/${nodeValue}[${index}]`;\n  }\n  return `/${nodeValue}`;\n}\n\n/**\n * Checks if trace headers should be propagated\n * @param spanUrl\n * @private\n */\nexport function shouldPropagateTraceHeaders(\n  spanUrl: string,\n  propagateTraceHeaderCorsUrls?: PropagateTraceHeaderCorsUrls\n): boolean {\n  let propagateTraceHeaderUrls = propagateTraceHeaderCorsUrls || [];\n  if (\n    typeof propagateTraceHeaderUrls === 'string' ||\n    propagateTraceHeaderUrls instanceof RegExp\n  ) {\n    propagateTraceHeaderUrls = [propagateTraceHeaderUrls];\n  }\n  const parsedSpanUrl = parseUrl(spanUrl);\n\n  if (parsedSpanUrl.origin === getOrigin()) {\n    return true;\n  } else {\n    return propagateTraceHeaderUrls.some(propagateTraceHeaderUrl =>\n      urlMatches(spanUrl, propagateTraceHeaderUrl)\n    );\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBA,IAAA,sBAAA,WAAA;AAAA,WAAAA,uBAAA;AAIU,SAAA,WAAW;AAKZ,SAAA,kBAAkB;EA6F3B;AArFU,EAAAA,qBAAA,UAAA,gBAAR,SACE,SACA,QAAS;AADT,QAAA,YAAA,QAAA;AAAA,gBAAA;IAAsB;AAGtB,QAAM,UAAU;AAChB,QAAM,iBAAiB,WAAA;AAAA,UAAA,QAAA;AAAyB,UAAA,OAAA,CAAA;eAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAkB;AAAlB,aAAA,MAAA,UAAA;;AAC9C,aAAO,QAAQ,KAAK,SAAS,WAAA;AAAM,eAAA,OAAO,MAAM,OAAM,IAAI;MAAvB,CAAwB;IAC7D;AACA,WAAO,eAAe,gBAAgB,UAAU;MAC9C,YAAY;MACZ,cAAc;MACd,UAAU;MACV,OAAO,OAAO;KACf;AACD,WAAO;EACT;AAKA,EAAAA,qBAAA,UAAA,SAAA,WAAA;AACE,WAAO,KAAK;EACd;AAQA,EAAAA,qBAAA,UAAA,OAAA,SAAQ,SAAkB,QAAS;AAEjC,QAAI,YAAY,QAAW;AACzB,gBAAU,KAAK,OAAM;;AAEvB,QAAI,OAAO,WAAW,YAAY;AAChC,aAAO,KAAK,cAAc,SAAS,MAAM;;AAE3C,WAAO;EACT;AAKA,EAAAA,qBAAA,UAAA,UAAA,WAAA;AACE,SAAK,kBAAkB;AACvB,SAAK,WAAW;AAChB,WAAO;EACT;AAKA,EAAAA,qBAAA,UAAA,SAAA,WAAA;AACE,QAAI,KAAK,UAAU;AACjB,aAAO;;AAET,SAAK,WAAW;AAChB,SAAK,kBAAkB;AACvB,WAAO;EACT;AAUA,EAAAA,qBAAA,UAAA,OAAA,SACE,SACA,IACA,SAA8B;AAC9B,QAAA,OAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAU;AAAV,WAAA,KAAA,KAAA,UAAA;;AAEA,QAAM,kBAAkB,KAAK;AAC7B,SAAK,kBAAkB,WAAW;AAElC,QAAI;AACF,aAAO,GAAG,KAAI,MAAP,IAAE,cAAA,CAAM,OAAO,GAAA,OAAK,IAAI,GAAA,KAAA,CAAA;;AAE/B,WAAK,kBAAkB;;EAE3B;AACF,SAAAA;AAAA,EAtGA;;;;;;;;;;;;;;;;;;;;;;;;ACSA,IAAA,oBAAA,SAAA,QAAA;AAAuC,YAAAC,oBAAA,MAAA;AAKrC,WAAAA,mBAAY,QAA4B;AAA5B,QAAA,WAAA,QAAA;AAAA,eAAA,CAAA;IAA4B;AAAxC,QAAA,QACE,OAAA,KAAA,MAAM,MAAM,KAAC;AAEb,QAAK,OAAiC,gBAAgB;AACpD,YACE;;AAIJ,QAAK,OAAiC,YAAY;AAChD,YAAM;;;EAEV;AASS,EAAAA,mBAAA,UAAA,WAAT,SAAkB,QAAkC;AAAlC,QAAA,WAAA,QAAA;AAAA,eAAA,CAAA;IAAkC;AAClD,QAAI,OAAO,mBAAmB,QAAW;AACvC,aAAO,iBAAiB,IAAI,oBAAmB;;AAEjD,QAAI,OAAO,gBAAgB;AACzB,aAAO,eAAe,OAAM;;AAG9B,WAAA,UAAM,SAAQ,KAAA,MAAC,MAAM;EACvB;AACF,SAAAA;AAAA,EApCuC,mBAAmB;;;ACf1D,IAAY;CAAZ,SAAYC,yBAAsB;AAChC,EAAAA,wBAAA,iBAAA;AACA,EAAAA,wBAAA,mBAAA;AACA,EAAAA,wBAAA,uBAAA;AACA,EAAAA,wBAAA,kBAAA;AACA,EAAAA,wBAAA,kCAAA;AACA,EAAAA,wBAAA,oCAAA;AACA,EAAAA,wBAAA,qBAAA;AACA,EAAAA,wBAAA,uBAAA;AACA,EAAAA,wBAAA,yBAAA;AACA,EAAAA,wBAAA,uBAAA;AACA,EAAAA,wBAAA,iBAAA;AACA,EAAAA,wBAAA,oBAAA;AACA,EAAAA,wBAAA,sBAAA;AACA,EAAAA,wBAAA,sBAAA;AACA,EAAAA,wBAAA,kBAAA;AACA,EAAAA,wBAAA,oBAAA;AACA,EAAAA,wBAAA,mBAAA;AACA,EAAAA,wBAAA,kBAAA;AACA,EAAAA,wBAAA,oBAAA;AACA,EAAAA,wBAAA,6BAAA;AACA,EAAAA,wBAAA,sBAAA;AACA,EAAAA,wBAAA,wBAAA;AACF,GAvBY,2BAAA,yBAAsB,CAAA,EAAA;;;ACkBlC,IAAI;AACJ,SAAS,0BAAuB;AAC9B,MAAI,CAAC,sBAAsB;AACzB,2BAAuB,SAAS,cAAc,GAAG;;AAGnD,SAAO;AACT;AAQM,SAAU,OACd,KACA,KAAc;AAEd,SAAO,OAAO;AAChB;AASM,SAAU,oBACd,MACA,iBACA,SACA,aAAoB;AAEpB,MAAI,WAAW;AACf,MAAI,UAAU;AACd,MACE,OAAO,SAAS,eAAe,KAC/B,OAAO,QAAQ,qBAAqB,UACpC;AACA,eAAW,QAAQ;;AAErB,MAAM,UAAU,eAAe,uBAAI;AAGnC,MAAI,OAAO,SAAS,OAAO,KAAK,OAAO,QAAQ,aAAa,UAAU;AACpE,cAAU,QAAQ;;AAEpB,MAAI,aAAa,UAAa,YAAY,UAAa,YAAY,SAAS;AAC1E,SAAK,SAAS,iBAAiB,QAAQ;AACvC,WAAO;;AAET,SAAO;AACT;AAOM,SAAU,qBACd,MACA,UAA4B;AAE5B,sBAAoB,MAAM,uBAAI,aAAa,QAAQ;AACnD,sBAAoB,MAAM,uBAAI,qBAAqB,QAAQ;AAC3D,sBAAoB,MAAM,uBAAI,mBAAmB,QAAQ;AACzD,sBAAoB,MAAM,uBAAI,eAAe,QAAQ;AACrD,MACE,OAAO,UAAuC,MAAM,KACnD,SAAuC,QAAQ,WAAW,QAAQ,GACnE;AACA,wBAAoB,MAAM,uBAAI,yBAAyB,QAAQ;;AAEjE,sBAAoB,MAAM,uBAAI,aAAa,QAAQ;AACnD,sBAAoB,MAAM,uBAAI,eAAe,QAAQ;AACrD,sBAAoB,MAAM,uBAAI,gBAAgB,QAAQ;AACtD,sBAAoB,MAAM,uBAAI,cAAc,QAAQ;AACpD,MAAM,gBAAgB,SAAS,uBAAI;AACnC,MAAI,kBAAkB,QAAW;AAC/B,SAAK,aAAa,uCAAuC,aAAa;;AAExE,MAAM,gBAAgB,SAAS,uBAAI;AAEnC,MAAI,kBAAkB,UAAa,kBAAkB,eAAe;AAClE,SAAK,aACH,oDACA,aAAa;;AAGnB;AAMM,SAAU,cACd,mBAA8C;AAE9C,SAAO,kBAAkB,MAAK,EAAG,KAAK,SAAC,GAAG,GAAC;AACzC,QAAM,SAAS,EAAE,uBAAI;AACrB,QAAM,SAAS,EAAE,uBAAI;AACrB,QAAI,SAAS,QAAQ;AACnB,aAAO;eACE,SAAS,QAAQ;AAC1B,aAAO;;AAET,WAAO;EACT,CAAC;AACH;AAGA,SAAS,YAAS;AAChB,SAAO,OAAO,aAAa,cAAc,SAAS,SAAS;AAC7D;AAYM,SAAU,YACd,SACA,aACA,WACA,WACA,kBACA,eAAsB;AADtB,MAAA,qBAAA,QAAA;AAAA,uBAAA,oBAA2D,QAAO;EAA6B;AAI/F,MAAM,gBAAgB,SAAS,OAAO;AACtC,YAAU,cAAc,SAAQ;AAEhC,MAAM,oBAAoB,uBACxB,SACA,aACA,WACA,WACA,kBACA,aAAa;AAGf,MAAI,kBAAkB,WAAW,GAAG;AAClC,WAAO;MACL,aAAa;;;AAGjB,MAAI,kBAAkB,WAAW,GAAG;AAClC,WAAO;MACL,aAAa,kBAAkB;;;AAGnC,MAAM,SAAS,cAAc,iBAAiB;AAE9C,MAAI,cAAc,WAAW,UAAS,KAAM,OAAO,SAAS,GAAG;AAC7D,QAAI,uBAA8D,OAAO;AACzE,QAAI,cAAyC,gBAC3C,QACA,qBAAqB,uBAAI,eACzB,SAAS;AAGX,QAAM,cAAc,qBAAqB,uBAAI;AAC7C,QAAM,aAAa,YAAY,uBAAI;AAGnC,QAAI,aAAa,aAAa;AAC5B,oBAAc;AACd,6BAAuB;;AAGzB,WAAO;MACL;MACA;;SAEG;AACL,WAAO;MACL,aAAa,kBAAkB;;;AAGrC;AAQA,SAAS,gBACP,WACA,6BACA,eAAyB;AAEzB,MAAM,cAAc,oBAAoB,aAAa;AACrD,MAAM,UAAU,oBACd,kBAAkB,2BAA2B,CAAC;AAGhD,MAAI,cAAyC,UAAU;AACvD,MAAI;AAEJ,MAAM,SAAS,UAAU;AACzB,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,QAAM,WAAW,UAAU;AAC3B,QAAM,oBAAoB,oBACxB,kBAAkB,SAAS,uBAAI,YAAY,CAAC;AAG9C,QAAM,kBAAkB,oBACtB,kBAAkB,SAAS,uBAAI,aAAa,CAAC;AAG/C,QAAM,aAAa,cAAc;AAEjC,QAAI,qBAAqB,YAAY,CAAC,WAAW,aAAa,UAAU;AACtE,gBAAU;AACV,oBAAc;;;AAGlB,SAAO;AACT;AAWA,SAAS,uBACP,SACA,aACA,WACA,WACA,kBACA,eAAsB;AAEtB,MAAM,YAAY,oBAAoB,WAAW;AACjD,MAAM,UAAU,oBAAoB,SAAS;AAC7C,MAAI,oBAAoB,UAAU,OAAO,SAAA,UAAQ;AAC/C,QAAM,oBAAoB,oBACxB,kBAAkB,SAAS,uBAAI,YAAY,CAAC;AAE9C,QAAM,kBAAkB,oBACtB,kBAAkB,SAAS,uBAAI,aAAa,CAAC;AAG/C,WACE,SAAS,cAAc,YAAW,OAC/B,iBAAiB,qBACpB,SAAS,SAAS,WAClB,qBAAqB,aACrB,mBAAmB;EAEvB,CAAC;AAED,MAAI,kBAAkB,SAAS,GAAG;AAChC,wBAAoB,kBAAkB,OAAO,SAAA,UAAQ;AACnD,aAAO,CAAC,iBAAiB,IAAI,QAAQ;IACvC,CAAC;;AAGH,SAAO;AACT;AAuBM,SAAU,SAAS,KAAW;AAClC,MAAI,OAAO,QAAQ,YAAY;AAC7B,WAAO,IAAI,IACT,KACA,OAAO,aAAa,cAChB,SAAS,UACT,OAAO,aAAa,cAClB,SAAS,OACT,MAAS;;AAGnB,MAAM,UAAU,wBAAuB;AACvC,UAAQ,OAAO;AACf,SAAO;AACT;AAUM,SAAU,aAAa,KAAW;AACtC,MAAM,UAAU,SAAS,GAAG;AAC5B,SAAO,QAAQ;AACjB;AASM,SAAU,gBAAgB,QAAa,WAAmB;AAC9D,MAAI,OAAO,aAAa,KAAK,eAAe;AAC1C,WAAO;;AAET,MAAM,cAAc,aAAa,QAAQ,SAAS;AAClD,MAAI,aAAa,YAAY,QAAQ,KAAK,IAAI,GAAG;AAC/C,WAAO;;AAET,MAAI,QAAQ;AACZ,MAAI,OAAO,YAAY;AACrB,aAAS,gBAAgB,OAAO,YAAY,KAAK;;AAEnD,WAAS;AAET,SAAO;AACT;AAMA,SAAS,aAAa,QAAmB;AACvC,MAAI,CAAC,OAAO,YAAY;AACtB,WAAO;;AAET,MAAM,eAAe,CAAC,OAAO,QAAQ;AACrC,MAAI,OAAO,aAAa,KAAK,oBAAoB;AAC/C,iBAAa,KAAK,KAAK,SAAS;;AAElC,MAAI,WAAW,MAAM,KAAK,OAAO,WAAW,UAAU;AACtD,aAAW,SAAS,OAAO,SAAC,SAAa;AACvC,QAAM,YAAa,QAAwB;AAC3C,WACE,aAAa,QAAQ,QAAQ,QAAQ,KAAK,KAC1C,cAAc,OAAO;EAEzB,CAAC;AACD,MAAI,SAAS,UAAU,GAAG;AACxB,WAAO,SAAS,QAAQ,MAAM,IAAI;;AAGpC,SAAO;AACT;AAOA,SAAS,aAAa,QAAqB,WAAmB;AAC5D,MAAM,WAAW,OAAO;AACxB,MAAM,QAAQ,aAAa,MAAM;AACjC,MAAI,YAAY;AAChB,MAAI,aAAa,KAAK,cAAc;AAClC,QAAM,KAAK,OAAO,aAAa,IAAI;AACnC,QAAI,aAAa,IAAI;AACnB,aAAO,cAAY,KAAE;;AAEvB,gBAAY,OAAO;aAEnB,aAAa,KAAK,aAClB,aAAa,KAAK,oBAClB;AACA,gBAAY;aACH,aAAa,KAAK,cAAc;AACzC,gBAAY;SACP;AACL,WAAO;;AAGT,MAAI,aAAa,QAAQ,GAAG;AAC1B,WAAO,MAAI,YAAS,MAAI,QAAK;;AAE/B,SAAO,MAAI;AACb;AAOM,SAAU,4BACd,SACA,8BAA2D;AAE3D,MAAI,2BAA2B,gCAAgC,CAAA;AAC/D,MACE,OAAO,6BAA6B,YACpC,oCAAoC,QACpC;AACA,+BAA2B,CAAC,wBAAwB;;AAEtD,MAAM,gBAAgB,SAAS,OAAO;AAEtC,MAAI,cAAc,WAAW,UAAS,GAAI;AACxC,WAAO;SACF;AACL,WAAO,yBAAyB,KAAK,SAAA,yBAAuB;AAC1D,aAAA,WAAW,SAAS,uBAAuB;IAA3C,CAA4C;;AAGlD;",
  "names": ["StackContextManager", "WebTracerProvider", "PerformanceTimingNames"]
}
