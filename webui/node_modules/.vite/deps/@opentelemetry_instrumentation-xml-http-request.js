import {
  InstrumentationBase,
  isWrapped,
  safeExecuteInTheMiddle
} from "./chunk-DF74NQCN.js";
import {
  PerformanceTimingNames,
  addSpanNetworkEvents,
  getResource,
  parseUrl,
  shouldPropagateTraceHeaders
} from "./chunk-SQ2JK5US.js";
import "./chunk-JLKGFFLA.js";
import "./chunk-Y3KLUB34.js";
import {
  hrTime,
  isUrlIgnored,
  otperformance
} from "./chunk-EUE7Z7AQ.js";
import {
  SEMATTRS_HTTP_HOST,
  SEMATTRS_HTTP_METHOD,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_SCHEME,
  SEMATTRS_HTTP_STATUS_CODE,
  SEMATTRS_HTTP_URL,
  SEMATTRS_HTTP_USER_AGENT
} from "./chunk-KGIZC2BO.js";
import {
  SpanKind,
  context,
  diag,
  propagation,
  trace
} from "./chunk-EOA2FUOG.js";
import "./chunk-TWLJ45QX.js";

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/enums/EventNames.js
var EventNames;
(function(EventNames2) {
  EventNames2["METHOD_OPEN"] = "open";
  EventNames2["METHOD_SEND"] = "send";
  EventNames2["EVENT_ABORT"] = "abort";
  EventNames2["EVENT_ERROR"] = "error";
  EventNames2["EVENT_LOAD"] = "loaded";
  EventNames2["EVENT_TIMEOUT"] = "timeout";
})(EventNames || (EventNames = {}));

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/utils.js
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DIAG_LOGGER = diag.createComponentLogger({
  namespace: "@opentelemetry/opentelemetry-instrumentation-xml-http-request/utils"
});
function getXHRBodyLength(body) {
  if (typeof Document !== "undefined" && body instanceof Document) {
    return new XMLSerializer().serializeToString(document).length;
  }
  if (body instanceof Blob) {
    return body.size;
  }
  if (body.byteLength !== void 0) {
    return body.byteLength;
  }
  if (body instanceof FormData) {
    return getFormDataSize(body);
  }
  if (body instanceof URLSearchParams) {
    return getByteLength(body.toString());
  }
  if (typeof body === "string") {
    return getByteLength(body);
  }
  DIAG_LOGGER.warn("unknown body type");
  return void 0;
}
var TEXT_ENCODER = new TextEncoder();
function getByteLength(s) {
  return TEXT_ENCODER.encode(s).byteLength;
}
function getFormDataSize(formData) {
  var e_1, _a;
  var size = 0;
  try {
    for (var _b = __values(formData.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
      size += key.length;
      if (value instanceof Blob) {
        size += value.size;
      } else {
        size += value.length;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return))
        _a.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return size;
}

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/version.js
var VERSION = "0.56.0";

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/enums/AttributeNames.js
var AttributeNames;
(function(AttributeNames2) {
  AttributeNames2["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames || (AttributeNames = {}));

// node_modules/@opentelemetry/instrumentation-xml-http-request/build/esm/xhr.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var OBSERVER_WAIT_TIME_MS = 300;
var XMLHttpRequestInstrumentation = function(_super) {
  __extends(XMLHttpRequestInstrumentation2, _super);
  function XMLHttpRequestInstrumentation2(config) {
    if (config === void 0) {
      config = {};
    }
    var _this = _super.call(this, "@opentelemetry/instrumentation-xml-http-request", VERSION, config) || this;
    _this.component = "xml-http-request";
    _this.version = VERSION;
    _this.moduleName = _this.component;
    _this._tasksCount = 0;
    _this._xhrMem = /* @__PURE__ */ new WeakMap();
    _this._usedResources = /* @__PURE__ */ new WeakSet();
    return _this;
  }
  XMLHttpRequestInstrumentation2.prototype.init = function() {
  };
  XMLHttpRequestInstrumentation2.prototype._addHeaders = function(xhr, spanUrl) {
    var url = parseUrl(spanUrl).href;
    if (!shouldPropagateTraceHeaders(url, this.getConfig().propagateTraceHeaderCorsUrls)) {
      var headers_1 = {};
      propagation.inject(context.active(), headers_1);
      if (Object.keys(headers_1).length > 0) {
        this._diag.debug("headers inject skipped due to CORS policy");
      }
      return;
    }
    var headers = {};
    propagation.inject(context.active(), headers);
    Object.keys(headers).forEach(function(key) {
      xhr.setRequestHeader(key, String(headers[key]));
    });
  };
  XMLHttpRequestInstrumentation2.prototype._addChildSpan = function(span, corsPreFlightRequest) {
    var _this = this;
    context.with(trace.setSpan(context.active(), span), function() {
      var childSpan = _this.tracer.startSpan("CORS Preflight", {
        startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START]
      });
      if (!_this.getConfig().ignoreNetworkEvents) {
        addSpanNetworkEvents(childSpan, corsPreFlightRequest);
      }
      childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
    });
  };
  XMLHttpRequestInstrumentation2.prototype._addFinalSpanAttributes = function(span, xhrMem, spanUrl) {
    if (typeof spanUrl === "string") {
      var parsedUrl = parseUrl(spanUrl);
      if (xhrMem.status !== void 0) {
        span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, xhrMem.status);
      }
      if (xhrMem.statusText !== void 0) {
        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);
      }
      span.setAttribute(SEMATTRS_HTTP_HOST, parsedUrl.host);
      span.setAttribute(SEMATTRS_HTTP_SCHEME, parsedUrl.protocol.replace(":", ""));
      span.setAttribute(SEMATTRS_HTTP_USER_AGENT, navigator.userAgent);
    }
  };
  XMLHttpRequestInstrumentation2.prototype._applyAttributesAfterXHR = function(span, xhr) {
    var _this = this;
    var applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
    if (typeof applyCustomAttributesOnSpan === "function") {
      safeExecuteInTheMiddle(function() {
        return applyCustomAttributesOnSpan(span, xhr);
      }, function(error) {
        if (!error) {
          return;
        }
        _this._diag.error("applyCustomAttributesOnSpan", error);
      }, true);
    }
  };
  XMLHttpRequestInstrumentation2.prototype._addResourceObserver = function(xhr, spanUrl) {
    var xhrMem = this._xhrMem.get(xhr);
    if (!xhrMem || typeof PerformanceObserver !== "function" || typeof PerformanceResourceTiming !== "function") {
      return;
    }
    xhrMem.createdResources = {
      observer: new PerformanceObserver(function(list) {
        var entries = list.getEntries();
        var parsedUrl = parseUrl(spanUrl);
        entries.forEach(function(entry) {
          if (entry.initiatorType === "xmlhttprequest" && entry.name === parsedUrl.href) {
            if (xhrMem.createdResources) {
              xhrMem.createdResources.entries.push(entry);
            }
          }
        });
      }),
      entries: []
    };
    xhrMem.createdResources.observer.observe({
      entryTypes: ["resource"]
    });
  };
  XMLHttpRequestInstrumentation2.prototype._clearResources = function() {
    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
      otperformance.clearResourceTimings();
      this._xhrMem = /* @__PURE__ */ new WeakMap();
      this._usedResources = /* @__PURE__ */ new WeakSet();
    }
  };
  XMLHttpRequestInstrumentation2.prototype._findResourceAndAddNetworkEvents = function(xhrMem, span, spanUrl, startTime, endTime) {
    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {
      return;
    }
    var resources = xhrMem.createdResources.entries;
    if (!resources || !resources.length) {
      resources = otperformance.getEntriesByType("resource");
    }
    var resource = getResource(parseUrl(spanUrl).href, startTime, endTime, resources, this._usedResources);
    if (resource.mainRequest) {
      var mainRequest = resource.mainRequest;
      this._markResourceAsUsed(mainRequest);
      var corsPreFlightRequest = resource.corsPreFlightRequest;
      if (corsPreFlightRequest) {
        this._addChildSpan(span, corsPreFlightRequest);
        this._markResourceAsUsed(corsPreFlightRequest);
      }
      if (!this.getConfig().ignoreNetworkEvents) {
        addSpanNetworkEvents(span, mainRequest);
      }
    }
  };
  XMLHttpRequestInstrumentation2.prototype._cleanPreviousSpanInformation = function(xhr) {
    var xhrMem = this._xhrMem.get(xhr);
    if (xhrMem) {
      var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
      if (callbackToRemoveEvents) {
        callbackToRemoveEvents();
      }
      this._xhrMem.delete(xhr);
    }
  };
  XMLHttpRequestInstrumentation2.prototype._createSpan = function(xhr, url, method) {
    var _a;
    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
      this._diag.debug("ignoring span as url matches ignored url");
      return;
    }
    var spanName = method.toUpperCase();
    var currentSpan = this.tracer.startSpan(spanName, {
      kind: SpanKind.CLIENT,
      attributes: (_a = {}, _a[SEMATTRS_HTTP_METHOD] = method, _a[SEMATTRS_HTTP_URL] = parseUrl(url).toString(), _a)
    });
    currentSpan.addEvent(EventNames.METHOD_OPEN);
    this._cleanPreviousSpanInformation(xhr);
    this._xhrMem.set(xhr, {
      span: currentSpan,
      spanUrl: url
    });
    return currentSpan;
  };
  XMLHttpRequestInstrumentation2.prototype._markResourceAsUsed = function(resource) {
    this._usedResources.add(resource);
  };
  XMLHttpRequestInstrumentation2.prototype._patchOpen = function() {
    var _this = this;
    return function(original) {
      var plugin = _this;
      return function patchOpen() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var method = args[0];
        var url = args[1];
        plugin._createSpan(this, url, method);
        return original.apply(this, args);
      };
    };
  };
  XMLHttpRequestInstrumentation2.prototype._patchSend = function() {
    var plugin = this;
    function endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime) {
      var callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;
      if (typeof callbackToRemoveEvents === "function") {
        callbackToRemoveEvents();
      }
      var span = xhrMem.span, spanUrl = xhrMem.spanUrl, sendStartTime = xhrMem.sendStartTime;
      if (span) {
        plugin._findResourceAndAddNetworkEvents(xhrMem, span, spanUrl, sendStartTime, performanceEndTime);
        span.addEvent(eventName, endTime);
        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);
        span.end(endTime);
        plugin._tasksCount--;
      }
      plugin._clearResources();
    }
    function endSpan(eventName, xhr) {
      var xhrMem = plugin._xhrMem.get(xhr);
      if (!xhrMem) {
        return;
      }
      xhrMem.status = xhr.status;
      xhrMem.statusText = xhr.statusText;
      plugin._xhrMem.delete(xhr);
      if (xhrMem.span) {
        plugin._applyAttributesAfterXHR(xhrMem.span, xhr);
      }
      var performanceEndTime = hrTime();
      var endTime = Date.now();
      setTimeout(function() {
        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);
      }, OBSERVER_WAIT_TIME_MS);
    }
    function onError() {
      endSpan(EventNames.EVENT_ERROR, this);
    }
    function onAbort() {
      endSpan(EventNames.EVENT_ABORT, this);
    }
    function onTimeout() {
      endSpan(EventNames.EVENT_TIMEOUT, this);
    }
    function onLoad() {
      if (this.status < 299) {
        endSpan(EventNames.EVENT_LOAD, this);
      } else {
        endSpan(EventNames.EVENT_ERROR, this);
      }
    }
    function unregister(xhr) {
      xhr.removeEventListener("abort", onAbort);
      xhr.removeEventListener("error", onError);
      xhr.removeEventListener("load", onLoad);
      xhr.removeEventListener("timeout", onTimeout);
      var xhrMem = plugin._xhrMem.get(xhr);
      if (xhrMem) {
        xhrMem.callbackToRemoveEvents = void 0;
      }
    }
    return function(original) {
      return function patchSend() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var xhrMem = plugin._xhrMem.get(this);
        if (!xhrMem) {
          return original.apply(this, args);
        }
        var currentSpan = xhrMem.span;
        var spanUrl = xhrMem.spanUrl;
        if (currentSpan && spanUrl) {
          if (plugin.getConfig().measureRequestSize && (args === null || args === void 0 ? void 0 : args[0])) {
            var body = args[0];
            var bodyLength = getXHRBodyLength(body);
            if (bodyLength !== void 0) {
              currentSpan.setAttribute(SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);
            }
          }
          context.with(trace.setSpan(context.active(), currentSpan), function() {
            plugin._tasksCount++;
            xhrMem.sendStartTime = hrTime();
            currentSpan.addEvent(EventNames.METHOD_SEND);
            _this.addEventListener("abort", onAbort);
            _this.addEventListener("error", onError);
            _this.addEventListener("load", onLoad);
            _this.addEventListener("timeout", onTimeout);
            xhrMem.callbackToRemoveEvents = function() {
              unregister(_this);
              if (xhrMem.createdResources) {
                xhrMem.createdResources.observer.disconnect();
              }
            };
            plugin._addHeaders(_this, spanUrl);
            plugin._addResourceObserver(_this, spanUrl);
          });
        }
        return original.apply(this, args);
      };
    };
  };
  XMLHttpRequestInstrumentation2.prototype.enable = function() {
    this._diag.debug("applying patch to", this.moduleName, this.version);
    if (isWrapped(XMLHttpRequest.prototype.open)) {
      this._unwrap(XMLHttpRequest.prototype, "open");
      this._diag.debug("removing previous patch from method open");
    }
    if (isWrapped(XMLHttpRequest.prototype.send)) {
      this._unwrap(XMLHttpRequest.prototype, "send");
      this._diag.debug("removing previous patch from method send");
    }
    this._wrap(XMLHttpRequest.prototype, "open", this._patchOpen());
    this._wrap(XMLHttpRequest.prototype, "send", this._patchSend());
  };
  XMLHttpRequestInstrumentation2.prototype.disable = function() {
    this._diag.debug("removing patch from", this.moduleName, this.version);
    this._unwrap(XMLHttpRequest.prototype, "open");
    this._unwrap(XMLHttpRequest.prototype, "send");
    this._tasksCount = 0;
    this._xhrMem = /* @__PURE__ */ new WeakMap();
    this._usedResources = /* @__PURE__ */ new WeakSet();
  };
  return XMLHttpRequestInstrumentation2;
}(InstrumentationBase);
export {
  XMLHttpRequestInstrumentation
};
//# sourceMappingURL=@opentelemetry_instrumentation-xml-http-request.js.map
