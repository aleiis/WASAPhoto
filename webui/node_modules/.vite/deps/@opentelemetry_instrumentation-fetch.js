import {
  InstrumentationBase,
  isWrapped,
  safeExecuteInTheMiddle
} from "./chunk-DF74NQCN.js";
import {
  PerformanceTimingNames,
  addSpanNetworkEvents,
  getResource,
  parseUrl,
  shouldPropagateTraceHeaders
} from "./chunk-SQ2JK5US.js";
import "./chunk-JLKGFFLA.js";
import "./chunk-Y3KLUB34.js";
import {
  _globalThis,
  hrTime,
  isUrlIgnored,
  millisToHrTime
} from "./chunk-EUE7Z7AQ.js";
import {
  SEMATTRS_HTTP_HOST,
  SEMATTRS_HTTP_METHOD,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_SCHEME,
  SEMATTRS_HTTP_STATUS_CODE,
  SEMATTRS_HTTP_URL,
  SEMATTRS_HTTP_USER_AGENT
} from "./chunk-KGIZC2BO.js";
import {
  SpanKind,
  context,
  diag,
  propagation,
  trace
} from "./chunk-EOA2FUOG.js";
import "./chunk-TWLJ45QX.js";

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/enums/AttributeNames.js
var AttributeNames;
(function(AttributeNames2) {
  AttributeNames2["COMPONENT"] = "component";
  AttributeNames2["HTTP_ERROR_NAME"] = "http.error_name";
  AttributeNames2["HTTP_STATUS_TEXT"] = "http.status_text";
})(AttributeNames || (AttributeNames = {}));

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/utils.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var DIAG_LOGGER = diag.createComponentLogger({
  namespace: "@opentelemetry/opentelemetry-instrumentation-fetch/utils"
});
function getFetchBodyLength() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args[0] instanceof URL || typeof args[0] === "string") {
    var requestInit = args[1];
    if (!(requestInit === null || requestInit === void 0 ? void 0 : requestInit.body)) {
      return Promise.resolve();
    }
    if (requestInit.body instanceof ReadableStream) {
      var _a2 = _getBodyNonDestructively(requestInit.body), body = _a2.body, length_1 = _a2.length;
      requestInit.body = body;
      return length_1;
    } else {
      return Promise.resolve(getXHRBodyLength(requestInit.body));
    }
  } else {
    var info = args[0];
    if (!(info === null || info === void 0 ? void 0 : info.body)) {
      return Promise.resolve();
    }
    return info.clone().text().then(function(t) {
      return getByteLength(t);
    });
  }
}
function _getBodyNonDestructively(body) {
  if (!body.pipeThrough) {
    DIAG_LOGGER.warn("Platform has ReadableStream but not pipeThrough!");
    return {
      body,
      length: Promise.resolve(void 0)
    };
  }
  var length = 0;
  var resolveLength;
  var lengthPromise = new Promise(function(resolve) {
    resolveLength = resolve;
  });
  var transform = new TransformStream({
    start: function() {
    },
    transform: function(chunk, controller) {
      return __awaiter(this, void 0, void 0, function() {
        var bytearray;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, chunk];
            case 1:
              bytearray = _a2.sent();
              length += bytearray.byteLength;
              controller.enqueue(chunk);
              return [2];
          }
        });
      });
    },
    flush: function() {
      resolveLength(length);
    }
  });
  return {
    body: body.pipeThrough(transform),
    length: lengthPromise
  };
}
function getXHRBodyLength(body) {
  if (typeof Document !== "undefined" && body instanceof Document) {
    return new XMLSerializer().serializeToString(document).length;
  }
  if (body instanceof Blob) {
    return body.size;
  }
  if (body.byteLength !== void 0) {
    return body.byteLength;
  }
  if (body instanceof FormData) {
    return getFormDataSize(body);
  }
  if (body instanceof URLSearchParams) {
    return getByteLength(body.toString());
  }
  if (typeof body === "string") {
    return getByteLength(body);
  }
  DIAG_LOGGER.warn("unknown body type");
  return void 0;
}
var TEXT_ENCODER = new TextEncoder();
function getByteLength(s) {
  return TEXT_ENCODER.encode(s).byteLength;
}
function getFormDataSize(formData) {
  var e_1, _a2;
  var size = 0;
  try {
    for (var _b = __values(formData.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
      size += key.length;
      if (value instanceof Blob) {
        size += value.size;
      } else {
        size += value.length;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return size;
}

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/version.js
var VERSION = "0.56.0";

// node_modules/@opentelemetry/instrumentation-fetch/build/esm/fetch.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var _a;
var OBSERVER_WAIT_TIME_MS = 300;
var isNode = typeof process === "object" && ((_a = process.release) === null || _a === void 0 ? void 0 : _a.name) === "node";
var FetchInstrumentation = function(_super) {
  __extends(FetchInstrumentation2, _super);
  function FetchInstrumentation2(config) {
    if (config === void 0) {
      config = {};
    }
    var _this = _super.call(this, "@opentelemetry/instrumentation-fetch", VERSION, config) || this;
    _this.component = "fetch";
    _this.version = VERSION;
    _this.moduleName = _this.component;
    _this._usedResources = /* @__PURE__ */ new WeakSet();
    _this._tasksCount = 0;
    return _this;
  }
  FetchInstrumentation2.prototype.init = function() {
  };
  FetchInstrumentation2.prototype._addChildSpan = function(span, corsPreFlightRequest) {
    var childSpan = this.tracer.startSpan("CORS Preflight", {
      startTime: corsPreFlightRequest[PerformanceTimingNames.FETCH_START]
    }, trace.setSpan(context.active(), span));
    if (!this.getConfig().ignoreNetworkEvents) {
      addSpanNetworkEvents(childSpan, corsPreFlightRequest);
    }
    childSpan.end(corsPreFlightRequest[PerformanceTimingNames.RESPONSE_END]);
  };
  FetchInstrumentation2.prototype._addFinalSpanAttributes = function(span, response) {
    var parsedUrl = parseUrl(response.url);
    span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, response.status);
    if (response.statusText != null) {
      span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);
    }
    span.setAttribute(SEMATTRS_HTTP_HOST, parsedUrl.host);
    span.setAttribute(SEMATTRS_HTTP_SCHEME, parsedUrl.protocol.replace(":", ""));
    if (typeof navigator !== "undefined") {
      span.setAttribute(SEMATTRS_HTTP_USER_AGENT, navigator.userAgent);
    }
  };
  FetchInstrumentation2.prototype._addHeaders = function(options, spanUrl) {
    if (!shouldPropagateTraceHeaders(spanUrl, this.getConfig().propagateTraceHeaderCorsUrls)) {
      var headers = {};
      propagation.inject(context.active(), headers);
      if (Object.keys(headers).length > 0) {
        this._diag.debug("headers inject skipped due to CORS policy");
      }
      return;
    }
    if (options instanceof Request) {
      propagation.inject(context.active(), options.headers, {
        set: function(h, k, v) {
          return h.set(k, typeof v === "string" ? v : String(v));
        }
      });
    } else if (options.headers instanceof Headers) {
      propagation.inject(context.active(), options.headers, {
        set: function(h, k, v) {
          return h.set(k, typeof v === "string" ? v : String(v));
        }
      });
    } else if (options.headers instanceof Map) {
      propagation.inject(context.active(), options.headers, {
        set: function(h, k, v) {
          return h.set(k, typeof v === "string" ? v : String(v));
        }
      });
    } else {
      var headers = {};
      propagation.inject(context.active(), headers);
      options.headers = Object.assign({}, headers, options.headers || {});
    }
  };
  FetchInstrumentation2.prototype._clearResources = function() {
    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {
      performance.clearResourceTimings();
      this._usedResources = /* @__PURE__ */ new WeakSet();
    }
  };
  FetchInstrumentation2.prototype._createSpan = function(url, options) {
    var _a2;
    if (options === void 0) {
      options = {};
    }
    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {
      this._diag.debug("ignoring span as url matches ignored url");
      return;
    }
    var method = (options.method || "GET").toUpperCase();
    var spanName = "HTTP " + method;
    return this.tracer.startSpan(spanName, {
      kind: SpanKind.CLIENT,
      attributes: (_a2 = {}, _a2[AttributeNames.COMPONENT] = this.moduleName, _a2[SEMATTRS_HTTP_METHOD] = method, _a2[SEMATTRS_HTTP_URL] = url, _a2)
    });
  };
  FetchInstrumentation2.prototype._findResourceAndAddNetworkEvents = function(span, resourcesObserver, endTime) {
    var resources = resourcesObserver.entries;
    if (!resources.length) {
      if (!performance.getEntriesByType) {
        return;
      }
      resources = performance.getEntriesByType("resource");
    }
    var resource = getResource(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, "fetch");
    if (resource.mainRequest) {
      var mainRequest = resource.mainRequest;
      this._markResourceAsUsed(mainRequest);
      var corsPreFlightRequest = resource.corsPreFlightRequest;
      if (corsPreFlightRequest) {
        this._addChildSpan(span, corsPreFlightRequest);
        this._markResourceAsUsed(corsPreFlightRequest);
      }
      if (!this.getConfig().ignoreNetworkEvents) {
        addSpanNetworkEvents(span, mainRequest);
      }
    }
  };
  FetchInstrumentation2.prototype._markResourceAsUsed = function(resource) {
    this._usedResources.add(resource);
  };
  FetchInstrumentation2.prototype._endSpan = function(span, spanData, response) {
    var _this = this;
    var endTime = millisToHrTime(Date.now());
    var performanceEndTime = hrTime();
    this._addFinalSpanAttributes(span, response);
    setTimeout(function() {
      var _a2;
      (_a2 = spanData.observer) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      _this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);
      _this._tasksCount--;
      _this._clearResources();
      span.end(endTime);
    }, OBSERVER_WAIT_TIME_MS);
  };
  FetchInstrumentation2.prototype._patchConstructor = function() {
    var _this = this;
    return function(original) {
      var plugin = _this;
      return function patchConstructor() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var self = this;
        var url = parseUrl(args[0] instanceof Request ? args[0].url : String(args[0])).href;
        var options = args[0] instanceof Request ? args[0] : args[1] || {};
        var createdSpan = plugin._createSpan(url, options);
        if (!createdSpan) {
          return original.apply(this, args);
        }
        var spanData = plugin._prepareSpanData(url);
        if (plugin.getConfig().measureRequestSize) {
          getFetchBodyLength.apply(void 0, __spreadArray([], __read2(args), false)).then(function(length) {
            if (!length)
              return;
            createdSpan.setAttribute(SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, length);
          }).catch(function(error) {
            plugin._diag.warn("getFetchBodyLength", error);
          });
        }
        function endSpanOnError(span, error) {
          plugin._applyAttributesAfterFetch(span, options, error);
          plugin._endSpan(span, spanData, {
            status: error.status || 0,
            statusText: error.message,
            url
          });
        }
        function endSpanOnSuccess(span, response) {
          plugin._applyAttributesAfterFetch(span, options, response);
          if (response.status >= 200 && response.status < 400) {
            plugin._endSpan(span, spanData, response);
          } else {
            plugin._endSpan(span, spanData, {
              status: response.status,
              statusText: response.statusText,
              url
            });
          }
        }
        function onSuccess(span, resolve, response) {
          try {
            var resClone = response.clone();
            var resClone4Hook_1 = response.clone();
            var body = resClone.body;
            if (body) {
              var reader_1 = body.getReader();
              var read_1 = function() {
                reader_1.read().then(function(_a2) {
                  var done = _a2.done;
                  if (done) {
                    endSpanOnSuccess(span, resClone4Hook_1);
                  } else {
                    read_1();
                  }
                }, function(error) {
                  endSpanOnError(span, error);
                });
              };
              read_1();
            } else {
              endSpanOnSuccess(span, response);
            }
          } finally {
            resolve(response);
          }
        }
        function onError(span, reject, error) {
          try {
            endSpanOnError(span, error);
          } finally {
            reject(error);
          }
        }
        return new Promise(function(resolve, reject) {
          return context.with(trace.setSpan(context.active(), createdSpan), function() {
            plugin._addHeaders(options, url);
            plugin._tasksCount++;
            return original.apply(self, options instanceof Request ? [options] : [url, options]).then(onSuccess.bind(self, createdSpan, resolve), onError.bind(self, createdSpan, reject));
          });
        });
      };
    };
  };
  FetchInstrumentation2.prototype._applyAttributesAfterFetch = function(span, request, result) {
    var _this = this;
    var applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;
    if (applyCustomAttributesOnSpan) {
      safeExecuteInTheMiddle(function() {
        return applyCustomAttributesOnSpan(span, request, result);
      }, function(error) {
        if (!error) {
          return;
        }
        _this._diag.error("applyCustomAttributesOnSpan", error);
      }, true);
    }
  };
  FetchInstrumentation2.prototype._prepareSpanData = function(spanUrl) {
    var startTime = hrTime();
    var entries = [];
    if (typeof PerformanceObserver !== "function") {
      return { entries, startTime, spanUrl };
    }
    var observer = new PerformanceObserver(function(list) {
      var perfObsEntries = list.getEntries();
      perfObsEntries.forEach(function(entry) {
        if (entry.initiatorType === "fetch" && entry.name === spanUrl) {
          entries.push(entry);
        }
      });
    });
    observer.observe({
      entryTypes: ["resource"]
    });
    return { entries, observer, startTime, spanUrl };
  };
  FetchInstrumentation2.prototype.enable = function() {
    if (isNode) {
      this._diag.warn("this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()");
      return;
    }
    if (isWrapped(fetch)) {
      this._unwrap(_globalThis, "fetch");
      this._diag.debug("removing previous patch for constructor");
    }
    this._wrap(_globalThis, "fetch", this._patchConstructor());
  };
  FetchInstrumentation2.prototype.disable = function() {
    if (isNode) {
      return;
    }
    this._unwrap(_globalThis, "fetch");
    this._usedResources = /* @__PURE__ */ new WeakSet();
  };
  return FetchInstrumentation2;
}(InstrumentationBase);
export {
  FetchInstrumentation
};
//# sourceMappingURL=@opentelemetry_instrumentation-fetch.js.map
