{
  "version": 3,
  "sources": ["../../@opentelemetry/instrumentation-fetch/src/enums/AttributeNames.ts", "../../@opentelemetry/instrumentation-fetch/src/utils.ts", "../../@opentelemetry/instrumentation-fetch/src/version.ts", "../../@opentelemetry/instrumentation-fetch/src/fetch.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nexport enum AttributeNames {\n  COMPONENT = 'component',\n  HTTP_ERROR_NAME = 'http.error_name',\n  HTTP_STATUS_TEXT = 'http.status_text',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Much of the logic here overlaps with the same utils file in opentelemetry-instrumentation-xml-http-request\n// These may be unified in the future.\n\nimport * as api from '@opentelemetry/api';\n\nconst DIAG_LOGGER = api.diag.createComponentLogger({\n  namespace: '@opentelemetry/opentelemetry-instrumentation-fetch/utils',\n});\n\n/**\n * Helper function to determine payload content length for fetch requests\n *\n * The fetch API is kinda messy: there are a couple of ways the body can be passed in.\n *\n * In all cases, the body param can be some variation of ReadableStream,\n * and ReadableStreams can only be read once! We want to avoid consuming the body here,\n * because that would mean that the body never gets sent with the actual fetch request.\n *\n * Either the first arg is a Request object, which can be cloned\n *   so we can clone that object and read the body of the clone\n *   without disturbing the original argument\n *   However, reading the body here can only be done async; the body() method returns a promise\n *   this means this entire function has to return a promise\n *\n * OR the first arg is a url/string\n *   in which case the second arg has type RequestInit\n *   RequestInit is NOT cloneable, but RequestInit.body is writable\n *   so we can chain it into ReadableStream.pipeThrough()\n *\n *   ReadableStream.pipeThrough() lets us process a stream and returns a new stream\n *   So we can measure the body length as it passes through the pie, but need to attach\n *   the new stream to the original request\n *   so that the browser still has access to the body.\n *\n * @param body\n * @returns promise that resolves to the content length of the body\n */\nexport function getFetchBodyLength(...args: Parameters<typeof fetch>) {\n  if (args[0] instanceof URL || typeof args[0] === 'string') {\n    const requestInit = args[1];\n    if (!requestInit?.body) {\n      return Promise.resolve();\n    }\n    if (requestInit.body instanceof ReadableStream) {\n      const { body, length } = _getBodyNonDestructively(requestInit.body);\n      requestInit.body = body;\n\n      return length;\n    } else {\n      return Promise.resolve(getXHRBodyLength(requestInit.body));\n    }\n  } else {\n    const info = args[0];\n    if (!info?.body) {\n      return Promise.resolve();\n    }\n\n    return info\n      .clone()\n      .text()\n      .then(t => getByteLength(t));\n  }\n}\n\nfunction _getBodyNonDestructively(body: ReadableStream) {\n  // can't read a ReadableStream without destroying it\n  // but we CAN pipe it through and return a new ReadableStream\n\n  // some (older) platforms don't expose the pipeThrough method and in that scenario, we're out of luck;\n  //   there's no way to read the stream without consuming it.\n  if (!body.pipeThrough) {\n    DIAG_LOGGER.warn('Platform has ReadableStream but not pipeThrough!');\n    return {\n      body,\n      length: Promise.resolve(undefined),\n    };\n  }\n\n  let length = 0;\n  let resolveLength: (l: number) => void;\n  const lengthPromise = new Promise<number>(resolve => {\n    resolveLength = resolve;\n  });\n\n  const transform = new TransformStream({\n    start() {},\n    async transform(chunk, controller) {\n      const bytearray = (await chunk) as Uint8Array;\n      length += bytearray.byteLength;\n\n      controller.enqueue(chunk);\n    },\n    flush() {\n      resolveLength(length);\n    },\n  });\n\n  return {\n    body: body.pipeThrough(transform),\n    length: lengthPromise,\n  };\n}\n\n/**\n * Helper function to determine payload content length for XHR requests\n * @param body\n * @returns content length\n */\nexport function getXHRBodyLength(\n  body: Document | XMLHttpRequestBodyInit\n): number | undefined {\n  if (typeof Document !== 'undefined' && body instanceof Document) {\n    return new XMLSerializer().serializeToString(document).length;\n  }\n  // XMLHttpRequestBodyInit expands to the following:\n  if (body instanceof Blob) {\n    return body.size;\n  }\n\n  // ArrayBuffer | ArrayBufferView\n  if ((body as any).byteLength !== undefined) {\n    return (body as any).byteLength as number;\n  }\n\n  if (body instanceof FormData) {\n    return getFormDataSize(body);\n  }\n\n  if (body instanceof URLSearchParams) {\n    return getByteLength(body.toString());\n  }\n\n  if (typeof body === 'string') {\n    return getByteLength(body);\n  }\n\n  DIAG_LOGGER.warn('unknown body type');\n  return undefined;\n}\n\nconst TEXT_ENCODER = new TextEncoder();\nfunction getByteLength(s: string): number {\n  return TEXT_ENCODER.encode(s).byteLength;\n}\n\nfunction getFormDataSize(formData: FormData): number {\n  let size = 0;\n  for (const [key, value] of formData.entries()) {\n    size += key.length;\n    if (value instanceof Blob) {\n      size += value.size;\n    } else {\n      size += value.length;\n    }\n  }\n  return size;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '0.56.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport * as core from '@opentelemetry/core';\nimport * as web from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport {\n  SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_HTTP_HOST,\n  SEMATTRS_HTTP_USER_AGENT,\n  SEMATTRS_HTTP_SCHEME,\n  SEMATTRS_HTTP_URL,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n} from '@opentelemetry/semantic-conventions';\nimport { FetchError, FetchResponse, SpanData } from './types';\nimport { getFetchBodyLength } from './utils';\nimport { VERSION } from './version';\nimport { _globalThis } from '@opentelemetry/core';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nconst isNode = typeof process === 'object' && process.release?.name === 'node';\n\nexport interface FetchCustomAttributeFunction {\n  (\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ): void;\n}\n\n/**\n * FetchPlugin Config\n */\nexport interface FetchInstrumentationConfig extends InstrumentationConfig {\n  // the number of timing resources is limited, after the limit\n  // (chrome 250, safari 150) the information is not collected anymore\n  // the only way to prevent that is to regularly clean the resources\n  // whenever it is possible, this is needed only when PerformanceObserver\n  // is not available\n  clearTimingResources?: boolean;\n  // urls which should include trace headers when origin doesn't match\n  propagateTraceHeaderCorsUrls?: web.PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: FetchCustomAttributeFunction;\n  // Ignore adding network events as span events\n  ignoreNetworkEvents?: boolean;\n  /** Measure outgoing request size */\n  measureRequestSize?: boolean;\n}\n\n/**\n * This class represents a fetch plugin for auto instrumentation\n */\nexport class FetchInstrumentation extends InstrumentationBase<FetchInstrumentationConfig> {\n  readonly component: string = 'fetch';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n  private _tasksCount = 0;\n\n  constructor(config: FetchInstrumentationConfig = {}) {\n    super('@opentelemetry/instrumentation-fetch', VERSION, config);\n  }\n\n  init(): void {}\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    const childSpan = this.tracer.startSpan(\n      'CORS Preflight',\n      {\n        startTime: corsPreFlightRequest[web.PerformanceTimingNames.FETCH_START],\n      },\n      api.trace.setSpan(api.context.active(), span)\n    );\n    if (!this.getConfig().ignoreNetworkEvents) {\n      web.addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n    }\n    childSpan.end(\n      corsPreFlightRequest[web.PerformanceTimingNames.RESPONSE_END]\n    );\n  }\n\n  /**\n   * Adds more attributes to span just before ending it\n   * @param span\n   * @param response\n   */\n  private _addFinalSpanAttributes(\n    span: api.Span,\n    response: FetchResponse\n  ): void {\n    const parsedUrl = web.parseUrl(response.url);\n    span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, response.status);\n    if (response.statusText != null) {\n      span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);\n    }\n    span.setAttribute(SEMATTRS_HTTP_HOST, parsedUrl.host);\n    span.setAttribute(\n      SEMATTRS_HTTP_SCHEME,\n      parsedUrl.protocol.replace(':', '')\n    );\n    if (typeof navigator !== 'undefined') {\n      span.setAttribute(SEMATTRS_HTTP_USER_AGENT, navigator.userAgent);\n    }\n  }\n\n  /**\n   * Add headers\n   * @param options\n   * @param spanUrl\n   */\n  private _addHeaders(options: Request | RequestInit, spanUrl: string): void {\n    if (\n      !web.shouldPropagateTraceHeaders(\n        spanUrl,\n        this.getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n\n    if (options instanceof Request) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Headers) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Map) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      options.headers = Object.assign({}, headers, options.headers || {});\n    }\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link FetchPluginConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      performance.clearResourceTimings();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Creates a new span\n   * @param url\n   * @param options\n   */\n  private _createSpan(\n    url: string,\n    options: Partial<Request | RequestInit> = {}\n  ): api.Span | undefined {\n    if (core.isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    const method = (options.method || 'GET').toUpperCase();\n    const spanName = `HTTP ${method}`;\n    return this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: {\n        [AttributeNames.COMPONENT]: this.moduleName,\n        [SEMATTRS_HTTP_METHOD]: method,\n        [SEMATTRS_HTTP_URL]: url,\n      },\n    });\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   * @param resourcesObserver\n   * @param endTime\n   */\n  private _findResourceAndAddNetworkEvents(\n    span: api.Span,\n    resourcesObserver: SpanData,\n    endTime: api.HrTime\n  ): void {\n    let resources: PerformanceResourceTiming[] = resourcesObserver.entries;\n    if (!resources.length) {\n      if (!performance.getEntriesByType) {\n        return;\n      }\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      resources = performance.getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n    const resource = web.getResource(\n      resourcesObserver.spanUrl,\n      resourcesObserver.startTime,\n      endTime,\n      resources,\n      this._usedResources,\n      'fetch'\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      if (!this.getConfig().ignoreNetworkEvents) {\n        web.addSpanNetworkEvents(span, mainRequest);\n      }\n    }\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming): void {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Finish span, add attributes, network events etc.\n   * @param span\n   * @param spanData\n   * @param response\n   */\n  private _endSpan(\n    span: api.Span,\n    spanData: SpanData,\n    response: FetchResponse\n  ) {\n    const endTime = core.millisToHrTime(Date.now());\n    const performanceEndTime = core.hrTime();\n    this._addFinalSpanAttributes(span, response);\n\n    setTimeout(() => {\n      spanData.observer?.disconnect();\n      this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);\n      this._tasksCount--;\n      this._clearResources();\n      span.end(endTime);\n    }, OBSERVER_WAIT_TIME_MS);\n  }\n\n  /**\n   * Patches the constructor of fetch\n   */\n  private _patchConstructor(): (original: typeof fetch) => typeof fetch {\n    return original => {\n      const plugin = this;\n      return function patchConstructor(\n        this: typeof globalThis,\n        ...args: Parameters<typeof fetch>\n      ): Promise<Response> {\n        const self = this;\n        const url = web.parseUrl(\n          args[0] instanceof Request ? args[0].url : String(args[0])\n        ).href;\n\n        const options = args[0] instanceof Request ? args[0] : args[1] || {};\n        const createdSpan = plugin._createSpan(url, options);\n        if (!createdSpan) {\n          return original.apply(this, args);\n        }\n        const spanData = plugin._prepareSpanData(url);\n\n        if (plugin.getConfig().measureRequestSize) {\n          getFetchBodyLength(...args)\n            .then(length => {\n              if (!length) return;\n\n              createdSpan.setAttribute(\n                SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n                length\n              );\n            })\n            .catch(error => {\n              plugin._diag.warn('getFetchBodyLength', error);\n            });\n        }\n\n        function endSpanOnError(span: api.Span, error: FetchError) {\n          plugin._applyAttributesAfterFetch(span, options, error);\n          plugin._endSpan(span, spanData, {\n            status: error.status || 0,\n            statusText: error.message,\n            url,\n          });\n        }\n\n        function endSpanOnSuccess(span: api.Span, response: Response) {\n          plugin._applyAttributesAfterFetch(span, options, response);\n          if (response.status >= 200 && response.status < 400) {\n            plugin._endSpan(span, spanData, response);\n          } else {\n            plugin._endSpan(span, spanData, {\n              status: response.status,\n              statusText: response.statusText,\n              url,\n            });\n          }\n        }\n\n        function onSuccess(\n          span: api.Span,\n          resolve: (value: Response | PromiseLike<Response>) => void,\n          response: Response\n        ): void {\n          try {\n            const resClone = response.clone();\n            const resClone4Hook = response.clone();\n            const body = resClone.body;\n            if (body) {\n              const reader = body.getReader();\n              const read = (): void => {\n                reader.read().then(\n                  ({ done }) => {\n                    if (done) {\n                      endSpanOnSuccess(span, resClone4Hook);\n                    } else {\n                      read();\n                    }\n                  },\n                  error => {\n                    endSpanOnError(span, error);\n                  }\n                );\n              };\n              read();\n            } else {\n              // some older browsers don't have .body implemented\n              endSpanOnSuccess(span, response);\n            }\n          } finally {\n            resolve(response);\n          }\n        }\n\n        function onError(\n          span: api.Span,\n          reject: (reason?: unknown) => void,\n          error: FetchError\n        ) {\n          try {\n            endSpanOnError(span, error);\n          } finally {\n            reject(error);\n          }\n        }\n\n        return new Promise((resolve, reject) => {\n          return api.context.with(\n            api.trace.setSpan(api.context.active(), createdSpan),\n            () => {\n              plugin._addHeaders(options, url);\n              plugin._tasksCount++;\n              // TypeScript complains about arrow function captured a this typed as globalThis\n              // ts(7041)\n              return original\n                .apply(\n                  self,\n                  options instanceof Request ? [options] : [url, options]\n                )\n                .then(\n                  onSuccess.bind(self, createdSpan, resolve),\n                  onError.bind(self, createdSpan, reject)\n                );\n            }\n          );\n        });\n      };\n    };\n  }\n\n  private _applyAttributesAfterFetch(\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ) {\n    const applyCustomAttributesOnSpan =\n      this.getConfig().applyCustomAttributesOnSpan;\n    if (applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, request, result),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * Prepares a span data - needed later for matching appropriate network\n   *     resources\n   * @param spanUrl\n   */\n  private _prepareSpanData(spanUrl: string): SpanData {\n    const startTime = core.hrTime();\n    const entries: PerformanceResourceTiming[] = [];\n    if (typeof PerformanceObserver !== 'function') {\n      return { entries, startTime, spanUrl };\n    }\n\n    const observer = new PerformanceObserver(list => {\n      const perfObsEntries = list.getEntries() as PerformanceResourceTiming[];\n      perfObsEntries.forEach(entry => {\n        if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {\n          entries.push(entry);\n        }\n      });\n    });\n    observer.observe({\n      entryTypes: ['resource'],\n    });\n    return { entries, observer, startTime, spanUrl };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable(): void {\n    if (isNode) {\n      // Node.js v18+ *does* have a global `fetch()`, but this package does not\n      // support instrumenting it.\n      this._diag.warn(\n        \"this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()\"\n      );\n      return;\n    }\n    if (isWrapped(fetch)) {\n      this._unwrap(_globalThis, 'fetch');\n      this._diag.debug('removing previous patch for constructor');\n    }\n    this._wrap(_globalThis, 'fetch', this._patchConstructor());\n  }\n\n  /**\n   * implements unpatch function\n   */\n  override disable(): void {\n    if (isNode) {\n      return;\n    }\n    this._unwrap(_globalThis, 'fetch');\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],
  "mappings": "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",
  "names": ["AttributeNames", "_a", "FetchInstrumentation", "_a", "__read"]
}
