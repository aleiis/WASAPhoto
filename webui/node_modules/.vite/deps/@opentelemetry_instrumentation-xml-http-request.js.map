{
  "version": 3,
  "sources": ["../../@opentelemetry/instrumentation-xml-http-request/src/enums/EventNames.ts", "../../@opentelemetry/instrumentation-xml-http-request/src/utils.ts", "../../@opentelemetry/instrumentation-xml-http-request/src/version.ts", "../../@opentelemetry/instrumentation-xml-http-request/src/enums/AttributeNames.ts", "../../@opentelemetry/instrumentation-xml-http-request/src/xhr.ts"],
  "sourcesContent": ["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport enum EventNames {\n  METHOD_OPEN = 'open',\n  METHOD_SEND = 'send',\n  EVENT_ABORT = 'abort',\n  EVENT_ERROR = 'error',\n  EVENT_LOAD = 'loaded',\n  EVENT_TIMEOUT = 'timeout',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Much of the logic here overlaps with the same utils file in opentelemetry-instrumentation-fetch\n// These may be unified in the future.\n\nimport * as api from '@opentelemetry/api';\n\nconst DIAG_LOGGER = api.diag.createComponentLogger({\n  namespace:\n    '@opentelemetry/opentelemetry-instrumentation-xml-http-request/utils',\n});\n\n/**\n * Helper function to determine payload content length for XHR requests\n * @param body\n * @returns content length\n */\nexport function getXHRBodyLength(\n  body: Document | XMLHttpRequestBodyInit\n): number | undefined {\n  if (typeof Document !== 'undefined' && body instanceof Document) {\n    return new XMLSerializer().serializeToString(document).length;\n  }\n  // XMLHttpRequestBodyInit expands to the following:\n  if (body instanceof Blob) {\n    return body.size;\n  }\n\n  // ArrayBuffer | ArrayBufferView\n  if ((body as any).byteLength !== undefined) {\n    return (body as any).byteLength as number;\n  }\n\n  if (body instanceof FormData) {\n    return getFormDataSize(body);\n  }\n\n  if (body instanceof URLSearchParams) {\n    return getByteLength(body.toString());\n  }\n\n  if (typeof body === 'string') {\n    return getByteLength(body);\n  }\n\n  DIAG_LOGGER.warn('unknown body type');\n  return undefined;\n}\n\nconst TEXT_ENCODER = new TextEncoder();\nfunction getByteLength(s: string): number {\n  return TEXT_ENCODER.encode(s).byteLength;\n}\n\nfunction getFormDataSize(formData: FormData): number {\n  let size = 0;\n  for (const [key, value] of formData.entries()) {\n    size += key.length;\n    if (value instanceof Blob) {\n      size += value.size;\n    } else {\n      size += value.length;\n    }\n  }\n  return size;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '0.56.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/semantic_conventions/http.md\n */\nexport enum AttributeNames {\n  HTTP_STATUS_TEXT = 'http.status_text',\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport { hrTime, isUrlIgnored, otperformance } from '@opentelemetry/core';\nimport {\n  SEMATTRS_HTTP_HOST,\n  SEMATTRS_HTTP_METHOD,\n  SEMATTRS_HTTP_SCHEME,\n  SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_HTTP_URL,\n  SEMATTRS_HTTP_USER_AGENT,\n  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n} from '@opentelemetry/semantic-conventions';\nimport {\n  addSpanNetworkEvents,\n  getResource,\n  PerformanceTimingNames as PTN,\n  shouldPropagateTraceHeaders,\n  parseUrl,\n} from '@opentelemetry/sdk-trace-web';\nimport { EventNames } from './enums/EventNames';\nimport {\n  OpenFunction,\n  PropagateTraceHeaderCorsUrls,\n  SendFunction,\n  XhrMem,\n} from './types';\nimport { getXHRBodyLength } from './utils';\nimport { VERSION } from './version';\nimport { AttributeNames } from './enums/AttributeNames';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nexport type XHRCustomAttributeFunction = (\n  span: api.Span,\n  xhr: XMLHttpRequest\n) => void;\n\n/**\n * XMLHttpRequest config\n */\nexport interface XMLHttpRequestInstrumentationConfig\n  extends InstrumentationConfig {\n  /**\n   * The number of timing resources is limited, after the limit\n   * (chrome 250, safari 150) the information is not collected anymore.\n   * The only way to prevent that is to regularly clean the resources\n   * whenever it is possible. This is needed only when PerformanceObserver\n   * is not available\n   */\n  clearTimingResources?: boolean;\n  /** URLs which should include trace headers when origin doesn't match */\n  propagateTraceHeaderCorsUrls?: PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: XHRCustomAttributeFunction;\n  /** Ignore adding network events as span events */\n  ignoreNetworkEvents?: boolean;\n  /** Measure outgoing request size */\n  measureRequestSize?: boolean;\n}\n\n/**\n * This class represents a XMLHttpRequest plugin for auto instrumentation\n */\nexport class XMLHttpRequestInstrumentation extends InstrumentationBase<XMLHttpRequestInstrumentationConfig> {\n  readonly component: string = 'xml-http-request';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n\n  private _tasksCount = 0;\n  private _xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n\n  constructor(config: XMLHttpRequestInstrumentationConfig = {}) {\n    super('@opentelemetry/instrumentation-xml-http-request', VERSION, config);\n  }\n\n  init() {}\n\n  /**\n   * Adds custom headers to XMLHttpRequest\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addHeaders(xhr: XMLHttpRequest, spanUrl: string) {\n    const url = parseUrl(spanUrl).href;\n    if (\n      !shouldPropagateTraceHeaders(\n        url,\n        this.getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    const headers: { [key: string]: unknown } = {};\n    api.propagation.inject(api.context.active(), headers);\n    Object.keys(headers).forEach(key => {\n      xhr.setRequestHeader(key, String(headers[key]));\n    });\n  }\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   * @private\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    api.context.with(api.trace.setSpan(api.context.active(), span), () => {\n      const childSpan = this.tracer.startSpan('CORS Preflight', {\n        startTime: corsPreFlightRequest[PTN.FETCH_START],\n      });\n      if (!this.getConfig().ignoreNetworkEvents) {\n        addSpanNetworkEvents(childSpan, corsPreFlightRequest);\n      }\n      childSpan.end(corsPreFlightRequest[PTN.RESPONSE_END]);\n    });\n  }\n\n  /**\n   * Add attributes when span is going to end\n   * @param span\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  _addFinalSpanAttributes(span: api.Span, xhrMem: XhrMem, spanUrl?: string) {\n    if (typeof spanUrl === 'string') {\n      const parsedUrl = parseUrl(spanUrl);\n      if (xhrMem.status !== undefined) {\n        span.setAttribute(SEMATTRS_HTTP_STATUS_CODE, xhrMem.status);\n      }\n      if (xhrMem.statusText !== undefined) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, xhrMem.statusText);\n      }\n      span.setAttribute(SEMATTRS_HTTP_HOST, parsedUrl.host);\n      span.setAttribute(\n        SEMATTRS_HTTP_SCHEME,\n        parsedUrl.protocol.replace(':', '')\n      );\n\n      // @TODO do we want to collect this or it will be collected earlier once only or\n      //    maybe when parent span is not available ?\n      span.setAttribute(SEMATTRS_HTTP_USER_AGENT, navigator.userAgent);\n    }\n  }\n\n  private _applyAttributesAfterXHR(span: api.Span, xhr: XMLHttpRequest) {\n    const applyCustomAttributesOnSpan =\n      this.getConfig().applyCustomAttributesOnSpan;\n    if (typeof applyCustomAttributesOnSpan === 'function') {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, xhr),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * will collect information about all resources created\n   * between \"send\" and \"end\" with additional waiting for main resource\n   * @param xhr\n   * @param spanUrl\n   * @private\n   */\n  private _addResourceObserver(xhr: XMLHttpRequest, spanUrl: string) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (\n      !xhrMem ||\n      typeof PerformanceObserver !== 'function' ||\n      typeof PerformanceResourceTiming !== 'function'\n    ) {\n      return;\n    }\n    xhrMem.createdResources = {\n      observer: new PerformanceObserver(list => {\n        const entries = list.getEntries() as PerformanceResourceTiming[];\n        const parsedUrl = parseUrl(spanUrl);\n\n        entries.forEach(entry => {\n          if (\n            entry.initiatorType === 'xmlhttprequest' &&\n            entry.name === parsedUrl.href\n          ) {\n            if (xhrMem.createdResources) {\n              xhrMem.createdResources.entries.push(entry);\n            }\n          }\n        });\n      }),\n      entries: [],\n    };\n    xhrMem.createdResources.observer.observe({\n      entryTypes: ['resource'],\n    });\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link XMLHttpRequestInstrumentationConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      (otperformance as unknown as Performance).clearResourceTimings();\n      this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   */\n  private _findResourceAndAddNetworkEvents(\n    xhrMem: XhrMem,\n    span: api.Span,\n    spanUrl?: string,\n    startTime?: api.HrTime,\n    endTime?: api.HrTime\n  ): void {\n    if (!spanUrl || !startTime || !endTime || !xhrMem.createdResources) {\n      return;\n    }\n\n    let resources: PerformanceResourceTiming[] =\n      xhrMem.createdResources.entries;\n\n    if (!resources || !resources.length) {\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      // ts thinks this is the perf_hooks module, but it is the browser performance api\n      resources = (otperformance as unknown as Performance).getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n\n    const resource = getResource(\n      parseUrl(spanUrl).href,\n      startTime,\n      endTime,\n      resources,\n      this._usedResources\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      if (!this.getConfig().ignoreNetworkEvents) {\n        addSpanNetworkEvents(span, mainRequest);\n      }\n    }\n  }\n\n  /**\n   * Removes the previous information about span.\n   * This might happened when the same xhr is used again.\n   * @param xhr\n   * @private\n   */\n  private _cleanPreviousSpanInformation(xhr: XMLHttpRequest) {\n    const xhrMem = this._xhrMem.get(xhr);\n    if (xhrMem) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n      if (callbackToRemoveEvents) {\n        callbackToRemoveEvents();\n      }\n      this._xhrMem.delete(xhr);\n    }\n  }\n\n  /**\n   * Creates a new span when method \"open\" is called\n   * @param xhr\n   * @param url\n   * @param method\n   * @private\n   */\n  private _createSpan(\n    xhr: XMLHttpRequest,\n    url: string,\n    method: string\n  ): api.Span | undefined {\n    if (isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    const spanName = method.toUpperCase();\n\n    const currentSpan = this.tracer.startSpan(spanName, {\n      kind: api.SpanKind.CLIENT,\n      attributes: {\n        [SEMATTRS_HTTP_METHOD]: method,\n        [SEMATTRS_HTTP_URL]: parseUrl(url).toString(),\n      },\n    });\n\n    currentSpan.addEvent(EventNames.METHOD_OPEN);\n\n    this._cleanPreviousSpanInformation(xhr);\n\n    this._xhrMem.set(xhr, {\n      span: currentSpan,\n      spanUrl: url,\n    });\n\n    return currentSpan;\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   * @private\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming) {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Patches the method open\n   * @private\n   */\n  protected _patchOpen() {\n    return (original: OpenFunction): OpenFunction => {\n      const plugin = this;\n      return function patchOpen(this: XMLHttpRequest, ...args): void {\n        const method: string = args[0];\n        const url: string = args[1];\n        plugin._createSpan(this, url, method);\n\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * Patches the method send\n   * @private\n   */\n  protected _patchSend() {\n    const plugin = this;\n\n    function endSpanTimeout(\n      eventName: string,\n      xhrMem: XhrMem,\n      performanceEndTime: api.HrTime,\n      endTime: number\n    ) {\n      const callbackToRemoveEvents = xhrMem.callbackToRemoveEvents;\n\n      if (typeof callbackToRemoveEvents === 'function') {\n        callbackToRemoveEvents();\n      }\n\n      const { span, spanUrl, sendStartTime } = xhrMem;\n\n      if (span) {\n        plugin._findResourceAndAddNetworkEvents(\n          xhrMem,\n          span,\n          spanUrl,\n          sendStartTime,\n          performanceEndTime\n        );\n        span.addEvent(eventName, endTime);\n        plugin._addFinalSpanAttributes(span, xhrMem, spanUrl);\n        span.end(endTime);\n        plugin._tasksCount--;\n      }\n      plugin._clearResources();\n    }\n\n    function endSpan(eventName: string, xhr: XMLHttpRequest) {\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (!xhrMem) {\n        return;\n      }\n      xhrMem.status = xhr.status;\n      xhrMem.statusText = xhr.statusText;\n      plugin._xhrMem.delete(xhr);\n\n      if (xhrMem.span) {\n        plugin._applyAttributesAfterXHR(xhrMem.span, xhr);\n      }\n      const performanceEndTime = hrTime();\n      const endTime = Date.now();\n\n      // the timeout is needed as observer doesn't have yet information\n      // when event \"load\" is called. Also the time may differ depends on\n      // browser and speed of computer\n      setTimeout(() => {\n        endSpanTimeout(eventName, xhrMem, performanceEndTime, endTime);\n      }, OBSERVER_WAIT_TIME_MS);\n    }\n\n    function onError(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ERROR, this);\n    }\n\n    function onAbort(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_ABORT, this);\n    }\n\n    function onTimeout(this: XMLHttpRequest) {\n      endSpan(EventNames.EVENT_TIMEOUT, this);\n    }\n\n    function onLoad(this: XMLHttpRequest) {\n      if (this.status < 299) {\n        endSpan(EventNames.EVENT_LOAD, this);\n      } else {\n        endSpan(EventNames.EVENT_ERROR, this);\n      }\n    }\n\n    function unregister(xhr: XMLHttpRequest) {\n      xhr.removeEventListener('abort', onAbort);\n      xhr.removeEventListener('error', onError);\n      xhr.removeEventListener('load', onLoad);\n      xhr.removeEventListener('timeout', onTimeout);\n      const xhrMem = plugin._xhrMem.get(xhr);\n      if (xhrMem) {\n        xhrMem.callbackToRemoveEvents = undefined;\n      }\n    }\n\n    return (original: SendFunction): SendFunction => {\n      return function patchSend(this: XMLHttpRequest, ...args): void {\n        const xhrMem = plugin._xhrMem.get(this);\n        if (!xhrMem) {\n          return original.apply(this, args);\n        }\n        const currentSpan = xhrMem.span;\n        const spanUrl = xhrMem.spanUrl;\n\n        if (currentSpan && spanUrl) {\n          if (plugin.getConfig().measureRequestSize && args?.[0]) {\n            const body = args[0];\n            const bodyLength = getXHRBodyLength(body);\n            if (bodyLength !== undefined) {\n              currentSpan.setAttribute(\n                SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n                bodyLength\n              );\n            }\n          }\n\n          api.context.with(\n            api.trace.setSpan(api.context.active(), currentSpan),\n            () => {\n              plugin._tasksCount++;\n              xhrMem.sendStartTime = hrTime();\n              currentSpan.addEvent(EventNames.METHOD_SEND);\n\n              this.addEventListener('abort', onAbort);\n              this.addEventListener('error', onError);\n              this.addEventListener('load', onLoad);\n              this.addEventListener('timeout', onTimeout);\n\n              xhrMem.callbackToRemoveEvents = () => {\n                unregister(this);\n                if (xhrMem.createdResources) {\n                  xhrMem.createdResources.observer.disconnect();\n                }\n              };\n              plugin._addHeaders(this, spanUrl);\n              plugin._addResourceObserver(this, spanUrl);\n            }\n          );\n        }\n        return original.apply(this, args);\n      };\n    };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable() {\n    this._diag.debug('applying patch to', this.moduleName, this.version);\n\n    if (isWrapped(XMLHttpRequest.prototype.open)) {\n      this._unwrap(XMLHttpRequest.prototype, 'open');\n      this._diag.debug('removing previous patch from method open');\n    }\n\n    if (isWrapped(XMLHttpRequest.prototype.send)) {\n      this._unwrap(XMLHttpRequest.prototype, 'send');\n      this._diag.debug('removing previous patch from method send');\n    }\n\n    this._wrap(XMLHttpRequest.prototype, 'open', this._patchOpen());\n    this._wrap(XMLHttpRequest.prototype, 'send', this._patchSend());\n  }\n\n  /**\n   * implements disable function\n   */\n  override disable() {\n    this._diag.debug('removing patch from', this.moduleName, this.version);\n\n    this._unwrap(XMLHttpRequest.prototype, 'open');\n    this._unwrap(XMLHttpRequest.prototype, 'send');\n\n    this._tasksCount = 0;\n    this._xhrMem = new WeakMap<XMLHttpRequest, XhrMem>();\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],
  "mappings": "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",
  "names": ["EventNames", "AttributeNames", "XMLHttpRequestInstrumentation"]
}
